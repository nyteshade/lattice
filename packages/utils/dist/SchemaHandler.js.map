{"version":3,"sources":["../src/SchemaHandler.js"],"names":["SchemaHandler","constructor","schema","resolvers","Error","types","_typeMap","hasType","nameOrRegex","Object","prototype","toString","apply","keys","filter","key","test","length","getType","name"],"mappings":";;;;;;;;;;;AAEA;;AACA;;;;AAIA;;;;;;;;AAQO,MAAMA,aAAN,CAAoB;AACzB;;;;;AAiBAC,cAAYC,MAAZ,EAA0CC,SAA1C,EAA8D;AAC5D,QAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,eAAS,0BAAYA,MAAZ,CAAT;AACA,WAAKC,SAAL,GAAiBA,SAAjB;AACD;;AAED,QAAI,CAAC,uBAASD,MAAT,CAAL,EAAuB;AACrB,YAAM,IAAIE,KAAJ,CAAU,+CAAV,CAAN;AACD;;AAED,SAAKF,MAAL,GAAcA,MAAd;AACD;;AAED;;;AAvBA;;;;;;;;AAwBA,MAAIG,KAAJ,GAAoB;AAClB,WAAO,KAAKH,MAAL,CAAYI,QAAnB;AACD;;AAEDC,UAAQC,WAAR,EAAsC;AACpC,QAAIC,OAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,KAA1B,CAAgCJ,WAAhC,MAAiD,iBAArD,EAAwE;AACtE,UAAIK,OAAO,oBAAY,KAAKX,MAAL,CAAYI,QAAxB,CAAX;;AAEA,aAAO,CAAC,CAACO,KAAKC,MAAL,CAAYC,OAAOP,YAAYQ,IAAZ,CAAiBD,GAAjB,CAAnB,EAA0CE,MAAnD;AACD,KAJD,MAKK,IAAI,OAAOT,WAAP,KAAuB,QAA3B,EAAqC;AACxC,aAAOA,eAAe,KAAKN,MAAL,CAAYI,QAAlC;AACD,KAFI,MAGA;AACH,aAAO,KAAP;AACD;AACF;;AAED;AACAY,UAAQC,IAAR,EAA8B;AAC5B,WAAO,KAAKd,KAAL,CAAWc,IAAX,CAAP;AACD;;AAED;AACA;AACA;;AAzDyB;QAAdnB,a,GAAAA,a","file":"SchemaHandler.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport { SyntaxTree } from '@nyteshade/lattice-core'\nimport { parse, graphqlSync, buildSchema, isSchema } from 'graphql'\n\nimport type { GraphQLSchema, Source } from 'graphql'\n\n/**\n * The SchemaHandler class is a lightweight wrapper around a GraphQLSchema\n * instance. Its purpose is to make navigating, altering and modifying the\n * schema easier. It does this by exposing some of the built-in methods of\n * the GraphQLSchema instance and by providing a suite of its own variants\n *\n * @since 3.0.0\n */\nexport class SchemaHandler {\n  /**\n   * The schema instance this handler wraps\n   *\n   * @type {GraphQLSchema}\n   */\n  schema: GraphQLSchema\n\n  /**\n   * An object that maps to the various resolvers that make this schema\n   * executable. Format varies depending on the engine in question. The\n   * Facebook reference implementation tends to use a slightly more flat\n   * layout than that of the Apollo server engine\n   *\n   * @type {Object}\n   */\n  resolvers: ?Object\n\n  constructor(schema: GraphQLSchema|string, resolvers?: Object) {\n    if (typeof schema === 'string') {\n      schema = buildSchema(schema)\n      this.resolvers = resolvers\n    }\n\n    if (!isSchema(schema)) {\n      throw new Error(\"Supplied schema object or string is not valid\");\n    }\n\n    this.schema = schema\n  }\n\n  // TODO fix @flow type\n  get types(): Object {\n    return this.schema._typeMap\n  }\n\n  hasType(nameOrRegex: string): boolean {\n    if (Object.prototype.toString.apply(nameOrRegex) === '[object RegExp]') {\n      let keys = Object.keys(this.schema._typeMap)\n\n      return !!keys.filter(key => nameOrRegex.test(key)).length\n    }\n    else if (typeof nameOrRegex === 'string') {\n      return nameOrRegex in this.schema._typeMap\n    }\n    else {\n      return false;\n    }\n  }\n\n  // TODO fix @flow type\n  getType(name: string): Object {\n    return this.types[name]\n  }\n\n  // todo\n  //  - addType (function)\n  //  - resolvers (map of types with resolvers for values)\n\n}\n"]}