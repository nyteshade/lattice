{"version":3,"sources":["../src/ModuleParser.js"],"names":["types","readdirAsync","readdir","statAsync","stat","typeOf","isString","isOfType","isPrimitive","isArray","isObject","extendsFrom","ModuleParser","constructor","directory","options","addLatticeTypes","resolve","directories","configs","skipped","valid","statSync","isDirectory","error","importConfigs","filePath","moduleContents","yellow","clear","require","ignore","log","trace","set","findLatticeConfigs","contents","gqlConfigs","stack","add","key","value","map","o","name","indexOf","push","has","delete","parse","modules","files","opts","Error","walk","file","get","reduce","last","cur","concat","forEach","config","sort","l","r","failOnError","size","printSkipped","parseSync","walkSync","outWrite","basename","message","replace","dir","filelist","extensions","exts","checkForPackageExtensions","pattern","arrayToPattern","stats","join","test","extname","flags","RegExp","toString","pkg","packageExts","Array"],"mappings":"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","file":"ModuleParser.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport fs, { readdirSync, statSync } from 'fs'\nimport path from 'path'\nimport * as types from './types'\nimport { merge } from 'lodash'\nimport {\n  promisify,\n  Deferred,\n  getLatticePrefs,\n  LatticeLogs as ll\n} from './utils'\n\nimport {\n  implementsLatticeSDLConfig,\n  isTypeConfig,\n  isScalarConfig,\n  isUnionConfig,\n  isInterfaceConfig\n} from './language'\n\nimport type {\n  LatticeConfig\n} from './language'\n\n// Promisify some bits\nconst readdirAsync = promisify(fs.readdir)\nconst statAsync = promisify(fs.stat)\n\n// Fetch some type checking bits from 'types'\nconst {\n  typeOf,\n  isString,\n  isOfType,\n  isPrimitive,\n  isArray,\n  isObject,\n  extendsFrom\n} = types;\n\ntype ModuleParserConfig = {\n  addLatticeTypes?: boolean\n}\n\n/**\n * The ModuleParser is a utility class designed to loop through and iterate\n * on a directory and pull out of each .js file found, any configs or exports\n * that are of LatticeConfig type.\n *\n * @class ModuleParser\n * @since 3.0.0\n */\nexport class ModuleParser {\n  /**\n   * An internal array of `LatticeConfig` extended classes found during\n   * either a `parse()` or `parseSync()` call.\n   *\n   * @memberof ModuleParser\n   * @type {Array<LatticeConfig>}\n   */\n  configs: Array<LatticeConfig>;\n\n  /**\n   * An array of strings holding loose GraphQL schema documents.\n   *\n   * @memberof ModuleParser\n   * @type {Array<string>}\n   */\n  looseGraphQL: Array<string> = [];\n\n  /**\n   * A map of skipped items on the last pass and the associated error that\n   * accompanies it.\n   */\n  skipped: Map<string, Error>;\n\n  /**\n   * A string denoting the directory on disk where `ModuleParser` should be\n   * searching for its classes.\n   *\n   * @memberof ModuleParser\n   * @type {string}\n   */\n  directory: string;\n\n  /**\n   * A map of which file contained which imports\n   *\n   * @memberof ModuleParser\n   * @type {Map<string, Array<LatticeConfig>>}\n   */\n  directories: Map<string, Array<LatticeConfig>>;\n\n  /**\n   * A boolean value denoting whether or not the `ModuleParser` instance is\n   * valid; i.e. the directory it points to actually exists and is a directory\n   *\n   * @type {boolean}\n   */\n  valid: boolean;\n\n  /**\n   * An object, optionally added during construction, that specifies some\n   * configuration about the ModuleParser and how it should do its job.\n   *\n   * Initially, the\n   *\n   * @type {Object}\n   */\n  options: Object = {};\n\n  /**\n   * The constructor\n   *\n   * @constructor\n   * @method ⎆⠀constructor\n   * @memberof ModuleParser\n   * @inner\n   *\n   * @param {string} directory a string path to a directory containing the\n   * various LatticeConfig extended classes that should be gathered.\n   */\n  constructor(\n    directory: string,\n    options: ModuleParserConfig = {addLatticeTypes: true}\n  ) {\n    this.directory = path.resolve(directory);\n    this.directories = new Map();\n    this.configs = [];\n    this.skipped = new Map();\n\n    merge(this.options, options);\n\n    try {\n      this.valid = fs.statSync(directory).isDirectory();\n    }\n    catch (error) {\n      this.valid = false;\n    }\n  }\n\n  /**\n   * Given a file path, this method will attempt to import/require the\n   * file in question and return the object it exported; whatever that\n   * may be.\n   *\n   * @method ModuleParser#⌾⠀importConfigs\n   * @since 3.0.0\n   *\n   * @param {string} filePath a path to pass to `require()`\n   *\n   * @return {Object} the object, or undefined, that was returned when\n   * it was `require()`'ed.\n   */\n  importConfigs(filePath: string): Object {\n    let moduleContents: Object = {};\n    let yellow: string = '\\x1b[33m'\n    let clear: string = '\\x1b[0m'\n\n    try {\n      moduleContents = require(filePath)\n    }\n    catch(ignore) {\n      ll.log(`${yellow}Skipping${clear} ${filePath}`)\n      ll.trace(ignore)\n      this.skipped.set(filePath, ignore)\n    }\n\n    return moduleContents;\n  }\n\n  /**\n   * Given an object, typically the result of a `require()` or `import`\n   * command, iterate over its contents and find any `GQLBase` derived\n   * exports. Continually, and recursively, build this list of classes out\n   * so that we can add them to a `GQLExpressMiddleware`.\n   *\n   * @method ModuleParser#⌾⠀findLatticeConfigs\n   * @since 3.0.0\n   *\n   * @param {Object} contents the object to parse for properties extending\n   * from `GQLBase`\n   * @param {Array<LatticeConfig>} gqlConfigs the results, allowed as a second\n   * parameter during recursion as a means to save state between calls\n   * @param {Set<LatticeConfig>} stack a `Set` used to slim down duplicates\n   *\n   * @return {Array<LatticeConfig>} a unique set of values that are currently\n   * being iterated over. Passed in as a third parameter to save state between\n   * calls during recursion.\n   */\n  findLatticeConfigs(\n    contents: Object,\n    gqlConfigs?: Array<LatticeConfig> = [],\n    stack?: Set<mixed> = new Set()\n  ): Array<LatticeConfig> {\n    // In order to prevent infinite object recursion, we should add the\n    // object being iterated over to our Set. At each new recursive level\n    // add the item being iterated over to the set and only recurse into\n    // if the item does not already exist in the stack itself.\n    stack.add(contents)\n\n    for (let key in contents) {\n      let value = contents[key];\n\n      if (implementsLatticeSDLConfig(value)) {\n        if (!~gqlConfigs.map(o => o.name).indexOf(value.name)) {\n          gqlConfigs.push(value)\n        }\n        else {\n          continue;\n        }\n      }\n\n      if ((isObject(value) || isArray(value)) && !stack.has(value)) {\n        gqlConfigs = this.findLatticeConfigs(value, gqlConfigs, stack);\n      }\n    }\n\n    // We remove the current iterable from our set as we leave this current\n    // recursive iteration.\n    stack.delete(contents)\n\n    return gqlConfigs\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   * in a resolved promise.\n   *\n   * @method ModuleParser#⌾⠀parse\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Promise<Array<GQLBase>>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  async parse(): Promise<Array<GQLBase>> {\n    let modules\n    let files\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    // @ComputedType\n    files = await this.constructor.walk(this.directory)\n    files\n      .map(file => {\n        this.directories.set(\n          file,\n          Array.from(this.findLatticeConfigs(this.importConfigs(file)))\n        )\n        return this.directories.get(file)\n      })\n      .reduce((last, cur) => last.concat(cur), [])\n      .forEach(config => set.add(config))\n\n    // Convert the set back into an array\n    this.configs = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.configs.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    // if (this.options.addLatticeTypes) {\n    //   this.configs.push(GQLJSON)\n    // }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.configs;\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   *\n   * @method ModuleParser#⌾⠀parseSync\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Array<GQLBase>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  parseSync(): Array<GQLBase> {\n    let modules: mixed;\n    let files: Array<string>;\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    files = this.constructor.walkSync(this.directory)\n    files\n      .map(file => {\n        this.directories.set(\n          file,\n          Array.from(this.findLatticeConfigs(this.importConfigs(file)))\n        )\n        return this.directories.get(file)\n      })\n      .reduce((last, cur) => last.concat(cur), [])\n      .forEach(config => set.add(config))\n\n    // Convert the set back into an array\n    this.configs = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.configs.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    // if (this.options.addLatticeTypes) {\n    //   this.configs.push(GQLJSON)\n    // }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.configs;\n  }\n\n  /**\n   * Prints the list of skipped files, their stack traces, and the errors\n   * denoting the reasons the files were skipped.\n   */\n  printSkipped() {\n    if (this.skipped.size) {\n      ll.outWrite('\\x1b[1;91m')\n      ll.outWrite('Skipped\\x1b[0;31m the following files\\n')\n\n      for (let [key, value] of this.skipped) {\n        ll.log(`${path.basename(key)}: ${value.message}`)\n        if (value.stack)\n          ll.log(value.stack.replace(/(^)/m, '$1  '))\n      }\n\n      ll.outWrite('\\x1b[0m')\n    }\n    else {\n      ll.log('\\x1b[1;32mNo files skipped\\x1b[0m')\n    }\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory.\n   *\n   * @method ModuleParser~⌾⠀walk\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Promise<Array<string>>} an array of existing absolute file paths\n   * found under the supplied `dir` directory.\n   */\n  static async walk(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Promise<Array<string>> {\n    let files = await readdirAsync(dir);\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = await statAsync(file)\n      if (stats.isDirectory()) {\n        filelist = await this.walk(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory. This version does this in a\n   * synchronous fashion.\n   *\n   * @method ModuleParser~⌾⠀walkSync\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Array<string>} an array of existing absolute file paths found\n   * under the supplied `dir` directory.\n   */\n  static walkSync(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Array<string> {\n    let files = readdirSync(dir)\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = statSync(file)\n      if (stats.isDirectory()) {\n        filelist = this.walkSync(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * The ModuleParser should only parse files that match the default or\n   * supplied file extensions. The default list contains .js, .jsx, .ts\n   * and .tsx; so JavaScript or TypeScript files and their JSX React\n   * counterparts\n   *\n   * Since the list is customizable for a usage, however, it makes sense\n   * to have a function that will match what is supplied rather than\n   * creating a constant expression to use instead.\n   *\n   * @static\n   * @memberof ModuleParser\n   * @function ⌾⠀arrayToPattern\n   * @since 2.13.0\n   *\n   * @param {Array<string>} extensions an array of extensions to\n   * convert to a regular expression that would pass for each\n   * @param {string} flags the value passed to a new RegExp denoting the\n   * flags used in the pattern; defaults to 'i' for case insensitivity\n   * @return {RegExp} a regular expression object matching the contents\n   * of the array of extensions or the default extensions and that will\n   * also match those values in a case insensitive manner\n   */\n  static arrayToPattern(\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx'],\n    flags: string = 'i'\n  ) {\n    return new RegExp(\n      extensions\n        .join('|')\n        .replace(/\\./g, '\\\\.')\n        .replace(/([\\|$])/g, '\\\\b$1'),\n      flags\n    )\n  }\n\n  /**\n   * Using the module `read-pkg-up`, finds the nearest package.json file\n   * and checks to see if it has a `.lattice.moduleParser.extensions'\n   * preference. If so, if the value is an array, that value is used,\n   * otherwise the value is wrapped in an array. If the optional parameter\n   * `toString` is `true` then `.toString()` will be invoked on any non\n   * Array values found; this behavior is the default\n   *\n   * @static\n   * @memberof ModuleParser\n   * @method ⌾⠀checkForPackageExtensions\n   * @since 2.13.0\n   *\n   * @param {boolean} toString true if any non-array values should have\n   * their `.toString()` method invoked before being wrapped in an Array;\n   * defaults to true\n   * @return {?Array<string>} null if no value is set for the property\n   * `lattice.ModuleParser.extensions` in `package.json` or the value\n   * of the setting if it is an array. Finally if the value is set but is\n   * not an array, the specified value wrapped in an array is returned\n   */\n  static checkForPackageExtensions(toString: boolean = true): ?Array<string> {\n    let pkg = getLatticePrefs()\n    let extensions = null\n\n    if (pkg.ModuleParser && pkg.ModuleParser.extensions) {\n      let packageExts = pkg.ModuleParser.extensions\n\n      if (Array.isArray(packageExts)) {\n        extensions = packageExts\n      }\n      else {\n        extensions = [toString ? packageExts.toString() : packageExts]\n      }\n    }\n\n    return extensions\n  }\n}\n\nexport default ModuleParser;\n"]}