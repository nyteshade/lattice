{"version":3,"sources":["../src/factory.js"],"names":["factory","configs","cfgs","Array","isArray","tree","EmptyDocument","map","schema","config","name","appendDefinitions","scalars","gqlTypes","rootTypes","filter","RegExp","queryType","_queryType","mutationType","_mutationType","subscriptionType","_subscriptionType","remainingTypes","_typeMap","i","test","typeKey","type","fields","field","_fields","resolve","execType","configKey","fn","error","console","message","stack","FactoryParsingError"],"mappings":";;;;;;;;;;QAQgBA,O,GAAAA,O;;AARhB;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,OAAT,CAAiBC,OAAjB,EAA0B;AAC/B,MAAIC,OAAOC,MAAMC,OAAN,CAAcH,OAAd,IAAyBA,OAAzB,GAAmC,CAACA,OAAD,CAA9C;AACA,MAAII,OAAO,uBAAWC,aAAX,EAAX;AACA,MAAIC,MAAM,EAAV;AACA,MAAIC,MAAJ;;AAEA,OAAK,IAAIC,MAAT,IAAmBP,IAAnB,EAAyB;AACvBK,QAAIE,OAAOC,IAAX,IAAmBD,MAAnB;AACAJ,SAAKM,iBAAL,CAAuBF,OAAOD,MAA9B;AACD;;AAED,MAAI;AACFA,aAASH,KAAKG,MAAd;;AAEA,QAAII,UAAU,6BAAd;AACA,QAAIC,WAAW,sCAAf;AACA,QAAIC,YAAY,6BAAhB;AACA,QAAIC,SAAS,IAAIC,MAAJ,CAAY,GAAEH,QAAS,IAAGD,OAAQ,IAAGE,SAAU,EAA/C,CAAb;;AAEA;AACA;AACA;AACA;AACA,QAAIG,YAAYT,OAAOU,UAAvB;AACA,QAAIC,eAAeX,OAAOY,aAA1B;AACA,QAAIC,mBAAmBb,OAAOc,iBAA9B;;AAEA,QAAIC,iBAAiB,oBACXf,OAAOgB,QADI,EAEhBT,MAFgB,CAETU,KAAK,CAACV,OAAOW,IAAP,CAAYD,CAAZ,CAFG,CAArB;;AAIA,SAAK,IAAIE,OAAT,IAAoBJ,cAApB,EAAoC;AAClC,UAAIK,OAAOpB,OAAOgB,QAAP,CAAgBG,OAAhB,CAAX;;AAEA,UAAIC,QAAQA,KAAKlB,IAAb,IAAqBH,IAAIqB,KAAKlB,IAAT,CAArB,IAAuCH,IAAIqB,KAAKlB,IAAT,EAAemB,MAA1D,EAAkE;AAChE,aAAK,IAAIC,KAAT,IAAkB,oBAAYvB,IAAIqB,KAAKlB,IAAT,EAAemB,MAA3B,CAAlB,EAAsD;AACpDD,eAAKG,OAAL,CAAaD,KAAb,EAAoBE,OAApB,GAA8BzB,IAAIqB,KAAKlB,IAAT,EAAemB,MAAf,CAAsBC,KAAtB,CAA9B;AACD;AACF;;AAED,WAAK,IAAI,CAACG,QAAD,EAAWC,SAAX,CAAT,IAAkC,CAC9B,CAACjB,SAAD,EAAY,SAAZ,CAD8B,EAE9B,CAACE,YAAD,EAAe,WAAf,CAF8B,EAG9B,CAACE,gBAAD,EAAmB,eAAnB,CAH8B,CAAlC,EAIG;AACD,YAAI,CAACY,QAAD,IAAa,CAAC1B,IAAIqB,KAAKlB,IAAT,EAAewB,SAAf,CAAlB,EAA6C;;AAE7C,aAAK,IAAIJ,KAAT,IAAkB,oBAAYvB,IAAIqB,KAAKlB,IAAT,EAAewB,SAAf,CAAZ,CAAlB,EAA0D;AACxD,cAAIC,KAAK5B,IAAIqB,KAAKlB,IAAT,EAAewB,SAAf,EAA0BJ,KAA1B,CAAT;AACAG,mBAASF,OAAT,CAAiBD,KAAjB,EAAwBE,OAAxB,GAAkCG,EAAlC;AACD;AACF;AACF;AACF,GA1CD,CA2CA,OAAOC,KAAP,EAAc;AACZC,YAAQD,KAAR,CAAc,UAAd,EAA0BA,MAAME,OAAN,IAAiB,gBAA3C;AACAD,YAAQD,KAAR,CAAcA,MAAMG,KAApB;AACA,UAAM,IAAIC,mBAAJ,CAAwBJ,KAAxB,CAAN;AACD;;AAED,SAAO5B,MAAP;AACD","file":"factory.js","sourceRoot":"src","sourcesContent":["import { SyntaxTree } from './SyntaxTree'\n\n// What's missing\n// concrete testing for interfaces, enums, unions and scalars\n// ability to discern these types from config objects, hopefully\n//   without the need to specify [type]\n// all the specification of [type] even if a config seems like\n// its something else\nexport function factory(configs) {\n  let cfgs = Array.isArray(configs) ? configs : [configs]\n  let tree = SyntaxTree.EmptyDocument()\n  let map = {}\n  let schema\n\n  for (let config of cfgs) {\n    map[config.name] = config\n    tree.appendDefinitions(config.schema)\n  }\n\n  try {\n    schema = tree.schema\n\n    let scalars = 'Int|Float|String|Boolean|ID'\n    let gqlTypes = '(__\\\\w+)|Object|Enum|Union|Interface'\n    let rootTypes = 'Query|Mutation|Subscription'\n    let filter = new RegExp(`${gqlTypes}|${scalars}|${rootTypes}`)\n\n    // We filter out the Query, Mutation and Subscription items from\n    // the ._typeMap names in the case that some clever programmer\n    // decides to rename them. They are then picked up here and\n    // processed separately.\n    let queryType = schema._queryType\n    let mutationType = schema._mutationType\n    let subscriptionType = schema._subscriptionType\n\n    let remainingTypes = Object\n        .keys(schema._typeMap)\n        .filter(i => !filter.test(i))\n\n    for (let typeKey of remainingTypes) {\n      let type = schema._typeMap[typeKey]\n\n      if (type && type.name && map[type.name] && map[type.name].fields) {\n        for (let field of Object.keys(map[type.name].fields)) {\n          type._fields[field].resolve = map[type.name].fields[field]\n        }\n      }\n\n      for (let [execType, configKey] of [\n          [queryType, 'queries'],\n          [mutationType, 'mutations'],\n          [subscriptionType, 'subscriptions']\n      ]) {\n        if (!execType || !map[type.name][configKey]) continue;\n\n        for (let field of Object.keys(map[type.name][configKey])) {\n          let fn = map[type.name][configKey][field]\n          execType._fields[field].resolve = fn\n        }\n      }\n    }\n  }\n  catch (error) {\n    console.error('[EEEEP!]', error.message || 'Unknown Error!')\n    console.error(error.stack)\n    throw new FactoryParsingError(error)\n  }\n\n  return schema\n}\n"]}