{"version":3,"sources":["../src/language.js"],"names":["implementsLatticeSDLConfig","isTypeConfig","isScalarConfig","isInterfaceConfig","isUnionConfig","representsType","config","hasRequireds","schema","name","hasOptionals","type","queries","mutations","subscriptions","parseValue","parseLiteral","serialize","meetsObjectType","resolveType","matches","validateExistence","tree","from","outline","types","enums","interfaces","unions","scalars"],"mappings":";;;;;QAyBgBA,0B,GAAAA,0B;QAoBAC,Y,GAAAA,Y;QAsBAC,c,GAAAA,c;QAmBAC,iB,GAAAA,iB;QAkBAC,a,GAAAA,a;QAsBAC,c,GAAAA,c;;AAzHhB;;AAQA;;;;;;;;;;;;AAYO,SAASL,0BAAT,CAAoCM,MAApC,EAA6D;AAClE,MAAIC,eAAeD,UAAUA,OAAOE,MAAjB,IAA2BF,OAAOG,IAArD;AACA,MAAIC,eAAeH,gBAAgBD,OAAOK,IAA1C;;AAEA,SAAO,CAAC,EAAGJ,gBAAgBG,YAAjB,IAAkCH,YAApC,CAAR;AACD;;AAED;;;;;;;;;;;;;AAhCA;;;;;AA6CO,SAASN,YAAT,CAAsBK,MAAtB,EAAiD;AACtD,MAAIC,eAAeP,2BAA2BM,MAA3B,CAAnB;AACA,MAAII,eAAeH,gBACdD,OAAOM,OADO,IAEdN,OAAOO,SAFO,IAGdP,OAAOQ,aAHZ;;AAKA,SAAO,CAAC,EAAGP,gBAAgBG,YAAjB,IAAkCH,YAApC,CAAR;AACD;;AAED;;;;;;;;;;;;AAYO,SAASL,cAAT,CAAwBI,MAAxB,EAAqD;AAC1D,SAAO,CAAC,EAAEN,2BAA2BM,MAA3B,KACLA,OAAOS,UADF,IAELT,OAAOU,YAFF,IAGLV,OAAOW,SAHJ,CAAR;AAID;;AAED;;;;;;;;;;;;AAYO,SAASd,iBAAT,CAA2BG,MAA3B,EAA2D;AAChE,MAAIY,kBAAkBjB,aAAaK,MAAb,CAAtB;;AAEA,SAAQY,mBAAmBZ,OAAOa,WAA3B,IAA2CD,eAAlD;AACD;;AAED;;;;;;;;;;;;AAYO,SAASd,aAAT,CAAuBE,MAAvB,EAAmD;AACxD,SAAO,CAAC,EAAEN,8BAA8BM,OAAOa,WAAvC,CAAR;AACD;;AAED;;;;;;;;;;;;;;;;;;AAkBO,SAASd,cAAT,CACLe,OADK,EAELd,MAFK,EAGLe,oBAA6B,KAHxB,EAIL;AACA,MAAI,CAACA,iBAAL,EAAwB;AACtB,WAAO,CAAC,EAAEf,UAAUA,OAAOG,IAAjB,IAAyBH,OAAOG,IAAP,KAAgBW,OAA3C,CAAR;AACD,GAFD,MAGK;AACH,QAAIZ,SAASF,UAAUA,OAAOE,MAA9B;AACA,QAAIc,OAAO,uBAAWC,IAAX,CAAgBjB,MAAhB,CAAX;AACA,QAAIkB,UAAUF,KAAKE,OAAnB;;AAEA,WAAOA,YACDA,QAAQC,KAAR,IAAiBD,QAAQC,KAAR,CAAcL,OAAd,CAAjB,IACDI,QAAQE,KAAR,IAAiBF,QAAQE,KAAR,CAAcN,OAAd,CADhB,IAEDI,QAAQG,UAAR,IAAsBH,QAAQG,UAAR,CAAmBP,OAAnB,CAFrB,IAGDI,QAAQI,MAAR,IAAkBJ,QAAQI,MAAR,CAAeR,OAAf,CAHjB,IAIDI,QAAQK,OAAR,IAAmBL,QAAQK,OAAR,CAAgBT,OAAhB,CALjB,CAAP;AAMD;AACF","file":"language.js","sourceRoot":"src","sourcesContent":["/**\n * @module Core\n * @flow\n */\n\nimport { SyntaxTree } from './SyntaxTree'\n\nimport type {\n  ValueNode,\n  GraphQLResolveInfo,\n  GraphQLObjectType\n} from 'graphql'\n\n/**\n * Checks to see if the object has a name, schema and/or type property. These\n * properties are used by the GraphQL Lattice Core factory to generate GraphQL\n * types\n *\n * @method Core.implementsLatticeSDLConfig\n * @since 3.0.0\n *\n * @param {LatticeNamedSDL} config an object conforming to the flow type\n * `LatticeNamedSDL`\n * @returns {boolean} true if the object conforms; false otherwise\n */\nexport function implementsLatticeSDLConfig(config: LatticeNamedSDL) {\n  let hasRequireds = config && config.schema && config.name\n  let hasOptionals = hasRequireds && config.type\n\n  return !!((hasRequireds && hasOptionals) || hasRequireds)\n}\n\n/**\n * Checks to see if the `config` object contains the expected fields\n * that make up a LatticeTypeConfig object. At the very least, for it\n * to work with the factory, it must have a name and schema string.\n *\n * @method Core.isTypeConfig\n * @since 3.0.0\n *\n * @param {LatticeTypeConfig} config an Object that contains at least\n * `LatticeNamedSDL` features.\n * @return {boolean} true if the object supplied meets the specifications\n * of a `LatticeTypeConfig` object.\n */\nexport function isTypeConfig(config: LatticeTypeConfig) {\n  let hasRequireds = implementsLatticeSDLConfig(config)\n  let hasOptionals = hasRequireds\n    && config.queries\n    && config.mutations\n    && config.subscriptions\n\n  return !!((hasRequireds && hasOptionals) || hasRequireds)\n}\n\n/**\n * Checks to see if the `config` object contains the expected fields\n * that make up a LatticeScalarConfig object.\n *\n * @method Core.isScalarConfig\n * @since 3.0.0\n *\n * @param {LatticeScalarConfig} config an Object that contains at least\n * `LatticeScalarConfig` properties\n * @return {boolean} true if the object supplied meets the specifications\n * of a `LatticeScalarConfig` object.\n */\nexport function isScalarConfig(config: LatticeScalarConfig) {\n  return !!(implementsLatticeSDLConfig(config)\n    && config.parseValue\n    && config.parseLiteral\n    && config.serialize)\n}\n\n/**\n * Checks to see if the `config` object contains the expected fields\n * that make up a `LatticeInterfaceConfig` object.\n *\n * @method Core.isInterfaceConfig\n * @since 3.0.0\n *\n * @param {LatticeInterfaceConfig} config an Object that contains at least\n * `LatticeInterfaceConfig` properties\n * @return {boolean} true if the object supplied meets the specifications\n * of a `LatticeInterfaceConfig` object.\n */\nexport function isInterfaceConfig(config: LatticeInterfaceConfig) {\n  let meetsObjectType = isTypeConfig(config)\n\n  return (meetsObjectType && config.resolveType) || meetsObjectType\n}\n\n/**\n * Checks to see if the `config` object contains the expected fields\n * that make up a `LatticeUnionConfig` object.\n *\n * @method Core.isUnionConfig\n * @since 3.0.0\n *\n * @param {LatticeUnionConfig} config an Object that contains at least\n * `LatticeUnionConfig` properties\n * @return {boolean} true if the object supplied meets the specifications\n * of a `LatticeUnionConfig` object.\n */\nexport function isUnionConfig(config: LatticeUnionConfig) {\n  return !!(implementsLatticeSDLConfig && config.resolveType)\n}\n\n/**\n * This function takes a type name as `matches` and checks the supplied\n * config object to see if the type matches. Optionally, a deeper check\n * that parses the schema of the config can be performed by supplying\n * true to `validateExistence`.\n *\n * @method Core.representsType\n * @since 3.0.0\n *\n * @param {string} matches the name of the type, enum, interface, scalar,\n * or union to search for\n * @param {LatticeTypeConfig | LatticeNamedSDL} config the config object\n * to search within for the named `match`\n * @param {boolean} validateExistence true if the schema should be parsed\n * rather than simply returning `config && config.name === matches`\n * @returns {boolean} true if the name of the GraphQL object matches the\n * supplied string.\n */\nexport function representsType(\n  matches: string,\n  config: Object,\n  validateExistence: boolean = false\n) {\n  if (!validateExistence) {\n    return !!(config && config.name && config.name === matches)\n  }\n  else {\n    let schema = config && config.schema\n    let tree = SyntaxTree.from(config)\n    let outline = tree.outline\n\n    return outline\n      && (outline.types && outline.types[matches]\n      || outline.enums && outline.enums[matches]\n      || outline.interfaces && outline.interfaces[matches]\n      || outline.unions && outline.unions[matches]\n      || outline.scalars && outline.scalars[matches])\n  }\n}\n\nexport type LatticeResolverBlock = {\n  [field: string | Symbol]: Function\n}\n\nexport interface LatticeNamedSDL {\n  name: string,\n  schema: string,\n  type?: GraphQLType | string\n}\n\nexport type LatticeConfig = LatticeNamedSDL\n  | LatticeTypeConfig\n  | LatticeScalarConfig<*>\n  | LatticeInterfaceConfig\n  | LatticeUnionConfig\n  | LatticeEnumConfig;\n\nexport type LatticeTypeConfig = {\n  name: string,\n  schema: string,\n  type?: GraphQLType | string,\n  queries?: LatticeResolverBlock,\n  mutations?: LatticeResolverBlock,\n  subscriptions?: LatticeResolverBlock\n}\n\nexport type LatticeInterfaceConfig = {\n  name: string,\n  schema: string,\n  type?: GraphQLType | string,\n  resolveType?: (value: any, info?: GraphQLResolveInfo) => ?GraphQLObjectType\n}\n\nexport type LatticeScalarConfig<InternalType> = {\n  name: string,\n  schema: string,\n  type?: GraphQLType | string,\n  serialize: (value: mixed) => ?InternalType;\n  parseValue?: (value: mixed) => ?InternalType;\n  parseLiteral?: (\n    valueNode: ValueNode,\n    variables: ?ObjMap<mixed>,\n  ) => ?InternalType\n}\n\nexport type LatticeEnumValueMap = {\n  [name: string | Symbol]: any\n}\n\nexport type LatticeEnumConfig = {\n  name: string,\n  schema: string,\n  type?: GraphQLType | string,\n  values: LatticeEnumValueMap\n}\n\nexport type LatticeUnionConfig = {\n  name: string,\n  schema: string,\n  type?: GraphQLType | string,\n  types: Array<GraphQLObjectType>,\n  resolveType?: (value: any, info?: GraphQLResolveInfo) => ?GraphQLObjectType\n}\n"]}