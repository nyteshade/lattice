{"version":3,"sources":["../src/SyntaxTree.js"],"names":["AST_KEY","SyntaxTree","constructor","schemaOrASTOrST","setAST","ast","value","type","st","String","name","ignore","Object","updateAST","newAST","error","schema","appendDefinitions","source","from","set","definitions","map","definition","add","theirs","ours","find","index","indexOf","has","push","kind","interfaces","concat","directives","fields","side","values","consumeDefinition","astOrSyntaxTree","definitionType","tree","left","right","Error","splice","consumeAllExecutableTypes","types","_queryType","_mutationType","_subscriptionType","readType","typeNode","setName","result","required","array","undefined","outline","enums","unions","inputs","scalars","out","key","forEach","field","arguments","args","arg","_interface","definitionName","findDefinition","toString","QUERY","MUTATION","SUBSCRIPTION","mixed","fromSDL","fromAST","sdl","findInASTArrayByNameValue","findField","fieldName","meta","nullable","findEnumDefinition","enumDefinitionName","enumValueName","isRegExp","test","regex","RegExp","flags","reducer","last","cur","i","reduce","EmptyQuery","EmptyMutation","EmptyDocument","loc","start","end"],"mappings":"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","file":"SyntaxTree.js","sourceRoot":"src","sourcesContent":["// @flow\n// @module SyntaxTree\n\nimport { typeOf } from './types'\nimport { print, parse, buildASTSchema } from 'graphql'\nimport { merge } from 'lodash'\nimport { LatticeLogs as ll } from './utils'\n\nimport type { GraphQLObjectType, GraphQLType } from 'graphql/type/definition'\nimport type { GraphQLSchema } from 'graphql/type/schema'\nimport type {\n  ASTNode,\n  DocumentNode,\n  DefinitionNode,\n  EnumTypeDefinitionNode,\n  EnumValueDefinitionNode,\n  FieldDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  ObjectTypeDefinitionNode,\n  TypeDefinitionNode,\n  TypeNode,\n  UnionTypeDefinitionNode\n} from 'graphql/language/ast'\n\n\n// Shorthand for the key storing the internal AST\n// @prop\nconst AST_KEY = Symbol.for('Internal AST Storage Key');\n\n/**\n * A parser and processor of GraphQL IDL Abstract Syntax Trees. Used to combine\n * a set of {@link GQLBase} class instances.\n *\n * @class SyntaxTree\n */\nexport class SyntaxTree\n{\n  /**\n   * Constructs a new `SyntaxTree` object. If a string schema is supplied or\n   * an already parsed AST object, either of which is valid GraphQL IDL, then\n   * its parsed AST will be the internals of this object.\n   *\n   * @constructor\n   * @memberof SyntaxTree\n   * @method ⎆⠀constructor\n   *\n   * @param {string|DocumentNode|SyntaxTree} schemaOrASTOrST if supplied the\n   * tree will be constructed with the contents of the data. If a string\n   * of IDL is given, it will be parsed. If an AST is given, it will be\n   * verified. If a SyntaxTree is supplied, it will be copied.\n   */\n  constructor(schemaOrASTOrST?: string | DocumentNode | SyntaxTree) {\n    // $ComputedType\n    this[AST_KEY] = {};\n\n    if (schemaOrASTOrST) {\n      this.setAST(schemaOrASTOrST);\n    }\n  }\n\n  /**\n   * Getter that retrieves the abstract syntax tree created by `graphql.parse`\n   * when it is presented with a valid string of IDL.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀ast\n   *\n   * @return {DocumentNode} a GraphQL AST object\n   */\n  get ast(): DocumentNode {\n    // $ComputedType\n    return this[AST_KEY];\n  }\n\n  /**\n   * Setter that assigns the abstract syntax tree, typically created by\n   * `graphql.parse` when given a valid string of IDL.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬆︎⠀ast\n   *\n   * @param {Object} value a valid AST object. Other operations will act\n   * in an undefined manner should this object not be a valid AST\n   */\n  set ast(value: DocumentNode): void {\n    // $ComputedType\n    this[AST_KEY] = value;\n  }\n\n  /**\n   * Sets the underlying AST object with either schema which will be parsed\n   * into a valid AST or an existing AST. Previous ast values will be erased.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀setAST\n   *\n   * @param {string|Object} schemaOrAST a valid GraphQL IDL schema or a\n   * previosuly parsed or compatible GraphQL IDL AST object.\n   * @return {SyntaxTree} this for inlining.\n   */\n  setAST(schemaOrASTOrST: string | DocumentNode | SyntaxTree): SyntaxTree {\n    this.ast = {};\n\n    const type = typeOf(schemaOrASTOrST);\n    let ast: DocumentNode;\n    let st: SyntaxTree;\n\n    switch (type) {\n      case String.name:\n        try {\n          ast = parse((schemaOrASTOrST: string));\n\n          merge(this.ast, ast);\n        }\n        catch (ignore) { /* Ignore this error */ }\n\n        break;\n      case Object.name:\n        ast = (schemaOrASTOrST: DocumentNode);\n\n        try {\n          ast = parse(print(ast));\n          merge(this.ast, ast);\n        }\n        catch (ignore) { /* Ignore this error */ }\n\n        break;\n      case SyntaxTree.name:\n        st = (schemaOrASTOrST: SyntaxTree);\n\n        merge(this.ast, st.ast);\n\n        break;\n    }\n\n    return this;\n  }\n\n  /**\n   * As passthru update method that works on the internal AST object. If\n   * an error occurs, the update is skipped. An error can occur if adding the\n   * changes would make the AST invalid. In such a case, the error is logged\n   * to the error console.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀updateAST\n   *\n   * @param {DocumentNode} ast an existing GraphQL IDL AST object that will be\n   * merged on top of the existing tree using _.merge()\n   * @return {SyntaxTree} this for inlining.\n   */\n  updateAST(ast: DocumentNode): SyntaxTree {\n    if (typeOf(ast) === Object.name) {\n      let newAST: DocumentNode = merge({}, this.ast, ast);\n\n      try {\n        print(newAST);\n        this.ast = merge(this.ast, ast);\n      }\n      catch (error) {\n        ll.error('[SyntaxTree] Failed to updateAST with %o', ast);\n        ll.error('Resulting object would be %o', newAST);\n        ll.error(error);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * The `GraphQLSchema` produced by this getter is sufficient to work with\n   * tools like express-graphql or Apollo server but is more than likely not\n   * executable. Use `SchemaUtils#injectAll` to populate this schema with\n   * resolvers and docs and the rest.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀schema\n   *\n   * @return {GraphQLSchema} a GraphQLSchema object instance based on the\n   * internal AST as built\n   */\n  get schema(): GraphQLSchema {\n    return buildASTSchema(this.ast)\n  }\n\n  /**\n   * Appends all definitions from another AST to this one. The method will\n   * actually create a copy using SyntaxTree.from() so the input types can\n   * be any one of a valid GraphQL IDL schema string, a GraphQL IDL AST or\n   * another SyntaxTree object instance.\n   *\n   * Definitions of the same name but different kinds will be replaced by the\n   * new copy. Those of the same kind and name will be merged (TODO handle more\n   * than ObjectTypeDefinition kinds when merging; currently other types are\n   * overwritten).\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀appendDefinitions\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST an instance of one of\n   * the valid types for SyntaxTree.from() that can be used to create or\n   * duplicate the source from which to copy definitions.\n   * @return {SyntaxTree} this for inlining\n   */\n  appendDefinitions(\n    schemaOrASTOrST: string | DocumentNode | SyntaxTree\n  ): SyntaxTree {\n    const source = SyntaxTree.from(schemaOrASTOrST);\n    const set = new Set();\n\n    this.ast.definitions.map((definition: DefinitionNode) => {\n      set.add(definition.name.value);\n    })\n\n    if (source && source.ast.definitions && this.ast.definitions) {\n      for (let theirs: DocumentNode of (source: any)) {\n        let name = theirs.name.value;\n        let ours: DocumentNode = this.find(name);\n        let index = ours && this.ast.definitions.indexOf(ours) || -1;\n\n        // We don't yet have one with that name\n        if (!set.has(name)) {\n          set.add(name);\n          this.ast.definitions.push(theirs);\n        }\n\n        // We do have one with that name\n        else {\n          // The kinds aren't the same, just replace theirs with ours\n          // TODO add a prefs line that offers different ways of dealing\n          // with this merged situation. First obvious solution would be\n          // to THROW, the other option is use the SOURCE or EXISTING\n          if (theirs.kind !== ours.kind) {\n            // replace with the new one\n            this.ast.definitions[index] = theirs;\n          }\n\n          // The kinds are the same, lets just merge their fields\n          else {\n            // merge the properties of the same types.\n            switch (theirs.kind) {\n              case 'ObjectTypeDefinition':\n                ours.interfaces = [].concat(ours.interfaces, theirs.interfaces)\n                ours.directives = [].concat(ours.directives, theirs.directives)\n                ours.fields = [].concat(ours.fields, theirs.fields)\n\n                break;\n              case 'EnumTypeDefinition':\n                let map = new Map()\n\n                for (\n                  let side: EnumValueDefinitionNode of\n                  ours.values.concat(theirs.values)\n                ) {\n                  if (!map.has(side.name.value)) {\n                    map.set(side.name.value, side)\n                  }\n                }\n\n                ours.values = Array.from(map.values())\n\n                break;\n              default:\n                // Since we don't support other types yet. Let's replace\n                this.ast.definitions[index] = theirs;\n                break;\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * This method finds the Query type definitions in the supplied AST or\n   * SyntaxTree objects, takes its defined fields and adds it to the current\n   * instances. If this instance does not have a Query type defined but the\n   * supplied object does, then the supplied one is moved over. If neither\n   * has a query handler, then nothing happens.\n   *\n   * NOTE this *removes* the Query type definition from the supplied AST or\n   * SyntaxTree object.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀consumeDefinition\n   *\n   * @param {Object|SyntaxTree} astOrSyntaxTree a valid GraphQL IDL AST or\n   * an instance of SyntaxTree that represents one.\n   * @param {string|RegExp} definitionType a valid search input as would be\n   * accepted for the #find() method of this object.\n   * @return {SyntaxTree} returns this for inlining\n   */\n  consumeDefinition(\n    astOrSyntaxTree: DocumentNode | SyntaxTree,\n    definitionType: string | RegExp = \"Query\"\n  ): SyntaxTree {\n    if (!astOrSyntaxTree || !this.ast || !this.ast.definitions) { return this }\n\n      const tree: SyntaxTree = (typeOf(astOrSyntaxTree) === SyntaxTree.name\n        ? astOrSyntaxTree\n        : SyntaxTree.from(astOrSyntaxTree));\n      let left = this.find(definitionType);\n      let right = tree.find(definitionType) || null;\n\n    if (!tree) {\n      ll.error('There seems to be something wrong with your tree')\n      ll.error(new Error('Missing tree; continuing...'));\n      return this;\n    }\n\n    if (!right) { return this }\n\n    if (!left) {\n      this.ast.definitions.push(right);\n\n      // Remove the copied definition from the source\n      tree.ast.definitions.splice(tree.ast.definitions.indexOf(right), 1);\n\n      return this;\n    }\n\n    // TODO support other types aside from ObjectTypeDefinitions\n    // TODO see if there is a better way to achieve this with built-in\n    // graphql code someplace\n    switch(left.kind) {\n      case 'ObjectTypeDefinition':\n        if (left.interfaces && right.interfaces) {\n          left.interfaces = [].concat(left.interfaces, right.interfaces);\n        }\n\n        if (left.directives && right.directives) {\n          left.directives = [].concat(left.directives, right.directives);\n        }\n\n        if (left.fields && right.fields) {\n          left.fields = [].concat(left.fields, right.fields);\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    // Remove the copied definition from the source\n    tree.ast.definitions.splice(tree.ast.definitions.indexOf(right), 1);\n\n    return this;\n  }\n\n  /**\n   * A function that looks into the supplied `SyntaxTree` or AST and\n   * tries to consume or merge all the executable shared type fields;\n   * namely Query, Mutation and Subscription. If given an instance of\n   * `SyntaxTree` it\n   */\n  consumeAllExecutableTypes(astOrSyntaxTree: DocumentNode | SyntaxTree) {\n    let types = []\n    let schema\n\n    if (typeOf(astOrSyntaxTree) === SyntaxTree.name) {\n      schema = astOrSyntaxTree.schema\n    }\n    else {\n      schema = SyntaxTree.from(astOrSyntaxTree).schema\n    }\n\n    types.push(schema._queryType)\n    types.push(schema._mutationType)\n    types.push(schema._subscriptionType)\n\n    for (let type of types) {\n      this.consumeDefinition(astOrSyntaxTree, type)\n    }\n\n    return this;\n  }\n\n\n  /**\n   * When iterating over an instance of SyntaxTree, you are actually\n   * iterating over the definitions of the SyntaxTree if there are any;\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method *[Symbol.iterator]\n   *\n   * @return {TypeDefinitionNode} an instance of a TypeDefinitionNode; see\n   * graphql/language/ast.js.flow for more information\n   * @ComputedType\n   */\n  *[Symbol.iterator](): TypeDefinitionNode {\n    if (this[AST_KEY].definitions) {\n      return yield* this[AST_KEY].definitions;\n    }\n    else {\n      return yield* this;\n    }\n  }\n\n  /**\n   * AST DocumentNode types can be annoyingly nested within themselves\n   * Examples are `NonNullType -> ListType -> \"true\" type`. And variations\n   * thereof. Rather than repeating this code elsewhere, a nice function\n   * to examine and derive that information is presented below.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method readType\n   *\n   * @param {TypeNode} typeNode the object in a DocumentNode keyed as `type`\n   */\n  static readType(typeNode: TypeNode, setName: ?String): {\n    required: boolean,\n    array: boolean,\n    type: string,\n    name: ?string\n  } {\n    let result: Object = {\n      required: typeNode.kind === 'NonNullType',\n      array: typeNode.kind === 'ListType'\n        || (typeNode.type && typeNode.type.kind === 'ListType')\n        || false,\n      type:\n        (typeNode.type\n         && typeNode.type.type\n         && typeNode.type.type.type\n         && typeNode.type.type.type.name\n         && typeNode.type.type.type.name.value)\n        ||\n        (typeNode.type\n         && typeNode.type.type\n         && typeNode.type.type.name\n         && typeNode.type.type.name.value)\n        || (typeNode.type && typeNode.type.name && typeNode.type.name.value)\n        || (typeNode.name && typeNode.name.value)\n        || undefined\n    }\n\n    if (setName) {\n      result.name = setName\n    }\n\n    return result;\n  }\n\n  /**\n   * Getter that builds a small outline object denoting the schema being\n   * processed. If you have a schema that looks like the following:\n   *\n   * ```javascript\n   * let st = SyntaxTree.from(`\n   *   type Contrived {\n   *     name: String\n   *     age: Int\n   *   }\n   *\n   *   type Query {\n   *     getContrived: Contrived\n   *   }\n   * `)\n   * let outline = st.outline\n   * ```\n   *\n   * You will end up with an object that looks like the following:\n   *\n   * ```javascript\n   * {\n   *   Contrived: { name: 'String', age: 'Int' },\n   *   Query: { getContrived: 'Contrived' }\n   * }\n   * ```\n   *\n   * As may be evidenced by the example above, the name of the type is\n   * represented by an object where the name of each field (sans arguments)\n   * is mapped to a string denoting the type.\n   */\n  get outline(): Object {\n    let outline = {\n      interfaces:{},\n      types:{},\n      enums:{},\n      unions:{},\n      inputs:{},\n      scalars:[]\n    }\n    let interfaces = Symbol.for('interfaces')\n\n    for (let definition: DefinitionNode of this) {\n      let out\n\n      switch (definition.kind) {\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n        case 'ObjectTypeDefinition':\n          let key = 'InterfaceTypeDefinition' === definition.kind\n            ? 'interfaces'\n            : ('ObjectTypeDefinition' === definition.kind)\n              ? 'types'\n              : 'inputs'\n          out = outline[key][definition.name.value] = {}\n          definition.fields.forEach(\n            (field: FieldDefinitionNode) => {\n              let name = field.name.value\n              out[name] = SyntaxTree.readType(field.type, name)\n\n              if (field.arguments) {\n                out[name].args = field.arguments.map(arg => {\n                  return {\n                    [arg.name.value]: SyntaxTree.readType(\n                      arg.type,\n                      arg.name.value\n                    )\n                  }\n                })\n              }\n              else {\n                out[name].args = []\n              }\n            }\n          )\n\n          if (definition.interfaces) {\n            out = (out[interfaces] = out[interfaces] || [])\n\n            definition.interfaces.forEach(\n              _interface => out.push(_interface.name.value)\n            )\n          }\n\n          break;\n\n        case 'EnumTypeDefinition':\n          out = outline.enums[definition.name.value] = []\n          definition.values.forEach(\n            value => out[value.name.value] = value.name.value\n          )\n          break;\n\n        case 'UnionTypeDefinition':\n          out = outline.unions[definition.name.value] = []\n          definition.types.forEach(\n            type => out.push(type.name.value)\n          )\n          break;\n\n        case 'ScalarTypeDefinition':\n          out = outline.scalars\n          out.push(definition.name.value)\n          break;\n      }\n    }\n\n    return outline\n  }\n\n  /**\n   * Iterate through the definitions of the AST if there are any. For each\n   * definition the name property's value field is compared to the supplied\n   * definitionName. The definitionName can be a string or a regular\n   * expression if finer granularity is desired.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀find\n   *\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @return {Object|null} a reference to the internal definition field or\n   * null if one with a matching name could not be found.\n   */\n  find(definitionName: string|RegExp): Object | null {\n    // $ComputedType\n    return SyntaxTree.findDefinition(this[AST_KEY], definitionName);\n  }\n\n  /**\n   * SyntaxTree instances that are toString()'ed will have the graphql method\n   * print() called on them to convert their internal structures back to a\n   * GraphQL IDL schema syntax. If the object is in an invalid state, it WILL\n   * throw an error.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀toString\n   *\n   * @return {string} the AST for the tree parsed back into a string\n   */\n  toString(): string {\n    // $ComputedType\n    return print(this[AST_KEY]);\n  }\n\n  /**\n   * A runtime constant denoting a query type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀QUERY\n   * @readonly\n   * @const\n   */\n  static get QUERY(): string { return 'Query' }\n\n  /**\n   * A runtime constant denoting a mutation type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀MUTATION\n   * @readonly\n   * @const\n   */\n  static get MUTATION(): string { return 'Mutation' }\n\n    /**\n   * A runtime constant denoting a subscription type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method SUBSCRIPTION\n   * @readonly\n   * @const\n   */\n  static get SUBSCRIPTION(): string { return 'Subscription' }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof SyntaxTree\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof SyntaxTree\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Given one of, a valid GraphQL IDL schema string, a valid GraphQL AST or\n   * an instance of SyntaxTree, the static from() method will create a new\n   * instance of the SyntaxTree with the values you provide.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀from\n   *\n   * @param {String|DocumentNode|SyntaxTree} mixed an instance of one of the\n   * valid* types specified above. Everything else will result in a null value.\n   * @return {SyntaxTree} a newly created and populated instance of SyntaxTree\n   * or null if an invalid type was supplied for mixed.\n   */\n  static from(mixed: string | DocumentNode | SyntaxTree): SyntaxTree | null {\n    let schema: string;\n    let ast: Object;\n\n    switch (typeOf(mixed)) {\n      case String.name:\n        schema = (mixed: any);\n        try { parse(schema) } catch(error) { ll.error(error); return null; }\n\n        return SyntaxTree.fromSDL(String(schema));\n      case Object.name:\n        ast = (mixed: any);\n        try { print(ast) } catch(error) { return null; }\n\n        return SyntaxTree.fromAST(ast);\n      case SyntaxTree.name:\n        schema = mixed.toString();\n\n        return SyntaxTree.from(schema);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Generates a new instance of SyntaxTree from the supplied, valid, GraphQL\n   * schema. This method does not perform try/catch validation and if an\n   * invalid GraphQL schema is supplied an error will be thrown.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀fromSDL\n   *\n   * @param {string} schema a valid GraphQL IDL schema string.\n   * @return {SyntaxTree} a new instance of SyntaxTree initialized with a\n   * parsed response from require('graphql').parse().\n   */\n  static fromSDL(sdl: string): SyntaxTree {\n    const ast = parse(sdl);\n    let tree = new SyntaxTree(ast);\n\n    return tree;\n  }\n\n  /**\n   * Generates a new instance of SyntaxTree from the supplied, valid, GraphQL\n   * schema. This method does not perform try/catch validation and if an\n   * invalid GraphQL schema is supplied an error will be thrown.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀fromAST\n   *\n   * @param {DocumentNode} ast a valid GraphQL AST object.\n   * @return {SyntaxTree} a new instance of SyntaxTree initialized with a\n   * supplied abstract syntax tree generated by require('graphql').parse() or\n   * other compatible method.\n   */\n  static fromAST(ast: DocumentNode): SyntaxTree | null {\n    // TODO make sure that we aren't losing anything here\n    const source = parse(print(ast));\n    let tree = new SyntaxTree(source);\n\n    return source ? tree : null;\n  }\n\n  /**\n   * Iterate through the definitions of the AST if there are any. For each\n   * definition the name property's value field is compared to the supplied\n   * definitionName. The definitionName can be a string or a regular\n   * expression if finer granularity is desired.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findDefinition\n   *\n   * @param {DocumentNode} ast an abstract syntax tree object created\n   * from a GQL SDL\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @return {Object|null} a reference to the internal definition field or\n   * null if one with a matching name could not be found.\n   */\n  static findDefinition(ast: DocumentNode, definitionName: string | RegExp) {\n    return this.findInASTArrayByNameValue(\n      ast.definitions,\n      definitionName\n    );\n  }\n\n  /**\n   * Iterate through the fields of a definition AST if there are any. For each\n   * field, the name property's value field is compared to the supplied\n   * fieldName. The fieldName can be a string or a regular expression if\n   * finer granularity is desired.\n   *\n   * Before iterating over the fields, however, the definition is found using\n   * `SyntaxTree#findDefinition`. If either the field or definition are not\n   * found, null is returned.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findField\n   * @since 2.7.0\n   *\n   * @param {DocumentNode} ast an abstract syntax tree object created\n   * from a GQL SDL\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @param {string|RegExp} fieldName a string or regular expression used\n   * to match against the field name field in a given AST.\n   * @return {Object|null} an object containing two keys, the first being\n   * `field` which points to the requested AST definition field. The second\n   * being `meta` which contains three commonly requested bits of data; `name`,\n   * `type` and `nullable`. Non-nullable fields have their actual type wrapped\n   * in a `NonNullType` GraphQL construct. The actual field type is contained\n   * within. The meta object surfaces those values for easy use.\n   */\n  static findField(\n    ast: DocumentNode,\n    definitionName: string | RegExp,\n    fieldName: string | RegExp\n  ) {\n    const definition = this.findDefinition(ast, definitionName)\n    let meta;\n\n    if (!definition || !definition.fields) {\n      return null;\n    }\n\n    const field = this.findInASTArrayByNameValue(definition.fields, fieldName)\n\n    if (field) {\n      meta = {\n        name: field.name && field.name.value || null,\n        type: field.type && field.type.kind === 'NonNullType'\n          ? field.type.type.name.value\n          : field.type && field.type.name && field.type.name.value || null,\n        nullable: !!(field.type && field.type.kind !== 'NonNullType')\n      }\n    }\n\n    return { field, meta };\n  }\n\n  /**\n   * Enum AST definitions operate differently than object type definitions\n   * do. Namely, they do not have a `fields` array but instead have a `values`\n   * array. This wrapper method, first finds the enum definition in the ast\n   * and then searches the values for the named node desired and returns that\n   * or null, if one could not be found.\n   *\n   * @method SyntaxTree#⌾⠀findEnumDefinition\n   * @since 2.7.0\n   *\n   * @param {DocumentNode} ast the abstract syntax tree parsed by graphql\n   * @param {string|RegExp} enumDefinitionName a string or regular expression\n   * used to locate the enum definition in the AST.\n   * @param {string|RegExp} enumValueName a string or regular expression used\n   * to locate the value by name in the values of the enum definition.\n   * @return {Object|null} the desired AST node or null if one does not exist\n   */\n  static findEnumDefinition(\n    ast: DocumentNode,\n    enumDefinitionName: string | RegExp,\n    enumValueName: string | RegExp\n  ): ?Object {\n    // Fetch the enum definition\n    const definition = this.findDefinition(ast, enumDefinitionName);\n\n    // Ensure we have one or that it has a values array\n    if (!definition || !definition.values) {\n      return null;\n    }\n\n    // Return the results of an `findInASTArrayByNameValue()` search of the\n    // aforementioned 'values' array.\n    return this.findInASTArrayByNameValue(\n      definition.values,\n      enumValueName\n    )\n  }\n\n  /**\n   * A lot of searching in ASTs is filtering through arrays and matching on\n   * subobject properties on each iteration. A common theme is find something\n   * by its `.name.value`. This method simplifies that by taking an array of\n   * AST nodes and searching them for a `.name.value` property that exists\n   * within.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findInASTArrayByNameValue\n   * @since 2.7.0\n   *\n   * @param {Array} array of mixed AST object nodes containing `name.value`s\n   * @param {string|RegExp} name a string or regular expression used\n   * to match against the node name value\n   * @return {Object|null} the AST leaf if one matches or null otherwise.\n   */\n  static findInASTArrayByNameValue(\n    array: Array<DocumentNode>,\n    name: string | RegExp\n  ): ?DocumentNode {\n    const isRegExp: boolean = /RegExp/.test(typeOf(name));\n    const regex = !isRegExp\n      // $FlowFixMe\n      ? new RegExp(RegExp.escape(name.toString()))\n      // $FlowFixMe\n      : (name: RegExp);\n    const flags = regex.flags\n    const source = regex.source\n    const reducer = (last,cur,i) => {\n      if (last !== -1) return last;\n      if (!cur || !cur.name || !cur.name.value) return -1;\n      return new RegExp(source, flags).test(cur.name.value) ? i : -1\n    }\n    const index = array.reduce(reducer, -1);\n\n    return (~index) ? array[index] : null;\n  }\n\n  /**\n   * Query types in GraphQL are an ObjectTypeDefinition of importance for\n   * placement on the root object. There is utility in creating an empty\n   * one that can be injected with the fields of other GraphQL object query\n   * entries.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyQuery\n   *\n   * @return {SyntaxTree} an instance of SyntaxTree with a base AST generated\n   * by parsing the graph query, \"type Query {}\"\n   */\n  static EmptyQuery(): ?SyntaxTree {\n    return SyntaxTree.from(`type ${this.QUERY} {}`);\n  }\n\n  /**\n   * Mutation types in GraphQL are an ObjectTypeDefinition of importance for\n   * placement on the root object. There is utility in creating an empty\n   * one that can be injected with the fields of other GraphQL object mutation\n   * entries.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyMutation\n   *\n   * @return {SyntaxTree} an instance of SyntaxTree with a base AST generated\n   * by parsing the graph query, \"type Mutation {}\"\n   */\n  static EmptyMutation(): ?SyntaxTree {\n    return SyntaxTree.from(`type ${this.MUTATION} {}`);\n  }\n\n  /**\n   * The starting point for a SyntaxTree that will be built up programmatically.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyDocument\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST any valid type taken by\n   * SyntaxTree.from() used to further populate the new empty document\n   * @return {SyntaxTree} an instance of SyntaxTree with no definitions and a\n   * kind set to 'Document'\n   */\n  static EmptyDocument(\n    schemaOrASTOrST?: string | Object | SyntaxTree\n  ): SyntaxTree {\n    let tree = new SyntaxTree();\n\n    // Due to normal validation methods with ASTs (i.e. converting to string\n    // and then back to an AST object), doing this with an empty document\n    // fails. Therefore, we manually set the document contents here. This allows\n    // toString(), consumeDefinition() and similar methods to still work.\n    tree.ast = {\n      kind: 'Document',\n      definitions: [],\n      loc: {start: 0, end: 0}\n    };\n\n    if (schemaOrASTOrST) {\n      tree.appendDefinitions(schemaOrASTOrST);\n    }\n\n    return tree;\n  }\n}\n\nexport default SyntaxTree;\n"]}