{"version":3,"sources":["../es6/GQLScalar.js"],"names":["GQLScalar","GQL_TYPE","serialize","value","parseValue","parseLiteral","ast"],"mappings":";;;;;;;AAEA;;AACA;;AAEA;;;;;;;;;;;IAWaA,S,WAAAA,S,GAAN,MAAMA,SAAN,0BAAgC;AACrC;;;;;;;;;;;;AAYA,aAAWC,QAAX,GAAgC;AAC9B;AACD;;AAED;;;;;;;;;;;;;;AAcA,SAAOC,SAAP,CAAiBC,KAAjB,EAAsC;AACpC,WAAOA,KAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,SAAOC,UAAP,CAAkBD,KAAlB,EAAyC;AACvC,WAAOA,KAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,SAAOE,YAAP,CAAoBC,GAApB,EAAyC,CACxC;AA1GoC,C;kBA6GxBN,S","file":"GQLScalar.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nimport { GraphQLScalarType } from 'graphql'\nimport { GQLBase } from './GQLBase'\n\n/**\n * GQLScalars are how one might construct their own types for use within \n * GraphQL with Lattice. The descriptions below should be sufficient to get \n * you started with your own types. The SDL for a Scalar looks like this:\n *\n * ```\n * scalar MyType\n * ```\n *\n * @class GQLScalar\n */\nexport class GQLScalar extends GQLBase {\n  /**\n   * Determines the default type targeted by this GQLBase class. Any\n   * type will technically be valid but only will trigger special behavior\n   *\n   * @memberof GQLScalar\n   * @method ⬇︎⠀GQL_TYPE\n   * @static\n   * @const\n   *\n   * @return {Function} a type, such as `GraphQLObjectType` or\n   * `GraphQLInterfaceType`\n   */\n  static get GQL_TYPE(): Function {\n    return GraphQLScalarType;\n  }\n\n  /**\n   * The `serialize` method is called by GraphQL when the type is going to \n   * be sent to the client. Since values on the client are in the form of \n   * JSON, the return value of `serialize` can be any valid JSON value;\n   * String, Number, Array, Object, etc...\n   *\n   * @memberof GQLScalar\n   * @method serialize\n   * @static \n   *\n   * @param {mixed} value the value that needs to be converted for the \n   * downstream JSON client side result.\n   * @return {mixed} any valid JSON value\n   */\n  static serialize(value: mixed): mixed {\n    return value;\n  }\n\n  /**\n   * Parse value handles input from the client. In this form, the value is \n   * taken directly from the sent query. The type of the value can be nearly \n   * anything, but the `parseValue` function's job is to interpret the \n   * input and return the understood value.\n   *\n   * You could have a ColorBlind scalar type that took in a hexadecimal \n   * color string and converted it to a color scheme as seen by those with \n   * some form of color blindness. The value supplied to `parseValue` would \n   * be the input color. The modified color would be the output value.\n   *\n   * ```\n   * query {\n   *   showMe(colorBlind: '#ff0000') {\n   *     color \n   *   }\n   * }\n   *\n   * // this might convert to #c65100\n   * ```\n   *\n   * This can also cover input sent in the form of variables. The variable \n   * can be of any valid JSON type. \n   *\n   * @memberof GQLScalar\n   * @method parseValue\n   * @static \n   *\n   * @param {mixed} value the input sent from a query that needs to be \n   * converted to an internal value for GraphQL to proceed\n   * @return {mixed} the converted output given the input; this will be purely \n   * how you want your scalars to function.\n   */\n  static parseValue(value: ?mixed): ?mixed {\n    return value;\n  }\n\n  /**\n   * Similar to `parseValue`, but rather than receiving the input values from \n   * a query or from a query variable, the data comes in the form of a parsed \n   * abstract syntax/source tree (AST). It is the job of `parseLiteral` to\n   * convert from an AST type to the desired output value. \n   *\n   * An example that converts all Strings to Numbers and vice versa\n   *\n   * ```javascript\n   * static parseLiteral(ast) {\n   *   const { Kind } = require('graphql/language')\n   *\n   *   switch (ast.kind) {\n   *     case Kind.INT:\n   *     case Kind.FLOAT:\n   *       return String(ast.value)\n   *     case Kind.STRING:\n   *       return parseFloat(ast.value)\n   *     default:\n   *       return null;\n   *   }\n   * }\n   * ```\n   *\n   * @memberof GQLScalar\n   * @method parseLiteral\n   * @static \n   *\n   * @param {Object} ast the parse value of the type given some literal SDL \n   * syntax. Presumably this is where you can choose to take a String, for\n   * example, and convert it to an integer when Kind.STRING is supplied. \n   * @return {mixed} the value of the conversion, given input.\n   */\n  static parseLiteral(ast: Object): ?mixed {\n  }\n}\n\nexport default GQLScalar"]}