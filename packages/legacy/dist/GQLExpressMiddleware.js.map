{"version":3,"sources":["../es6/GQLExpressMiddleware.js"],"names":["GQLExpressMiddleware","handlers","ast","cache","clear","requestData","separateByType","createMergedRoot","root","options","graphiql","patchFn","optsFn","req","res","gql","schema","rootValue","message","error","locations","stack","path","opts","formatError","bind","debug","resolvers","typeDefs","injectAll","apolloFn","apolloOpts","generateApolloOptions","json","text","type","next","is","body","query","graphqlHttpOptions","generateOptions","cached","get","set","generateSchemaSDL","customMiddleware","status","send"],"mappings":"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AAO,UAACG,GAAD,EAAcC,GAAd,EAA2BsB,IAA3B,EAA+C;AACpDtB,YAAIiC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,OAAKhC,MAA1B;AACD,OAFD;AAGD;;AAED;;;;;;;;;;;;;;wBAW8B;AAC5B,aAAO,UAACH,GAAD,EAAcC,GAAd,EAA2BsB,IAA3B,EAA+C;AACpDtB,YAAIiC,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,sCAArB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACD,OAhGD;AAiGD;;;;AA9cH;;kBAidehD,oB","file":"GQLExpressMiddleware.js","sourceRoot":"es6","sourcesContent":["// @flow\n// @module GQLExpressMiddleware\n\nimport { SyntaxTree } from './SyntaxTree'\nimport { GQLBase } from './GQLBase'\nimport { GQLInterface } from './GQLInterface'\nimport { GQLScalar } from './GQLScalar'\nimport { typeOf } from './types'\nimport { SchemaUtils } from './SchemaUtils'\nimport _, { merge } from 'lodash'\nimport { makeExecutableSchema } from 'graphql-tools'\n\nimport {\n  parse,\n  print,\n  buildSchema,\n  GraphQLSchema,\n  GraphQLInterfaceType,\n  GraphQLEnumType,\n  GraphQLScalarType\n} from 'graphql'\n\nimport bodyParser from 'body-parser'\nimport graphqlHTTP from 'express-graphql'\nimport EventEmitter from 'events'\nimport path from 'path'\n\n/**\n * A handler that exposes an express middleware function that mounts a\n * GraphQL I/O endpoint. Typical usage follows:\n *\n * ```js\n * const app = express();\n * app.use(/.../, new GQLExpressMiddleware([...classes]).middleware);\n * ```\n *\n * @class GQLExpressMiddleware\n */\nexport class GQLExpressMiddleware extends EventEmitter\n{\n  handlers: Array<GQLBase>;\n\n  schema: string;\n\n  cache: Map<any, any> = new Map()\n\n  /**\n   * For now, takes an Array of classes extending from GQLBase. These are\n   * parsed and a combined schema of all their individual schemas is generated\n   * via the use of ASTs. This is passed off to express-graphql.\n   *\n   * @memberof GQLExpressMiddleware\n   * @method ⎆⠀constructor\n   * @constructor\n   *\n   * @param {Array<GQLBase>} handlers an array of GQLBase extended classes\n   */\n  constructor(handlers: Array<GQLBase>) {\n    super()\n\n    this.handlers = handlers\n\n    // Generate and cache the schema SDL/IDL string and ast obj (GraphQLSchema)\n    this.ast\n  }\n\n  /**\n   * The Schema String and Schema AST/GraphQLSchema JavaScript objects are\n   * cached after being processed once. If there is a runtime need to rebuild\n   * these objects, calling `clearCache()` will allow their next usage to\n   * rebuild them dynamically.\n   *\n   * @method clearCache\n   * @memberof GQLExpressMiddleware\n   *\n   * @return {GQLExpressMiddleware} returns this so that it can be inlined; ala\n   * `gqlExpressMiddleware.clearCache().ast`, for example\n   */\n  clearCache(): GQLExpressMiddleware {\n    this.cache.clear()\n    return this\n  }\n\n  /**\n   * The schema property returns the textual Schema as it is generated based\n   * on the various Lattice types, interfaces and enums defined in your\n   * project. The ast property returns the JavaScript AST represenatation of\n   * that schema with all injected modificiations detailed in your classes.\n   */\n  get ast(): GraphQLSchema {\n    let cached: ?GraphQLSchema = this.cache.get('ast')\n\n    if (cached) {\n      return cached\n    }\n\n    let ast: GraphQLSchema = buildSchema(this.schema)\n\n    SchemaUtils.injectAll(ast, this.handlers);\n\n    this.cache.set('ast', ast)\n\n    return ast;\n  }\n\n  /**\n   * Generates the textual schema based on the registered `GQLBase` handlers\n   * this instance represents.\n   *\n   * @method GQLExpressMiddleware#⬇︎⠀schema\n   * @since 2.7.0\n   *\n   * @return {string} a generated schema string based on the handlers that\n   * are registered with this `GQLExpressMiddleware` instance.\n   */\n  get schema(): string {\n    let cached = this.cache.get('schema')\n    let schema\n\n    if (cached) return cached\n\n    schema = SchemaUtils.generateSchemaSDL(this.handlers);\n    this.cache.set('schema', schema)\n\n    return schema\n  }\n\n  async rootValue(\n    requestData: Object,\n    separateByType: boolean = false\n  ): Object {\n    let root = await SchemaUtils.createMergedRoot(\n      this.handlers, requestData, separateByType\n    )\n\n    return root;\n  }\n\n  /**\n   * Using the express-graphql module, it returns an Express 4.x middleware\n   * function.\n   *\n   * @instance\n   * @memberof GQLExpressMiddleware\n   * @method ⬇︎⠀middleware\n   *\n   * @return {Function} a function that expects request, response and next\n   * parameters as all Express middleware functions.\n   */\n  get middleware(): Function {\n    return this.customMiddleware();\n  }\n\n  /**\n   * Using the express-graphql module, it returns an Express 4.x middleware\n   * function. This version however, has graphiql disabled. Otherwise it is\n   * identical to the `middleware` property\n   *\n   * @instance\n   * @memberof GQLExpressMiddleware\n   * @method ⬇︎⠀middlewareWithoutGraphiQL\n   *\n   * @return {Function} a function that expects request, response and next\n   * parameters as all Express middleware functions.\n   */\n  get middlewareWithoutGraphiQL(): Function {\n    return this.customMiddleware({graphiql: false});\n  }\n\n  /**\n   * In order to ensure that Lattice functions receive the request data,\n   * it is important to use the options function feature of both\n   * `express-graphql` and `apollo-server-express`. This function will create\n   * an options function that reflects that schema and Lattice types defined\n   * in your project.\n   *\n   * Should you need to tailor the response before it is sent out, you may\n   * supply a function as a second parameter that takes two parameters and\n   * returns an options object. The patchFn callback signature looks like this\n   *\n   * ```patchFn(options, {req, res, next|gql})```\n   *\n   * When using the reference implementation, additional graphql request info\n   * can be obtained in lieu of the `next()` function so typically found in\n   * Express middleware. Apollo Server simply provides the next function in\n   * this location.\n   *\n   * @param {Object} options any options, to either engine, that make the most\n   * sense\n   * @param {Function} patchFn see above\n   */\n  generateOptions(\n    options: Object = { graphiql: true },\n    patchFn: ?Function = null\n  ): Function {\n    const optsFn = async (req: mixed, res: mixed, gql: mixed) => {\n      let schema = this.ast;\n      let opts = {\n        schema,\n        rootValue: await this.rootValue({req, res, gql}),\n        formatError: error => ({\n          message: error.message,\n          locations: error.locations,\n          stack: error.stack,\n          path: error.path\n        })\n      }\n\n      merge(opts, options);\n      if (patchFn && typeof patchFn === 'function') {\n        merge(\n          opts,\n          (patchFn.bind(this)(opts, {req, res, gql})) || opts\n        );\n      }\n\n      return opts;\n    }\n\n    return optsFn\n  }\n\n    /**\n   * In order to ensure that Lattice functions receive the request data,\n   * it is important to use the options function feature of both\n   * `express-graphql` and `apollo-server-express`. This function will create\n   * an options function that reflects that schema and Lattice types defined\n   * in your project.\n   *\n   * Should you need to tailor the response before it is sent out, you may\n   * supply a function as a second parameter that takes two parameters and\n   * returns an options object. The patchFn callback signature looks like this\n   *\n   * ```patchFn(options, {req, res, next|gql})```\n   *\n   * When using the reference implementation, additional graphql request info\n   * can be obtained in lieu of the `next()` function so typically found in\n   * Express middleware. Apollo Server simply provides the next function in\n   * this location.\n   *\n   * @param {Object} options any options, to either engine, that make the most\n   * sense\n   * @param {Function} patchFn see above\n   */\n  generateApolloOptions(\n    options: Object = {\n      formatError: error => ({\n        message: error.message,\n        locations: error.locations,\n        stack: error.stack,\n        path: error.path\n      }),\n      debug: true\n    },\n    patchFn: ?Function = null\n  ): Function {\n    const optsFn = async (req: mixed) => {\n      let opts = {\n        schema: this.ast,\n        resolvers: await this.rootValue({req}, true)\n      }\n\n      opts.schema = makeExecutableSchema({\n        typeDefs: [this.schema],\n        resolvers: opts.resolvers\n      })\n\n      SchemaUtils.injectAll(opts.schema, this.handlers);\n\n      merge(opts, options);\n      if (patchFn && typeof patchFn === 'function') {\n        merge(\n          opts,\n          (patchFn.bind(this)(opts, {req})) || opts\n        );\n      }\n\n      return opts;\n    }\n\n    return optsFn\n  }\n\n  apolloMiddleware(\n    apolloFn: Function,\n    apolloOpts: Object = {},\n    patchFn: ?Function = null\n  ): Array<Function> {\n    let opts = this.generateApolloOptions(apolloOpts, patchFn)\n\n    return [\n      bodyParser.json(),\n      bodyParser.text({ type: 'application/graphql' }),\n      (req, res, next) => {\n          if (req.is('application/graphql')) {\n              req.body = { query: req.body };\n          }\n          next();\n      },\n      apolloFn(opts)\n    ]\n  }\n\n  /**\n   * If your needs require you to specify different values to `graphqlHTTP`,\n   * part of the `express-graphql` package, you can use the `customMiddleware`\n   * function to do so.\n   *\n   * The first parameter is an object that should contain valid `graphqlHTTP`\n   * options. See https://github.com/graphql/express-graphql#options for more\n   * details. Validation is NOT performed.\n   *\n   * The second parameter is a function that will be called after any options\n   * have been applied from the first parameter and the rest of the middleware\n   * has been performed. This, if not modified, will be the final options\n   * passed into `graphqlHTTP`. In your callback, it is expected that the\n   * supplied object is to be modified and THEN RETURNED. Whatever is returned\n   * will be used or passed on. If nothing is returned, the options supplied\n   * to the function will be used instead.\n   *\n   * @method ⌾⠀customMiddleware\n   * @memberof GQLExpressMiddleware\n   * @instance\n   *\n   * @param {Object} [graphqlHttpOptions={graphiql: true}] standard set of\n   * `express-graphql` options. See above.\n   * @param {Function} patchFn see above\n\n   * @return {Function} a middleware function compatible with Express\n   */\n  customMiddleware(\n    graphqlHttpOptions: Object = {graphiql: true},\n    patchFn?: Function\n  ): Function {\n    const optsFn = this.generateOptions(graphqlHttpOptions, patchFn)\n    return graphqlHTTP(optsFn)\n  }\n\n  /**\n   * An optional express middleware function that can be mounted to return\n   * a copy of the generated schema string being used by GQLExpressMiddleware.\n   *\n   * @memberof GQLExpressMiddleware\n   * @method schemaMiddleware\n   * @instance\n   *\n   * @type {Function}\n   */\n  get schemaMiddleware(): Function {\n    return (req: Object, res: Object, next: ?Function) => {\n      res.status(200).send(this.schema);\n    }\n  }\n\n  /**\n   * An optional express middleware function that can be mounted to return\n   * the JSON AST representation of the schema string being used by\n   * GQLExpressMiddleware.\n   *\n   * @memberof GQLExpressMiddleware\n   * @method astMiddleware\n   * @instance\n   *\n   * @type {Function}\n   */\n  get astMiddleware(): Function {\n    return (req: Object, res: Object, next: ?Function) => {\n      res.status(200).send('Temporarily disabled in this version')\n\n      // let cachedOutput = this.cache.get('astMiddlewareOutput')\n      // if (cachedOutput) {\n      //   res\n      //     .status(302)\n      //     .set('Content-Type', 'application/json')\n      //     .send(cachedOutput)\n      // }\n      // else {\n      //   this.rootValue({req, res, next}, true)\n      //     .then(resolvers => {\n      //       let schema: GraphQLSchema = buildSchema(this.schema)\n\n      //       SchemaUtils.injectInterfaceResolvers(schema, this.handlers);\n      //       SchemaUtils.injectEnums(schema, this.handlers);\n      //       SchemaUtils.injectScalars(schema, this.handlers);\n      //       SchemaUtils.injectComments(schema, this.handlers);\n\n      //       function killToJSON(obj: any, path = 'obj.') {\n      //         for (let key in obj) {\n      //           try {\n      //             if (key == 'prev' || key == 'next' || key == 'ofType') continue;\n\n      //             if (key == 'toJSON') {\n      //               let success = delete obj.toJSON\n      //               //console.log(`Killing ${path}toJSON...${success ? 'success' : 'failure'}`)\n      //               continue\n      //             }\n\n      //             if (key == 'inspect') {\n      //               let success = delete obj.inspect\n      //               //console.log(`Killing ${path}inspect...${success ? 'success' : 'failure'}`)\n      //               continue\n      //             }\n\n      //             if (key == 'toString') {\n      //               obj.toString = Object.prototype.toString\n      //               //console.log(`Replacing ${path}toString with default`)\n      //               continue\n      //             }\n\n      //             if (typeof obj[key] == 'function') {\n      //               obj[key] = `[Function ${obj[key].name}]`\n      //               continue\n      //             }\n\n      //             if (typeof obj[key] == 'object') {\n      //               obj[key] = killToJSON(obj[key], `${path}${key}.`)\n      //               continue\n      //             }\n      //           }\n      //           catch (error) {\n      //             continue\n      //           }\n      //         }\n\n      //         return obj\n      //       }\n\n      //       // $FlowFixMe\n      //       schema = killToJSON(schema)\n\n      //       // Still do not know why/how they are preventing JSONifying the\n      //       // _typeMap keys. So aggravting\n      //       for (let typeKey of Object.keys(schema._typeMap)) {\n      //         let object = {}\n\n      //         // $FlowFixMe\n      //         for (let valKey of Object.keys(schema._typeMap[typeKey])) {\n      //           // $FlowFixMe\n      //           object[valKey] = schema._typeMap[typeKey][valKey]\n      //         }\n\n      //         // $FlowFixMe\n      //         schema._typeMap[typeKey] = object\n      //       }\n\n      //       let output = JSON.stringify(schema)\n      //       this.cache.delete('ast')\n      //       this.cache.set('astMiddlewareOutput', output)\n\n      //       res\n      //         .status(200)\n      //         .set('Content-Type', 'application/json')\n      //         .send(output)\n      //     })\n      //     .catch(error => {\n      //       console.error(error)\n\n      //       res\n      //         .status(500)\n      //         .json(error)\n      //     })\n      // }\n    }\n  }\n}\n\nexport default GQLExpressMiddleware;\n"]}