{"version":3,"sources":["../es6/IDLFileHandler.js"],"names":["IDLFileHandler","constructor","Class","symbol","SCHEMA","pattern","symbolString","toString","ADJACENT_FILE","module","Error","name","filename","extension","Path","extname","dir","dirname","filefixed","basename","build","resolve","join","path","test","parsed","exec","file","getFile","fs","readFileSync","String","getSchema","tree","getSyntaxTree","buffer","SyntaxTree"],"mappings":";;;;;;;;;;;;;AAAA;;;;;;;IAOaA,c,WAAAA,c,GAAN,MAAMA,cAAN,CAAqB;;AAK1B;;;;;;;;;;;;;;AAcAC,cAAYC,KAAZ,EAA6B;AAC3B;AACA,UAAMC,SAAS,OAAOD,MAAME,MAAb,KAAwB,QAAxB,IAAoCF,MAAME,MAA1C,IAAoD,IAAnE;AACA,UAAMC,UAAU,sCAAhB;;AAEA,QAAIF,MAAJ,EAAY;AACV,UAAIG,eAAeH,OAAOI,QAAP,EAAnB;;AAEA,UAAIJ,WAAWD,MAAMM,aAArB,EAAoC;AAClC,YAAIN,MAAMO,MAAN,KAAiBA,MAArB,EAA6B;AAC3B,gBAAM,IAAIC,KAAJ,CAAW;kDACuBR,MAAMS,IAAK;;;;sBAIvCT,MAAMS,IAAK;;;oBAGbT,MAAMS,IAAK;;oBAEXT,MAAMS,IAAK;;;;yBAINT,MAAMS,IAAK;;;;WAdpB,CAAN;AAmBD;;AAED,cAAMC,WAAWV,MAAMO,MAAN,CAAaG,QAA9B;AACA,cAAMC,YAAYC,KAAKC,OAAL,CAAaH,QAAb,CAAlB;AACA,cAAMI,MAAMF,KAAKG,OAAL,CAAaL,QAAb,CAAZ;AACA,cAAMM,YAAYJ,KAAKK,QAAL,CAAcP,QAAd,EAAwBC,SAAxB,CAAlB;AACA,cAAMO,QAAQN,KAAKO,OAAL,CAAaP,KAAKQ,IAAL,CAAUN,GAAV,EAAgB,GAAEE,SAAU,UAA5B,CAAb,CAAd;;AAEA,aAAKK,IAAL,GAAYH,KAAZ;AACA,aAAKP,SAAL,GAAiB,UAAjB;AACD,OA/BD,MAgCK,IAAIR,QAAQmB,IAAR,CAAalB,YAAb,CAAJ,EAAgC;AACnC,cAAMmB,SAASpB,QAAQqB,IAAR,CAAapB,YAAb,CAAf;AACA,cAAMO,YAAYY,OAAO,CAAP,KAAa,UAA/B;AACA,cAAMT,MAAMF,KAAKG,OAAL,CAAaQ,OAAO,CAAP,CAAb,CAAZ;AACA,cAAME,OAAOb,KAAKK,QAAL,CAAcM,OAAO,CAAP,CAAd,EAAyBZ,SAAzB,CAAb;AACA,cAAMO,QAAQN,KAAKO,OAAL,CAAaP,KAAKQ,IAAL,CAAUN,GAAV,EAAgB,GAAEW,IAAK,GAAEd,SAAU,EAAnC,CAAb,CAAd;;AAEA,aAAKU,IAAL,GAAYH,KAAZ;AACA,aAAKP,SAAL,GAAiBA,SAAjB;AACD;AACF,KA7CD,MA8CK;AACH,WAAKU,IAAL,GAAY,KAAKV,SAAL,GAAiB,IAA7B;AACD;AACF;;AAED;;;;;;;;;;;;;AAaAe,YAAkB;AAChB,WAAOC,GAAGC,YAAH,CAAgBC,OAAO,KAAKR,IAAZ,CAAhB,CAAP;AACD;;AAED;;;;;;;;;;;;AAYAS,cAAqB;AACnB,QAAI,CAAC,KAAKT,IAAV,EAAgB;AAAE,aAAO,IAAP;AAAc;;AAEhC,UAAMU,OAAO,KAAKC,aAAL,EAAb;;AAEA,WAAOD,KAAK1B,QAAL,EAAP;AACD;;AAED;;;;;;;;;;;;AAYA2B,kBAA4B;AAC1B,UAAMC,SAAS,KAAKP,OAAL,EAAf;AACA,UAAMK,OAAO,IAAIG,UAAJ,CAAeD,OAAO5B,QAAP,EAAf,CAAb;;AAEA,WAAO0B,IAAP;AACD;;AAED;;;;;;;;;;;AAWA,gCAA2B;AAAE,WAAO,KAAKhC,WAAL,CAAiBU,IAAxB;AAA8B;;AAE3D;;;;;;;;;;;;AAYA,uCAAkC;AAAE,WAAO,KAAKA,IAAZ;AAAkB;AA5J5B,C;kBA+JbX,c","file":"IDLFileHandler.js","sourceRoot":"es6","sourcesContent":["/**\n * The handler, an instance of which is created for every instance of GQLBase.\n * The handler manages the fetching and decoding of files bearing the IDL\n * schema associated with the class represented by this instance of GQLBase.\n *\n * @class IDLFileHandler\n */\nexport class IDLFileHandler {\n  path: ?string;\n\n  extension: ?string;\n\n  /**\n   * The IDLFileHandler checks the SCHEMA value returned by the class type\n   * of the supplied instance. If the resulting value is a Symbol, then the\n   * handler's responsibility is to find the file, load it from disk and\n   * provide various means of using its contents; i.e. as a Buffer, a String\n   * or wrapped in a SyntaxTree instance.\n   *\n   * @memberof IDLFileHandler\n   * @method ⎆⠀constructor\n   * @constructor\n   *\n   * @param {Function} Class a function or class definition that presumably\n   * extends from GQLBase were it an instance.\n   */\n  constructor(Class: Function) {\n    // $FlowFixMe\n    const symbol = typeof Class.SCHEMA === 'symbol' && Class.SCHEMA || null;\n    const pattern = /Symbol\\(Path (.*?) Extension (.*?)\\)/;\n\n    if (symbol) {\n      let symbolString = symbol.toString();\n\n      if (symbol === Class.ADJACENT_FILE) {\n        if (Class.module === module) {\n          throw new Error(`\n            The a static getter for 'module' on ${Class.name} must be present\n            that returns the module object where the Class is defined. Try the\n            following:\n\n            // your ${Class.name}.js file\n            import { GQLBase } from 'graphql-lattice'\n\n            const ${Class.name}Module = module;\n\n            class ${Class.name} extends GQLBase {\n              ...\n\n              static get module() {\n                return ${Class.name}Module;\n              }\n            }\n\n          `);\n        }\n\n        const filename = Class.module.filename;\n        const extension = Path.extname(filename)\n        const dir = Path.dirname(filename)\n        const filefixed = Path.basename(filename, extension)\n        const build = Path.resolve(Path.join(dir, `${filefixed}.graphql`))\n\n        this.path = build;\n        this.extension = '.graphql';\n      }\n      else if (pattern.test(symbolString)) {\n        const parsed = pattern.exec(symbolString);\n        const extension = parsed[2] || '.graphql'\n        const dir = Path.dirname(parsed[1])\n        const file = Path.basename(parsed[1], extension)\n        const build = Path.resolve(Path.join(dir, `${file}${extension}`))\n\n        this.path = build;\n        this.extension = extension;\n      }\n    }\n    else {\n      this.path = this.extension = null;\n    }\n  }\n\n  /**\n   * Loads the calculated file determined by the decoding of the meaning of\n   * the Symbol returned by the SCHEMA property of the instance supplied to\n   * the IDLFileHandler upon creation.\n   *\n   * @instance\n   * @memberof IDLFileHandler\n   * @method ⌾⠀getFile\n   *\n   * @return {Buffer|null} returns the Buffer containing the file base IDL\n   * schema or null if none was found or a direct string schema is returned\n   * by the SCHEMA property\n   */\n  getFile(): Buffer {\n    return fs.readFileSync(String(this.path));\n  }\n\n  /**\n   * If getFile() returns a Buffer, this is the string representation of the\n   * underlying file contents. As a means of validating the contents of the\n   * file, the string contents are parsed into an AST and back to a string.\n   *\n   * @instance\n   * @memberof IDLFileHandler\n   * @method ⌾⠀getSchema\n   *\n   * @return {string|null} the string contents of the Buffer containing the\n   * file based IDL schema.\n   */\n  getSchema(): ?string {\n    if (!this.path) { return null; }\n\n    const tree = this.getSyntaxTree();\n\n    return tree.toString();\n  }\n\n  /**\n   * If getFile() returns a Buffer, the string contents are passed to a new\n   * instance of SyntaxTree which parses this into an AST for manipulation.\n   *\n   * @instance\n   * @memberof IDLFileHandler\n   * @method ⌾⠀getSyntaxTree\n   *\n   * @return {SyntaxTree|null} a SyntaxTree instance constructed from the IDL\n   * schema contents loaded from disk. Null is returned if a calculated path\n   * cannot be found; always occurs when SCHEMA returns a string.\n   */\n  getSyntaxTree(): SyntaxTree {\n    const buffer = this.getFile();\n    const tree = new SyntaxTree(buffer.toString());\n\n    return tree;\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof IDLFileHandler\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof IDLFileHandler\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n}\n\nexport default IDLFileHandler"]}