{"version":3,"sources":["../es6/IDLFileHandler.js"],"names":["IDLFileHandler","Class","symbol","SCHEMA","pattern","symbolString","toString","ADJACENT_FILE","module","Error","name","filename","extension","Path","extname","dir","dirname","filefixed","basename","build","resolve","join","path","test","parsed","exec","file","fs","readFileSync","String","tree","getSyntaxTree","buffer","getFile","SyntaxTree","constructor"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;IAOaA,c,WAAAA,c;;AAKX;;;;;;;;;;;;;;AAcA,0BAAYC,KAAZ,EAA6B;AAAA;;AAC3B;AACA,QAAMC,SAAS,OAAOD,MAAME,MAAb,KAAwB,QAAxB,IAAoCF,MAAME,MAA1C,IAAoD,IAAnE;AACA,QAAMC,UAAU,sCAAhB;;AAEA,QAAIF,MAAJ,EAAY;AACV,UAAIG,eAAeH,OAAOI,QAAP,EAAnB;;AAEA,UAAIJ,WAAWD,MAAMM,aAArB,EAAoC;AAClC,YAAIN,MAAMO,MAAN,KAAiBA,MAArB,EAA6B;AAC3B,gBAAM,IAAIC,KAAJ,CAAW;kDACuBR,MAAMS,IAAK;;;;sBAIvCT,MAAMS,IAAK;;;oBAGbT,MAAMS,IAAK;;oBAEXT,MAAMS,IAAK;;;;yBAINT,MAAMS,IAAK;;;;WAdpB,CAAN;AAmBD;;AAED,YAAMC,WAAWV,MAAMO,MAAN,CAAaG,QAA9B;AACA,YAAMC,YAAYC,KAAKC,OAAL,CAAaH,QAAb,CAAlB;AACA,YAAMI,MAAMF,KAAKG,OAAL,CAAaL,QAAb,CAAZ;AACA,YAAMM,YAAYJ,KAAKK,QAAL,CAAcP,QAAd,EAAwBC,SAAxB,CAAlB;AACA,YAAMO,QAAQN,KAAKO,OAAL,CAAaP,KAAKQ,IAAL,CAAUN,GAAV,EAAgB,GAAEE,SAAU,UAA5B,CAAb,CAAd;;AAEA,aAAKK,IAAL,GAAYH,KAAZ;AACA,aAAKP,SAAL,GAAiB,UAAjB;AACD,OA/BD,MAgCK,IAAIR,QAAQmB,IAAR,CAAalB,YAAb,CAAJ,EAAgC;AACnC,YAAMmB,SAASpB,QAAQqB,IAAR,CAAapB,YAAb,CAAf;AACA,YAAMO,aAAYY,OAAO,CAAP,KAAa,UAA/B;AACA,YAAMT,OAAMF,KAAKG,OAAL,CAAaQ,OAAO,CAAP,CAAb,CAAZ;AACA,YAAME,OAAOb,KAAKK,QAAL,CAAcM,OAAO,CAAP,CAAd,EAAyBZ,UAAzB,CAAb;AACA,YAAMO,SAAQN,KAAKO,OAAL,CAAaP,KAAKQ,IAAL,CAAUN,IAAV,EAAgB,GAAEW,IAAK,GAAEd,UAAU,EAAnC,CAAb,CAAd;;AAEA,aAAKU,IAAL,GAAYH,MAAZ;AACA,aAAKP,SAAL,GAAiBA,UAAjB;AACD;AACF,KA7CD,MA8CK;AACH,WAAKU,IAAL,GAAY,KAAKV,SAAL,GAAiB,IAA7B;AACD;AACF;;AAED;;;;;;;;;;;;;;;;;8BAakB;AAChB,aAAOe,GAAGC,YAAH,CAAgBC,OAAO,KAAKP,IAAZ,CAAhB,CAAP;AACD;;AAED;;;;;;;;;;;;;;;gCAYqB;AACnB,UAAI,CAAC,KAAKA,IAAV,EAAgB;AAAE,eAAO,IAAP;AAAc;;AAEhC,UAAMQ,OAAO,KAAKC,aAAL,EAAb;;AAEA,aAAOD,KAAKxB,QAAL,EAAP;AACD;;AAED;;;;;;;;;;;;;;;oCAY4B;AAC1B,UAAM0B,SAAS,KAAKC,OAAL,EAAf;AACA,UAAMH,OAAO,IAAII,UAAJ,CAAeF,OAAO1B,QAAP,EAAf,CAAb;;AAEA,aAAOwB,IAAP;AACD;;AAED;;;;;;;;;;;;;;wBAW2B;AAAE,aAAO,KAAKK,WAAL,CAAiBzB,IAAxB;AAA8B;;AAE3D;;;;;;;;;;;;;;;wBAYkC;AAAE,aAAO,KAAKA,IAAZ;AAAkB;;;;;kBAGzCV,c","file":"IDLFileHandler.js","sourceRoot":"es6","sourcesContent":["/**\n * The handler, an instance of which is created for every instance of GQLBase.\n * The handler manages the fetching and decoding of files bearing the IDL\n * schema associated with the class represented by this instance of GQLBase.\n *\n * @class IDLFileHandler\n */\nexport class IDLFileHandler {\n  path: ?string;\n\n  extension: ?string;\n\n  /**\n   * The IDLFileHandler checks the SCHEMA value returned by the class type\n   * of the supplied instance. If the resulting value is a Symbol, then the\n   * handler's responsibility is to find the file, load it from disk and\n   * provide various means of using its contents; i.e. as a Buffer, a String\n   * or wrapped in a SyntaxTree instance.\n   *\n   * @memberof IDLFileHandler\n   * @method ⎆⠀constructor\n   * @constructor\n   *\n   * @param {Function} Class a function or class definition that presumably\n   * extends from GQLBase were it an instance.\n   */\n  constructor(Class: Function) {\n    // $FlowFixMe\n    const symbol = typeof Class.SCHEMA === 'symbol' && Class.SCHEMA || null;\n    const pattern = /Symbol\\(Path (.*?) Extension (.*?)\\)/;\n\n    if (symbol) {\n      let symbolString = symbol.toString();\n\n      if (symbol === Class.ADJACENT_FILE) {\n        if (Class.module === module) {\n          throw new Error(`\n            The a static getter for 'module' on ${Class.name} must be present\n            that returns the module object where the Class is defined. Try the\n            following:\n\n            // your ${Class.name}.js file\n            import { GQLBase } from 'graphql-lattice'\n\n            const ${Class.name}Module = module;\n\n            class ${Class.name} extends GQLBase {\n              ...\n\n              static get module() {\n                return ${Class.name}Module;\n              }\n            }\n\n          `);\n        }\n\n        const filename = Class.module.filename;\n        const extension = Path.extname(filename)\n        const dir = Path.dirname(filename)\n        const filefixed = Path.basename(filename, extension)\n        const build = Path.resolve(Path.join(dir, `${filefixed}.graphql`))\n\n        this.path = build;\n        this.extension = '.graphql';\n      }\n      else if (pattern.test(symbolString)) {\n        const parsed = pattern.exec(symbolString);\n        const extension = parsed[2] || '.graphql'\n        const dir = Path.dirname(parsed[1])\n        const file = Path.basename(parsed[1], extension)\n        const build = Path.resolve(Path.join(dir, `${file}${extension}`))\n\n        this.path = build;\n        this.extension = extension;\n      }\n    }\n    else {\n      this.path = this.extension = null;\n    }\n  }\n\n  /**\n   * Loads the calculated file determined by the decoding of the meaning of\n   * the Symbol returned by the SCHEMA property of the instance supplied to\n   * the IDLFileHandler upon creation.\n   *\n   * @instance\n   * @memberof IDLFileHandler\n   * @method ⌾⠀getFile\n   *\n   * @return {Buffer|null} returns the Buffer containing the file base IDL\n   * schema or null if none was found or a direct string schema is returned\n   * by the SCHEMA property\n   */\n  getFile(): Buffer {\n    return fs.readFileSync(String(this.path));\n  }\n\n  /**\n   * If getFile() returns a Buffer, this is the string representation of the\n   * underlying file contents. As a means of validating the contents of the\n   * file, the string contents are parsed into an AST and back to a string.\n   *\n   * @instance\n   * @memberof IDLFileHandler\n   * @method ⌾⠀getSchema\n   *\n   * @return {string|null} the string contents of the Buffer containing the\n   * file based IDL schema.\n   */\n  getSchema(): ?string {\n    if (!this.path) { return null; }\n\n    const tree = this.getSyntaxTree();\n\n    return tree.toString();\n  }\n\n  /**\n   * If getFile() returns a Buffer, the string contents are passed to a new\n   * instance of SyntaxTree which parses this into an AST for manipulation.\n   *\n   * @instance\n   * @memberof IDLFileHandler\n   * @method ⌾⠀getSyntaxTree\n   *\n   * @return {SyntaxTree|null} a SyntaxTree instance constructed from the IDL\n   * schema contents loaded from disk. Null is returned if a calculated path\n   * cannot be found; always occurs when SCHEMA returns a string.\n   */\n  getSyntaxTree(): SyntaxTree {\n    const buffer = this.getFile();\n    const tree = new SyntaxTree(buffer.toString());\n\n    return tree;\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof IDLFileHandler\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof IDLFileHandler\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n}\n\nexport default IDLFileHandler"]}