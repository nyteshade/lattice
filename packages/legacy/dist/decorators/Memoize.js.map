{"version":3,"sources":["../../es6/decorators/Memoize.js"],"names":["Memoize","cache","isValidKey","target","prop","descriptor","initializer","set","get","value","key","func","args","validate","wrapper","results","apply","error"],"mappings":";;;;;;;;;;QAQgBA,O,GAAAA,O;;;;AANhB,MAAMC,QAAQ,mBAAd;;AAEA,SAASC,UAAT,GAA+B;AAC7B,SAAO,KAAP;AACD;;AAEM,SAASF,OAAT,CACLG,MADK,EAELC,IAFK,EAGLC,UAHK,EAII;AACT;AACA,MAAI,OAAOA,WAAWC,WAAtB,EAAmC,OAAOD,UAAP;;AAEnC;AACA,MAAIA,WAAWE,GAAX,IAAkB,CAACF,WAAWG,GAA9B,IAAqC,CAACH,WAAWI,KAArD,EAA4D,OAAOJ,UAAP;;AAE5D;AACA,MACE,OAAOA,WAAWI,KAAlB,KAA4B,UAA5B,IACG,CAACJ,WAAWG,GAFjB,EAGE;AACA,WAAOH,UAAP;AACD;;AAED;AACA,QAAMK,MAAM;AACVP,UADU;AAEVC,QAFU;AAGVC,cAHU;;AAKVM,UAAMN,WAAWG,GAAX,IAAkBH,WAAWI,KALzB;AAMVG,UAAM,EANI;AAOVC,cAAUX;;AAGZ;AACA;AAXY,GAAZ,CAYA,MAAMY,UAAU,CAAC,GAAGF,IAAJ,KAAa;AAC3BF,QAAIE,IAAJ,GAAWA,IAAX;;AAEA;AACA;AACA,QAAIF,IAAIG,QAAJ,EAAJ,EAAoB;AAClB,aAAOZ,MAAMO,GAAN,CAAUE,GAAV,CAAP;AACD,KAFD,MAGK;AACH,UAAIK,OAAJ;;AAEA,UAAI;AACF,YAAIA,UAAUL,IAAIC,IAAJ,CAASK,KAAT,CAAeb,MAAf,EAAuBO,IAAIE,IAA3B,CAAd;AACAX,cAAMM,GAAN,CAAUG,GAAV,EAAeK,OAAf;AACD,OAHD,CAIA,OAAOE,KAAP,EAAc;AACZF,kBAAUE,KAAV;AACD;AACF;AACF,GAnBD;;AAqBA,MAAIZ,WAAWG,GAAf,EAAoB;AAClBH,eAAWG,GAAX,GAAiBM,OAAjB;AACD,GAFD,MAGK;AACHT,eAAWI,KAAX,GAAmBK,OAAnB;AACD;;AAED,SAAOT,UAAP;AACD","file":"Memoize.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nconst cache = new Map()\n\nfunction isValidKey(): boolean {\n  return false\n}\n\nexport function Memoize(\n  target: mixed,\n  prop: string,\n  descriptor: Object\n): ?Object {\n  // This won't make sense if we are a class prop; if so, bug out\n  if (typeof descriptor.initializer) return descriptor\n\n  // If we have only a setter, we can skip out\n  if (descriptor.set && !descriptor.get && !descriptor.value) return descriptor\n\n  // If we do not have a get function and value is not a function, jet\n  if (\n    typeof descriptor.value !== 'function'\n    && !descriptor.get\n  ) {\n    return descriptor\n  }\n\n  // Our passed arguments and function make our key\n  const key = {\n    target,\n    prop,\n    descriptor,\n\n    func: descriptor.get || descriptor.value,\n    args: [],\n    validate: isValidKey\n  }\n\n  // In order to determine if we have a match on key we must allow execution\n  // of a wrapper function that does so\n  const wrapper = (...args) => {\n    key.args = args;\n\n    // TODO check for cache hit by comparing objects\n    // return the cache if a hit or run the function and store otherwise\n    if (key.validate()) {\n      return cache.get(key)\n    }\n    else {\n      let results\n\n      try {\n        let results = key.func.apply(target, key.args)\n        cache.set(key, results)\n      }\n      catch (error) {\n        results = error;\n      }\n    }\n  }\n\n  if (descriptor.get) {\n    descriptor.get = wrapper\n  }\n  else {\n    descriptor.value = wrapper\n  }\n\n  return descriptor\n}\n"]}