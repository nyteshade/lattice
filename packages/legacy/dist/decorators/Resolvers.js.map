{"version":3,"sources":["../../es6/decorators/Resolvers.js"],"names":["resolver","mutator","subscriptor","decorate","metaProperty","target","key","descriptor","Class","constructor","proto","prototype","isClass","fn","value","console","warn","name","get","set","initializer","s","global","eval","push"],"mappings":";;;;;;;;;;;;;;QAyGgBA,Q,GAAAA,Q;QAuBAC,O,GAAAA,O;QAuBAC,W,GAAAA,W;;AApJhB;;AACA;;;;AAEA;;;;;;;;;;;;;;;AANA;AAqBA,SAASC,QAAT,CACEC,YADF,EAEEC,MAFF,EAGEC,GAHF,EAIEC,UAJF,EAKU;AACR,QAAMC,QAAQ,OAAOH,MAAP,KAAkB,UAAlB,GAA+BA,MAA/B,GAAwCA,OAAOI,WAA7D;AACA,QAAMC,QAAQ,OAAOL,MAAP,KAAkB,UAAlB,GAA+BA,OAAOM,SAAtC,GAAkDN,MAAhE;AACA,QAAMO,UAAUJ,UAAUH,MAA1B;AACA,MAAIQ,KAAeN,WAAWO,KAA9B;;AAEA,MAAI,CAACN,KAAD,4BAAJ,EAA+B;AAC7BO,YAAQC,IAAR,CAAa,gBAAO;qDAC6BH,MAAMA,GAAGI,IAAT,IAAiBX,GAAI;oCACtCE,MAAMS,IAAK;KAF3C;;AAKA,WAAOV,UAAP;AACD;;AAED,MACE,CAACA,WAAWO,KAAZ,IACIP,WAAWW,GAAX,IAAkBX,WAAWY,GAA7B,IAAoCZ,WAAWa,WAFrD,EAGE;AACAL,YAAQC,IAAR,CAAa,gBAAO;qDAC6BH,MAAMA,GAAGI,IAAT,IAAiBX,GAAI;;;;KADtE;;AAOA,WAAOC,UAAP;AACD;;AAED;AACA,SAAOF,OAAOC,GAAP,CAAP;AACA,SAAOC,WAAWO,KAAlB;;AAEA,MAAIF,OAAJ,EAAa;AACX,WAAOF,MAAMJ,GAAN,CAAP;AACD,GAFD,MAGK;AACH,WAAOE,MAAMF,GAAN,CAAP;AACD;;AAED;AACA;AACAE,2BAAgBJ,YAAhB,IAAgCI,yBAAgBJ,YAAhB,KAAiC,EAAjE;;AAEA;AACA;AACA;AACA,MAAIS,GAAGI,IAAH,KAAYX,GAAhB,EAAqB;AACnB,QAAIe,IAAI,uBAAR;;AAEAC,WAAOD,CAAP,IAAYR,EAAZ;AACAA,SAAKU,KAAM,aAAYjB,GAAI,0CAAtB,CAAL;AACD;;AAED;AACAE,2BAAgBJ,YAAhB,EAA8BoB,IAA9B,CAAmCX,EAAnC;;AAEA;AACAN,aAAW,mBAAWH,YAAX,CAAX,IAAuCS,EAAvC;;AAEA;AACA,SAAON,UAAP;AACD;;AAED;;;;;;;;;;;;;;;AAeO,SAASP,QAAT,CACLK,MADK,EAELC,GAFK,EAGLC,UAHK,EAIG;AACR,SAAOJ,SAAS,WAAT,EAAsBE,MAAtB,EAA8BC,GAA9B,EAAmCC,UAAnC,CAAP;AACD;;AAED;;;;;;;;;;;;;;;AAeO,SAASN,OAAT,CACLI,MADK,EAELC,GAFK,EAGLC,UAHK,EAIG;AACR,SAAOJ,SAAS,UAAT,EAAqBE,MAArB,EAA6BC,GAA7B,EAAkCC,UAAlC,CAAP;AACD;;AAED;;;;;;;;;;;;;;;AAeO,SAASL,WAAT,CACLG,MADK,EAELC,GAFK,EAGLC,UAHK,EAIG;AACR,SAAOJ,SAAS,cAAT,EAAyBE,MAAzB,EAAiCC,GAAjC,EAAsCC,UAAtC,CAAP;AACD","file":"Resolvers.js","sourceRoot":"es6","sourcesContent":["/** @namespace decorators */\n/** @flow */\n\nimport { GQLBase, META_KEY } from '../GQLBase'\nimport { dedent } from 'ne-tag-fns'\n\n/**\n * Since the bulk functionality of @subscriptor, @mutator and\n * @resolver are almost identical, a single function can serve\n * the bulk of the functionality needed since they are so similar\n * in nature.\n *\n * @method decorators~decorate\n * @param {string} metaProperty the name of the meta sub key under which to\n * store the modified decorated function.\n * @param {Object|Function} target either the Class itself, if defined\n * on a static method, or the prototype if defined on an instance method\n * @param {string} key the property name of the function being decorated\n * @param {Object} descriptor a decorator descriptor; see\n * `Object.defineProperty` for more information on descriptors\n */\nfunction decorate(\n  metaProperty: string,\n  target: Object | Function,\n  key: string,\n  descriptor: Object\n): Object {\n  const Class = typeof target === 'function' ? target : target.constructor;\n  const proto = typeof target === 'function' ? target.prototype : target;\n  const isClass = Class === target;\n  let fn: Function = descriptor.value;\n\n  if (!Class instanceof GQLBase) {\n    console.warn(dedent`\n      Ignoring the transformation of @resolver for ${fn && fn.name || key}.\n      The reason for this is that ${Class.name} is not an instance of GQLBase.\n    `)\n\n    return descriptor\n  }\n\n  if (\n    !descriptor.value\n    || (descriptor.get || descriptor.set || descriptor.initializer)\n  ) {\n    console.warn(dedent`\n      Ignoring the transformation of @resolver for ${fn && fn.name || key}. The\n      reason for this is that it should only be applied to a static or instance\n      method of a class. It is not valid to apply this to a getter, setter,\n      or property.\n    `)\n\n    return descriptor\n  }\n\n  // Remove the function from wherever it happens to be defined.\n  delete target[key];\n  delete descriptor.value;\n\n  if (isClass) {\n    delete proto[key]\n  }\n  else {\n    delete Class[key]\n  }\n\n  // Obtain a reference to the metadata storage area and create the resolver\n  // portion if it does not yet exist.\n  Class[META_KEY][metaProperty] = Class[META_KEY][metaProperty] || []\n\n  // Ensure that the function name matches the key, if not, wrap it\n  // such that future uses of the .name property match the key of the\n  // decorated function\n  if (fn.name !== key) {\n    let s = Symbol();\n\n    global[s] = fn;\n    fn = eval(`(function ${key}(...args) { return global[s](...args) })`)\n  }\n\n  // Store the key by name, overwritting if necessary, and assign the function\n  Class[META_KEY][metaProperty].push(fn)\n\n  // Pass the decorated function along for others to consume\n  descriptor[Symbol.for(metaProperty)] = fn\n\n  // Return a new decorator descriptor without the value function\n  return descriptor;\n}\n\n/**\n * The resolver function should perform the necessary insertion to place\n * the decorated function in question into a place that it can be merged\n * with the final list of query resolvers. Typically a resolver function,\n * as defined in `RESOLVERS()` receives a `requestData` object. Functions\n * decorated with `@resolver` receive this as their first parameter. Code\n * accordingly.\n *\n * @method üè∑‚†Ädecorators~resolver\n * @param {Object|Function} target either the Class itself, if defined\n * on a static method, or the prototype if defined on an instance method\n * @param {string} key the property name of the function being decorated\n * @param {Object} descriptor a decorator descriptor; see\n * `Object.defineProperty` for more information on descriptors\n */\nexport function resolver(\n  target: Object | Function,\n  key: string,\n  descriptor: Object\n): Object {\n  return decorate('resolvers', target, key, descriptor)\n}\n\n/**\n * The mutator function should perform the necessary insertion to place\n * the decorated function in question into a place that it can be merged\n * with the final list of query resolvers. Typically a mutator function,\n * as defined in `RESOLVERS()` receives a `requestData` object. Functions\n * decorated with `@mutator` receive this as their first parameter. Code\n * accordingly.\n *\n * @method üè∑‚†Ädecorators~mutator\n * @param {Object|Function} target either the Class itself, if defined\n * on a static method, or the prototype if defined on an instance method\n * @param {string} key the property name of the function being decorated\n * @param {Object} descriptor a decorator descriptor; see\n * `Object.defineProperty` for more information on descriptors\n */\nexport function mutator(\n  target: Object | Function,\n  key: string,\n  descriptor: Object\n): Object {\n  return decorate('mutators', target, key, descriptor)\n}\n\n/**\n * The subscriptor function should perform the necessary insertion to place\n * the decorated function in question into a place that it can be merged\n * with the final list of query resolvers. Typically a subscriptor function,\n * as defined in `RESOLVERS()` receives a `requestData` object. Functions\n * decorated with `@subscriptor` receive this as their first parameter.\n * Code accordingly.\n *\n * @method üè∑‚†Ädecorators~subscriptor\n * @param {Object|Function} target either the Class itself, if defined\n * on a static method, or the prototype if defined on an instance method\n * @param {string} key the property name of the function being decorated\n * @param {Object} descriptor a decorator descriptor; see\n * `Object.defineProperty` for more information on descriptors\n */\nexport function subscriptor(\n  target: Object | Function,\n  key: string,\n  descriptor: Object\n): Object {\n  return decorate('subscriptors', target, key, descriptor)\n}\n"]}