{"version":3,"sources":["../es6/GQLEnum.js"],"names":["_MODEL_KEY","_PROXY_HANDLER","ENUMS","GQLEnum","enumValueOrKey","requestData","Class","constructor","enums","symbol","enumVK","value","getModel","name","undefined","NaN","deprecationReason","description","result","map","get","obj","key","has","set","isFinite","length","DOC_CLASS","DOC_FIELDS","joinLines","ast","SCHEMA","array","Proxy","GenerateEnumsProxyHandler","values","astValues","definitions","error","enumDef","defKey","symObj","Object","sym","valueOf","push"],"mappings":"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","file":"GQLEnum.js","sourceRoot":"es6","sourcesContent":["/**\n @namespace GQLInterface\n @flow\n */\n\nimport { GQLBase } from './GQLBase'\nimport { GraphQLEnumType, parse } from 'graphql'\nimport { Getters } from './decorators/ModelProperties'\nimport { LatticeLogs as ll } from './utils'\n\n/* Internal Symbol referring to real accessor to GQLBase model object */\nconst _MODEL_KEY = Symbol.for('data-model-contents-value');\n\n/* Internal Symbol referring to the static object containing a proxy handler */\nconst _PROXY_HANDLER = Symbol.for('internal-base-proxy-handler')\n\n/* Internal Symbol property referring to the mapping of values on the GQLEnum */\nconst ENUMS = Symbol();\n\n/**\n * GraphQL Enum types can be a bit picky when it comes to how scalar types\n * equate to enum values. Lattice makes this easier by allowing you to specify\n * a value or the key when your enum has a value other than the key; GraphQL\n * does not allow this by default.\n *\n * Further more, when instantiating a GQLEnum type, you can pass a string or\n * value matching the enum key or value or you can pass an object with key of\n * value and the value being either the enum key or value. If any of those\n * things match, then your `instance.value` will equate to the enum's key. If,\n * on the other hand, your supplied values do not match then `instance.value`\n * will be `null`.\n *\n * @class GQLEnum\n */\n@Getters('symbol')\nexport class GQLEnum extends GQLBase {\n  constructor(enumValueOrKey: ?Object, requestData: ?Object) {\n    super({}, requestData)\n\n    const Class = this.constructor\n    const enums = Class.enums;\n    let symbol;\n    let enumVK: (Object | string | null) = enumValueOrKey || null\n\n    // @ComputedType\n    symbol = enums[enumVK] || enumVK && enums[enumVK.value] || null\n\n    Object.assign(this.getModel(), {\n      name: symbol ? symbol.name : null,\n      value: symbol ? symbol.value : null,\n      symbol: symbol ? symbol : null\n    })\n  }\n\n  /**\n   * Retrieves the actual symbol stored name property from the internal\n   * model object for this enum instance. That is a mouthfull, but it\n   * basically means that if your enum is something like:\n   *\n   * ```\n   * enum Person { TALL, SHORT }\n   * ```\n   *\n   * and you create an instance using any of the following\n   *\n   * ```\n   * p = new Person('TALL')\n   * p = new Person(valueFor('TALL'))\n   * p = new Person({value: 'TALL'})\n   * ```\n   *\n   * that your response to `p.name` will equate to `TALL`.\n   *\n   * @method ⬇︎⠀name\n   * @memberof GQLEnum\n   * @return {mixed} typically a String but any valid type supplied\n   */\n  get name(): mixed {\n    const name = this.getModel().name\n\n    return (\n      name !== undefined &&\n      name !== null &&\n      name !== NaN\n    ) ? name : null;\n  }\n\n  /**\n   * Much like the `.name` getter, the `.value` getter will typically\n   * retreive the name of the enum key you are requesting. In rare cases\n   * where you have defined values that differ from the name, the `.value`\n   * getter will retrieve that custom value from the `.value` property on\n   * the symbol in question.\n   *\n   * This should do the right thing even if you instantiated the instance\n   * using the name.\n   *\n   * @memberof GQLEnum\n   * @method ⬇︎⠀value\n   * @return {mixed} the value of the enum type; this in all likihood should\n   * be a String or potentially an object\n   */\n  get value(): mixed {\n    const value = this.getModel().value\n\n    return (\n      value !== undefined &&\n      value !== null &&\n      value !== NaN\n    ) ? value : null;\n  }\n\n  /**\n   * Determines the default type targeted by this GQLBase class. Any\n   * type will technically be valid but only will trigger special behavior\n   *\n   * @memberof GQLEnum\n   * @method ⬇︎⠀GQL_TYPE\n   * @static\n   * @const\n   *\n   * @return {Function} a type, such as `GraphQLObjectType` or\n   * `GraphQLInterfaceType`\n   */\n  static get GQL_TYPE(): Function {\n    return GraphQLEnumType;\n  }\n\n  /**\n   * Each instance of GQLEnum must specify a map of keys and values. If this\n   * method returns null or is not defined, the value of the enum will match\n   * the name of the enum as per the reference implementation.\n   *\n   * Example:\n   * ```\n   *   static get values(): ?Object {\n   *     const { valueOf } = this;\n   *\n   *     return {\n   *       NAME: valueOf(value)\n   *     }\n   *   }\n   * ```\n   *\n   * @method ⬇︎⠀values\n   * @memberof GQLEnum\n   * @static\n   *\n   * @return {Object|Null} an object mapping with each key mapping to an object\n   * possessing at least a value field, which in turn maps to the desired value\n   */\n  static get values(): Object {\n    return {};\n  }\n\n  /**\n   * Shorthand method to generate a GraphQLEnumValueDefinition implementation\n   * object. Use this for building and customizing your `values` key/value\n   * object in your child classes.\n   *\n   * @memberof GQLEnum\n   * @method valueFor\n   * @static\n   *\n   * @param {mixed} value any nonstandard value you wish your enum to have\n   * @param {String} deprecationReason an optional reason to deprecate an enum\n   * @param {String} description a non Lattice standard way to write a comment\n   * @return {Object} an object that conforms to the GraphQLEnumValueDefinition\n   * defined here http://graphql.org/graphql-js/type/#graphqlenumtype\n   */\n  static valueFor(\n    value: mixed,\n    deprecationReason: ?string,\n    description: ?string\n  ): Object {\n    const result: Object = { value }\n\n    if (deprecationReason) { result.deprecationReason = deprecationReason }\n    if (description) { result.description = description }\n\n    return result;\n  }\n\n  /**\n   * For easier use within JavaScript, the static enums method provides a\n   * Symbol backed solution for each of the enums defined. Each `Symbol`\n   * instance is wrapped in Object so as to allow some additional properties\n   * to be written to it.\n   *\n   * @memberof GQLEnum\n   * @method ⬇︎⠀enums\n   * @static\n   *\n   * @return {Array<Symbol>} an array of modified Symbols for each enum\n   * variation defined.\n   */\n  static get enums(): Array<Symbol> {\n    // @ComputedType\n    if (!this[ENUMS]) {\n      const map: Map<*,*> = new Map();\n      const ast = parse((this.SCHEMA: any));\n      const array = new Proxy([], GQLEnum.GenerateEnumsProxyHandler(map));\n      const values = this.values || {};\n      let astValues: Array<any>;\n\n      try {\n        // TODO: $FlowFixMe\n        astValues = ast.definitions[0].values;\n      }\n      catch (error) {\n        ll.error('Unable to discern the values from your enums SCHEMA')\n        ll.error(error)\n        throw error;\n      }\n\n      // Walk the AST for the class' schema and extract the names (same as\n      // values when specified in GraphQL SDL) and build an object the has\n      // the actual defined value and the AST generated name/value.\n      for (let enumDef of astValues) {\n        let defKey = enumDef.name.value;\n        let symObj: Object = Object(Symbol.for(defKey));\n\n        symObj.value = (values[defKey] && values[defKey].value) || defKey;\n        symObj.name = defKey\n        symObj.sym = symObj.valueOf()\n\n        map.set(symObj.name, symObj)\n        map.set(symObj.value, symObj)\n\n        // This bit of logic allows us to look into the \"enums\" property and\n        // get the generated Object wrapped Symbol with keys and values by\n        // supplying either a key or value.\n        array.push(symObj)\n      }\n\n      // @ComputedType\n      this[ENUMS] = array;\n    }\n\n    // @ComputedType\n    return this[ENUMS];\n  }\n\n  /**\n   * Due to the complexity of being able to access both the keys and values\n   * properly for an enum type, a Map is used as the backing store. The handler\n   * returned by this method is to be passed to a Proxy.\n   *\n   * @method GQLEnum#GenerateEnumsProxyHandler\n   * @static\n   *\n   * @param {Map} map the map containing the key<->value and\n   * value<->key mappings; the true storage backing the array in question.\n   * @return {Object}\n   */\n  static GenerateEnumsProxyHandler(map: Map<*, *>) {\n    return {\n      /**\n       * Get handler for the Map backed Array Proxy\n       *\n       * @memberof! GQLEnum\n       * @method get\n       *\n       * @param {mixed} obj the object targeted by the Proxy\n       * @param {string} key `key` of the value being requested\n       * @return {mixed} the `value` being requested\n       */\n      get(obj, key) {\n        if (map.has(key)) {\n          return map.get(key)\n        }\n\n        return obj[key]\n      },\n\n      /**\n       * Set handler for the Map backed Array Proxy.\n       *\n       * @memberof! GQLEnum\n       * @method set\n       *\n       * @param {mixed} obj the object the Proxy is targeting\n       * @param {string} key a string `key` being set\n       * @param {mixed} value the `value` being assigned to `key`\n       */\n      set(obj, key, value) {\n        if (isFinite(key) && value instanceof Symbol) {\n          map.set(value.name, value)\n          map.set(value.value, value)\n        }\n\n        // Some accessor on the receiving array\n        obj[key] = value;\n\n        // Arrays return length when pushing. Assume value as return\n        // otherwise. ¯\\_(ツ)_/¯\n        return isFinite(key) ? obj.length : obj[key];\n      }\n    }\n  }\n\n  /** @inheritdoc */\n  static apiDocs(): Object {\n    const { DOC_CLASS, DOC_FIELDS, joinLines } = this;\n\n    return {\n      [DOC_CLASS]: joinLines`\n        GQLEnums allow the definition of enum types with description fields\n        and values other than a 1:1 mapping of their types and their type\n        names. If you are reading this, the implementor likely did not\n        contribute comments for their type.\n      `\n    }\n  }\n}\n"]}