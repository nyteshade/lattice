{"version":3,"sources":["../es6/utils.js"],"names":["dedent","promisify","getLatticePrefs","Stats","Deferred","resolveWith","rejectWith","promise","resolve","reject","complete","timeOut","proxyPromise","deferred","name","then","catch","reason","setTimeout","Error","method","context","args","push","error","callbackArgs","apply","readPkgUpOpts","pkg","options","ModuleParser","extensions","failOnError","lattice","LatticeLogs","LOG","WARN","ERROR","INFO","TRACE","LEVELS","ll","equalOrBelow","testedLevel","lessThan","indexOf","atLeast","atLeastLevel","argMapper","arg","index","array","isError","showStack","test","process","env","LATTICE_ERRORS","message","failFast","logLevel","compareTo","LATTICE_LOGLEVEL","log","map","warn","info","trace","outWrite","chunk","encoding","callback","stdout","write","errWrite","stderr"],"mappings":"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","file":"utils.js","sourceRoot":"es6","sourcesContent":["/** @namespace utils */\n// @flow\n\nimport fs from 'fs'\nimport util from 'util'\nimport { typeOf } from './types'\nimport { sync as readPkg } from 'read-pkg-up'\nimport { merge } from 'lodash'\n\nexport { dedent as joinLines } from 'ne-tag-fns'\n\nconst { Stats } = fs;\n\n/**\n * Deferred is modeled after jQuery's deferred object. It inverts a promise\n * such that its resolve and reject methods can be invoked without wrapping\n * all of the related code within a Promise's function.\n *\n * @memberof utils\n * @class Deferred\n */\nexport class Deferred {\n  /**\n   * This property holds a `resolve` function from within the promise this\n   * deferred inverts.\n   *\n   * @type {Function}\n   * @memberof Deferred\n   * @instance\n   */\n  resolve: Function;\n\n  /**\n   * This property holds a `reject` function from within the promise this\n   * deferred inverts\n   *\n   * @type {Function}\n   * @memberof Deferred\n   * @instance\n   */\n  reject: Function;\n\n  /**\n   * This is the promise wrapped by and inverted in this deferred instance\n   *\n   * @type {Promise}\n   * @memberof Deferred\n   * @instance\n   */\n  promise: any;\n\n  /**\n   * An at a glance boolean property that denotes whether or not this\n   * deferred has been resolved or rejected yet.\n   *\n   * @type {boolean}\n   * @memberof Deferred\n   * @instance\n   */\n  complete: boolean;\n\n  /**\n   * Creates an object with four properties of note; promise, resolve, reject\n   * and a flag complete that will be set once either resolve or reject have\n   * been called. A Deferred is considered to be pending while complete is set\n   * to false.\n   *\n   * Once constructed, resolve and reject can be called later, at which point,\n   * the promise is completed. The promise property is the promise resolved\n   * or rejected by the associated properties and can be used with other\n   * async/await or Promise based code.\n   *\n   * @instance\n   * @memberof Deferred\n   * @method ⎆⠀constructor\n   *\n   * @param {any} resolveWith a deferred resolved as Promise.resolve() might do\n   * @param {any} rejectWith a deferred rejected as Promise.reject() might do\n   */\n  constructor(resolveWith: any, rejectWith: any) {\n    this.promise = new Promise((resolve, reject) => {\n      this.complete = false;\n\n      this.resolve = (...args) => {\n        this.complete = true;\n        return resolve(...args);\n      };\n\n      this.reject = (...args) => {\n        this.complete = true;\n        return reject(...args);\n      };\n\n      if (resolveWith && !rejectWith) { this.resolve(resolveWith) }\n      if (rejectWith && !resolveWith) { this.reject(rejectWith) }\n    });\n  }\n\n  /**\n   * Shorthand getter that denotes true if the deferred is not yet complete.\n   *\n   * @instance\n   * @memberof Deferred\n   * @method ⬇︎⠀pending\n   *\n   * @return {boolean} true if the promise is not yet complete; false otherwise\n   */\n  get pending(): boolean { return !this.complete }\n\n  /**\n   * Promises are great but if the code never resolves or rejects a deferred,\n   * then things will become eternal; in a bad way. This makes that less likely\n   * of an event.\n   *\n   * If the number of milliseconds elapses before a resolve or reject occur,\n   * then the deferred is rejected.\n   *\n   * @static\n   * @memberof Deferred\n   * @method ⌾⠀TimedDeferred\n   *\n   * @param {Number} timeOut a number of milliseconds to wait before rejecting\n   * the deferred.\n   * @param {Promise} proxyPromise a promise to proxy then/catch through to the\n   * deferreds resolve/reject.\n   * @return {Deferred} an instance of deferred that will timeout after\n   * `timeOut` milliseconds have elapsed. If `proxyPromise` is a `Promise`\n   * then the deferred's reject and resolve will be tied to the Promise's\n   * catch() and then() methods, respectively.\n   */\n  static TimedDeferred(timeOut: Number, proxyPromise: ?any): Deferred {\n    const deferred = new Deferred();\n\n    if (proxyPromise && typeOf(proxyPromise) === Promise.name) {\n      proxyPromise.then((...args) => deferred.resolve(...args))\n      proxyPromise.catch(reason => deferred.reject(reason))\n    }\n\n    setTimeout(() => deferred.reject(new Error('Deferred timed out'), timeOut))\n\n    return deferred;\n  }\n}\n\n/**\n * A simply promisify style function that returns an async function wrapped\n * around a supplied function designed for the standard callback methodology.\n * If the callback is the last parameter, and that callback is in the form of\n * (error, ...results) then this wrapper will do the trick for you.\n *\n * @method utils~⌾⠀promisify\n * @since 2.7.0\n *\n * @param {Function} method a function to wrap in an asynchronous function\n * @param {mixed} context an optional `this` object for use with the supplied\n * function.\n * @return {Function} an asynchronous function, i.e. one that returns a promise\n * containing the contents the callback results, that wraps the supplied\n * function.\n */\nexport function promisify(method: Function, context?: mixed): Function {\n  return async function(...args) {\n    return new Promise((resolve, reject) => {\n      args.push(function(error, ...callbackArgs) {\n        if (error) {\n          reject(error);\n        }\n        else {\n          resolve(...callbackArgs);\n        }\n      });\n\n      method.apply(context, args);\n    })\n  }\n}\n\n/**\n * It may be necessary to read GraphQL Lattice preferences from the nearest\n * `package.json` object to the excuting code. `getLatticePrefs()` does this\n * and merges any subsequently found options in said file on top of the\n * default values specified here in this file.\n *\n * @method utils~⌾⠀getLatticePrefs\n * @since 2.13.0\n *\n * @return {Object} an object containing at least the defaults plus any other\n * values specified in `package.json`\n */\nexport function getLatticePrefs(readPkgUpOpts: ?Object): Object {\n  let { pkg } = readPkg(readPkgUpOpts)\n  let options = {\n    ModuleParser: {\n      extensions: ['.js', '.jsx', '.ts', '.tsx'],\n      failOnError: false\n    }\n  }\n\n  if (pkg.lattice) {\n    merge(options, pkg.lattice || {})\n  }\n\n  return options;\n}\n\n/**\n * A small near pass-thru facility for logging within Lattice such that error\n * objects supplied get mapped to their message unless `LATTICE_ERRORS=STACK`\n * is set in `process.env`.\n *\n * Note the order of log levels for Lattice may be somewhat non-standard. Info\n * has been taken out of flow and placed above error to solve issues with jest\n * logging.\n *\n * @memberof utils\n * @type Object\n * @static\n */\nexport const LatticeLogs = {\n  get LOG(): string { return 'log' },\n\n  get WARN(): string { return 'warn' },\n\n  get ERROR(): string { return 'error' },\n\n  get INFO(): string { return 'info' },\n\n  get TRACE(): string { return 'trace' },\n\n  /**\n   * Ordering of log levels for LatticeLogs. `INFO` is a non error log level\n   * that is non-crucial and appears if LATTICE_LOGLEVEL is set to `INFO` or\n   * `TRACE`\n   */\n  get LEVELS(): Array<string> {\n    const ll = LatticeLogs\n\n    return [ll.LOG, ll.WARN, ll.ERROR, ll.INFO, ll.TRACE]\n  },\n\n  equalOrBelow(testedLevel: string, lessThan: string = 'error') {\n    const ll = LatticeLogs\n\n    return ll.LEVELS.indexOf(testedLevel) <= ll.LEVELS.indexOf(lessThan)\n  },\n\n  atLeast(testedLevel: string, atLeastLevel: string): boolean {\n    const ll = LatticeLogs\n\n    return ll.LEVELS.indexOf(testedLevel) >= ll.LEVELS.indexOf(atLeastLevel)\n  },\n\n  /**\n   * All arguments of any logging function in `LatticeLogs` get passed through\n   * this function first to modify or alter the type of value being logged.\n   *\n   * @param {mixed} arg the argument being passed to the `map()` function\n   * @param {number} index the index in the array of arguments\n   * @param {Array<mixed>} array the array containing this element\n   */\n  argMapper(arg: mixed, index: number, array: Array<mixed>): mixed {\n    let isError = typeOf(arg) === Error.name\n    let showStack = /\\bSTACK\\b/i.test(process.env.LATTICE_ERRORS || '')\n\n    // $FlowFixMe\n    return !isError ? arg : (showStack ? arg : arg.message)\n  },\n\n  /** A function that, when it returns true, will cause logging to be skipped */\n  failFast(logLevel: ?string, lessThan: ?string) {\n    const ll = LatticeLogs\n\n    if (logLevel) {\n      let compareTo = lessThan || process.env.LATTICE_LOGLEVEL || ll.ERROR\n      if (!ll.equalOrBelow(logLevel, compareTo)) return true\n    }\n\n    return /\\b(NONE|OFF|NO|0)\\b/i.test(process.env.LATTICE_ERRORS || '')\n  },\n\n  /** Pass-thru to console.log; arguments parsed via `argMapper` */\n  log(...args: Array<mixed>) {\n    if (LatticeLogs.failFast(LatticeLogs.LOG)) return;\n    console.log(...args.map(LatticeLogs.argMapper))\n  },\n\n  /** Pass-thru to console.warn; arguments parsed via `argMapper` */\n  warn(...args: Array<mixed>) {\n    if (LatticeLogs.failFast(LatticeLogs.WARN)) return;\n    console.warn(...args.map(LatticeLogs.argMapper))\n  },\n\n  /** Pass-thru to console.error; arguments parsed via `argMapper` */\n  error(...args: Array<mixed>) {\n    if (LatticeLogs.failFast(LatticeLogs.ERROR)) return;\n    console.error(...args.map(LatticeLogs.argMapper))\n  },\n\n  /** Pass-thru to console.info; arguments parsed via `argMapper` */\n  info(...args: Array<mixed>) {\n    if (LatticeLogs.failFast(LatticeLogs.INFO)) return;\n    console.info(...args.map(LatticeLogs.argMapper))\n  },\n\n  /** Pass-thru to console.trace; arguments parsed via `argMapper` */\n  trace(...args: Array<mixed>) {\n    if (LatticeLogs.failFast(LatticeLogs.TRACE)) return;\n    console.trace(...args.map(LatticeLogs.argMapper))\n  },\n\n  outWrite(\n    chunk: string|Uint8Array|Buffer,\n    encoding: ?string,\n    callback: ?Function\n  ) {\n    if (LatticeLogs.failFast(LatticeLogs.LOG)) return\n    // $FlowFixMe\n    process.stdout.write(chunk, encoding, callback)\n  },\n\n  errWrite(\n    chunk: string|Uint8Array|Buffer,\n    encoding: ?string,\n    callback: ?Function\n  ) {\n    if (LatticeLogs.failFast(LatticeLogs.ERROR)) return\n    // $FlowFixMe\n    process.stderr.write(chunk, encoding, callback)\n  }\n}\n"]}