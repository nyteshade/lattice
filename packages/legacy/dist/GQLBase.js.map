{"version":3,"sources":["../es6/GQLBase.js"],"names":["notDefined","hasProxy","global","Proxy","_MODEL_KEY","_PROXY_HANDLER","keyToTest","keySupplied","instance","RegExp","test","toString","hasOwnProperty","MODEL_KEY","REQ_DATA_KEY","META_KEY","AUTO_PROPS","GETTERS","SETTERS","PROPS","GQLBase","constructor","modelData","requestData","options","autoProps","Class","tree","from","SCHEMA","outline","Error","name","setupModel","setModel","fileHandler","applyAutoProps","length","warn","GQL_TYPE","props","propName","desc","prototype","hasCustomImpl","get","value","push","info","error","parsed","exec","message","getModel","extendModel","extensions","getProp","bindGetters","bindTo","proto","descriptor","result","initializer","what","bind","callProp","args","prop","apply","Function","setPromise","getResolver","resolverName","reqData","rootObj","getMergedRoot","apiDocs","DOC_CLASS","DOC_QUERY","DOC_MUTATION","DOC_SUBSCRIPTION","DOC_FIELDS","DOC_QUERIES","DOC_MUTATORS","DOC_SUBSCRIPTIONS","MUTATORS","RESOLVERS","ADJACENT_FILE","IDLFilePath","path","extension","handler","key","module","changeHandler","set","target","old","emit","EVENT_MODEL_PROP_CHANGE","model","deleteProperty","deleted","EVENT_MODEL_PROP_DELETE","hasListeners","listenerCount","EVENT_MODEL_WILL_BE_SET","EVENT_MODEL_HAS_BEEN_SET","lastResult","DOC_MUTATIONS","joinLines","separateByType","root","_","resolvers","mutators","subscriptors","convert","isFactoryClass","c","f","reduce","p","map","Query","Mutation","Subscription","storage"],"mappings":"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","file":"GQLBase.js","sourceRoot":"es6","sourcesContent":["/** @namespace GQLBaseEnv */\n// @flow\n\nimport Path from 'path'\nimport fs from 'fs'\n\nimport { Deferred, joinLines } from './utils'\nimport { typeOf } from './types'\nimport { SyntaxTree } from './SyntaxTree'\nimport { Properties } from './decorators/ModelProperties'\nimport { GraphQLObjectType, GraphQLEnumType } from 'graphql'\nimport { IDLFileHandler } from './IDLFileHandler'\nimport { merge } from 'lodash'\nimport { LatticeLogs as ll } from './utils'\nimport { dedent } from 'ne-tag-fns'\n\nimport AsyncFunctionExecutionError from './errors/AsyncFunctionExecutionError'\nimport FunctionExecutionError from './errors/FunctionExecutionError'\nimport AwaitingPromiseError from './errors/AwaitingPromiseError'\n\nimport EventEmitter from 'events'\n\n/* Internal implementation to detect the existence of proxies. When present\n * additional functionality is enabled. Proxies are native in Node >= 6 */\nconst hasProxy = typeof global.Proxy !== 'undefined';\n\n/* Internal Symbol referring to real accessor to GQLBase model object */\nconst _MODEL_KEY = Symbol.for('data-model-contents-value');\n\n/* Internal Symbol referring to the static object containing a proxy handler */\nconst _PROXY_HANDLER = Symbol.for('internal-base-proxy-handler')\n\n/**\n * Simple function to check if a supplied key matches a string of your\n * choosing and that string is not a defined property on the instance\n * passed to the check.\n *\n * @method GQLBaseEnv~notDefined\n * @memberof GQLBaseEnv\n * @since 2.5.0\n *\n * @param {string} keyToTest a String denoting the property you wish to test\n * @param {mixed} keySupplied a value, coerced `toString()`, to compare to\n * `keyToTest`\n * @param {mixed} instance an object instance to check `hasOwnProperty` on for\n * the `keyToTest` supplied.\n * @return {Boolean} true if the property matches the supplied key and that\n * property is not an ownedProperty of the instance supplied.\n */\nexport function notDefined(\n  keyToTest: string,\n  keySupplied: Object | string,\n  instance: Object\n) {\n  return (\n    new RegExp(\"^\" + keyToTest + \"$\").test(keySupplied.toString())\n    && !instance.hasOwnProperty(keyToTest)\n  );\n}\n\n/**\n * A `Symbol` used as a key to store the backing model data. Designed as a\n * way to separate model data and GraphQL property accessors into logical bits.\n *\n * @type {Symbol}\n * @memberof GQLBaseEnv\n * @const\n */\nexport const MODEL_KEY = Symbol.for('data-model-contents-key');\n\n/**\n * A `Symbol` used as a key to store the request data for an instance of the\n * GQLBase object in question.\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberof GQLBaseEnv\n */\nexport const REQ_DATA_KEY = Symbol.for('request-data-object-key');\n\n/**\n * A nameless Symbol for use as a key to the internal decorator storage\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberof GQLBaseEnv\n */\nexport const META_KEY = Symbol();\n\n/**\n * A Symbol used to identify calls to @Properties for properties generated\n * automatically upon instance creation.\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const AUTO_PROPS = Symbol.for('auto-props')\n\n/**\n * A Symbol used to identify calls to @Getters for properties generated\n * via decorator. These are stored in <class>[META_KEY][GETTERS]\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const GETTERS = Symbol.for('getters')\n\n/**\n * A Symbol used to identify calls to @Setters for properties generated\n * via decorator. These are stored in <class>[META_KEY][SETTERS]\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const SETTERS = Symbol.for('setters')\n\n/**\n * A Symbol used to identify calls to @Properties for properties generated\n * via decorator. These are stored in <class>[META_KEY][PROPS]\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const PROPS = Symbol.for('props')\n\n/**\n * All GraphQL Type objects used in this system are assumed to have extended\n * from this class. An instance of this class can be used to wrap an existing\n * structure if you have one.\n *\n * @class GQLBase\n */\nexport class GQLBase extends EventEmitter {\n  fileHandler: ?IDLFileHandler;\n\n  /**\n   * Request data is passed to this object when constructed. Typically these\n   * objects, and their children, are instantiated by its own static MUTATORS\n   * and RESOLVERS. They should contain request specific state if any is to\n   * be shared.\n   *\n   * These can be considered request specific controllers for the object in\n   * question. The base class takes a single object which should contain all\n   * the HTTP/S request data and the graphQLParams is provided as the object\n   * { query, variables, operationName, raw }.\n   *\n   * When used with express-graphql, the requestData object has the format\n   * { req, res, gql } where\n   *   • req is an Express 4.x request object\n   *   • res is an Express 4.x response object\n   *   • gql is the graphQLParams object in the format of\n   *     { query, variables, operationName, raw }\n   *     See https://github.com/graphql/express-graphql for more info\n   *\n   * @memberof GQLBase\n   * @method ⎆⠀constructor\n   * @constructor\n   *\n   * @param {mixed} modelData this, typically an object, although anything\n   * really is supported, represents the model data for our GraphQL object\n   * instance.\n   * @param {Object} requestData see description above\n   */\n  constructor(\n    modelData: Object = {},\n    requestData: ?Object = null,\n    options: Object = { autoProps: true }\n  ) {\n    super();\n\n    const Class = this.constructor;\n    const tree = SyntaxTree.from(Class.SCHEMA);\n    const outline = tree && tree.outline || null;\n\n    if (!outline) {\n      throw new FunctionExecutionError(\n        new Error(dedent`\n          The SDL is unparsable. Please check your SCHEMA and make sure\n          it is valid GraphQL SDL/IDL. Your SCHEMA is defined as:\n\n          ${this.SCHEMA}\n        `)\n      )\n    }\n\n    if (outline && !(Class.name in outline)) {\n      throw new FunctionExecutionError(\n        new Error(dedent`\n          The class name \"${Class.name}\" does not match any of the types,\n          enums, scalars, unions or interfaces defined in the SCHEMA for\n          this class (${Object.keys(outline)}).\n\n          \\x1b[1mIn most clases this is because your class name and SCHEMA\n          type do not match.\\x1b[0m\n        `)\n      )\n    }\n\n    GQLBase.setupModel(this);\n    this.setModel(modelData);\n    this.requestData = requestData || {};\n    this.fileHandler = new IDLFileHandler(this.constructor);\n\n    if (options && !!options.autoProps !== false) {\n      this.applyAutoProps()\n    }\n\n    // @ComputedType\n    return hasProxy ? new Proxy(this, GQLBase[_PROXY_HANDLER]) : this;\n  }\n\n  /**\n   * Since reading the Schema for a given GraphQL Lattice type or\n   * interface is simple enough, we should be able to automatically\n   * apply one to one GraphQL:Model properties.\n   *\n   * @instance\n   * @method ⌾⠀applyAutoProps\n   * @memberof GQLBase\n   */\n  applyAutoProps() {\n    if (!this.constructor.SCHEMA || !this.constructor.SCHEMA.length) {\n      ll.warn(joinLines`\n        There is no SCHEMA for ${this.constructor.name}!! This will likely\n        end in an error. Proceed with caution. Skipping \\`applyAutoProps\\`\n      `)\n      return\n    }\n\n    // Individual property getters do not need to be auto-created for enum\n    // types. Potentially do some checks for Interfaces and Unions as well\n    if (this.constructor.GQL_TYPE === GraphQLEnumType) {\n      return\n    }\n\n    let Class = this.constructor\n    let tree = SyntaxTree.from(Class.SCHEMA)\n    let outline = tree ? tree.outline : {}\n    let props = []\n\n    // $FlowFixMe\n    for (let propName of Object.keys(outline[Class.name])) {\n      // $FlowFixMe\n      let desc = Object.getOwnPropertyDescriptor(Class.prototype, propName)\n      let hasCustomImpl = !!(\n        // We have a descriptor for the property name\n        desc && (\n          // We have a getter function defined\n          typeof desc.get !== 'undefined'\n          ||\n          // ...or we have a function, async or not, defined\n          typeof desc.value === 'function'\n        )\n      )\n\n      // Only create auto-props for non custom implementations\n      if (!hasCustomImpl) {\n        props.push(propName)\n      }\n    }\n\n    if (props.length) {\n      ll.info(`Creating auto-props for [${Class.name}]: `, props)\n      try {\n        Properties(...props)(Class, [AUTO_PROPS])\n      }\n      catch(error) {\n        let parsed = /Cannot redefine property: (\\w+)/.exec(error.message)\n        if (parsed) {\n          ll.warn(`Skipping auto-prop '${Class.name}.${parsed[1]}'`)\n        }\n        else {\n          ll.error(`Failed to apply auto-properties\\nReason: `)\n          ll.error(error);\n        }\n      }\n    }\n  }\n\n  /**\n   * Getter for the internally stored model data. The contents of this\n   * object are abstracted away behind a `Symbol` key to prevent collision\n   * between the underlying model and any GraphQL Object Definition properties.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀getModel\n   * @since 2.5\n   *\n   * @param {Object} value any object you wish to use as a data store\n   */\n  getModel() {\n    // @ComputedType\n    return this[MODEL_KEY];\n  }\n\n  /**\n   * Setter for the internally stored model data. The contents of this\n   * object are abstracted away behind a `Symbol` key to prevent collision\n   * between the underlying model and any GraphQL Object Definition properties.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀setModel\n   * @since 2.5\n   *\n   * @param {Object} value any object you wish to use as a data store\n   */\n  setModel(value: Object): GQLBase {\n    // @ComputedType\n    this[MODEL_KEY] = value;\n    return this;\n  }\n\n  /**\n   * Uses `_.merge()` to modify the internal backing data store for the\n   * object instance. This is a shortcut for\n   * `_.merge()(instance[MODEL_KEY], ...extensions)`\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀extendModel\n   * @since 2.5\n   *\n   * @param {mixed} extensions n-number of valid `_.merge()` parameters\n   * @return {GQLBase} this is returned\n   */\n  extendModel(...extensions: Array<mixed>): GQLBase {\n    // $FlowFixMe\n    merge(this[MODEL_KEY], ...extensions);\n    return this;\n  }\n\n  /**\n   * A getter that retrieves the inner request data object. When used with\n   * GQLExpressMiddleware, this is an object matching {req, res, gql}.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⬇︎⠀requestData\n   *\n   * @return {Object} an object, usually matching { req, res, gql }\n   */\n  get requestData(): Object | null {\n    // @ComputedType\n    return this[REQ_DATA_KEY];\n  }\n\n  /**\n   * A setter that assigns a value to the inner request data object. When\n   * used with GQLExpressMiddleware, this is an object matching {req, res, gql}.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⬆︎⠀requestData\n   *\n   * @param {Object} value an object, usually matching { req, res, gql }\n   */\n  set requestData(value: Object): void {\n    // @ComputedType\n    this[REQ_DATA_KEY] = value;\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Properties defined for GraphQL types in Lattice can be defined as\n   * a getter, a function or an async function. In the case of standard\n   * functions, if they return a promise they will be handled as though\n   * they were async\n   *\n   * Given the variety of things a GraphQL type can actually be, obtaining\n   * its value can annoying. This method tends to lessen that boilerplate.\n   * Errors raised will be thrown.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀getProp\n   *\n   * @param {string|Symbol} propName the name of the property in question\n   * @param {boolean} bindGetters true, by default, if the `get` or\n   * `initializer` descriptor values should be bound to the current instance\n   * or an object of the programmers choice before returning\n   * @param {mixed} bindTo the `this` object to use for binding when\n   * `bindGetters` is set to true.\n   * @return {mixed} the value of the `propName` as a Function or something\n   * else when the requested property name exists\n   *\n   * @throws {Error} errors raised in awaiting results will be thrown\n   */\n  getProp(propName: string, bindGetters: boolean = true, bindTo: mixed) {\n    // $FlowFixMe\n    let proto = Object.getPrototypeOf(this)\n    let descriptor = Object.getOwnPropertyDescriptor(proto, propName)\n    let result\n\n    if (!descriptor) {\n      return null;\n    }\n\n    if (descriptor) {\n      if (descriptor.initializer || descriptor.get) {\n        let what = descriptor.initializer || descriptor.get\n\n        if (bindGetters) {\n          result = what.bind(bindTo || this)\n        }\n        else {\n          result = what\n        }\n      }\n      else if (descriptor.value) {\n        result = descriptor.value\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Properties defined for GraphQL types in Lattice can be defined as\n   * a getter, a function or an async function. In the case of standard\n   * functions, if they return a promise they will be handled as though\n   * they were async. In addition to fetching the property, or field\n   * resolver, its resulting function or getter will be invoked.\n   *\n   * Given the variety of things a GraphQL type can actually be, obtaining\n   * its value can annoying. This method tends to lessen that boilerplate.\n   * Errors raised will be thrown.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀callProp\n   *\n   * @param {string} propName the name of the property in question\n   * @param {Array<mixed>} args the arguments array that will be passed\n   * to `.apply()` should the property evaluate to a `function`\n   * @return {mixed} the return value of any resulting function or\n   * value returned by a getter; wrapped in a promise as all async\n   * functions do.\n   *\n   * @throws {Error} errors raised in awaiting results will be thrown\n   */\n  async callProp(propName: string, ...args: Array<mixed>) {\n    // $FlowFixMe\n    let prop = this.getProp(propName, ...args);\n    let result\n\n    if (prop && typeOf(prop) === 'AsyncFunction') {\n      try {\n        result = await prop.apply(this, args);\n      }\n      catch (error) {\n        throw new AsyncFunctionExecutionError(error, prop, args, result)\n      }\n    }\n    else if (prop && typeOf(prop) === Function.name) {\n      try {\n        result = prop.apply(this, args)\n      }\n      catch (error) {\n        throw new FunctionExecutionError(error, prop, args, result)\n      }\n\n      if (typeOf(result) === Promise.name) {\n        try {\n          result = await result\n        }\n        catch (error) {\n          throw new AwaitingPromiseError(error).setPromise(result)\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * A pass-thru method to the static function of the same name. The\n   * difference being that if `requestData` is not specified, the\n   * `requestData` object from this instance will be used to build the\n   * resolvers in question.\n   *\n   * @instance\n   * @method ⌾⠀getResolver\n   * @memberof GQLBase\n   *\n   * @param {string} resolverName the name of the resolver as a string\n   * @param {Object} requestData the requestData used to build the\n   * resolver methods from which to choose\n   * @return {Function} returns either a `function` representing the\n   * resolver requested or null if there wasn't one to be found\n   */\n  async getResolver(resolverName: string, requestData: Object) {\n    return await this.constructor.getResolver(\n      resolverName,\n      requestData || this.requestData\n    )\n  }\n\n  /**\n   * Resolvers are created in a number of different ways. OOP design\n   * dictates that instances of a created class will handle field\n   * resolvers, but query, mutation and subscription resolvers are\n   * typically what creates these instances.\n   *\n   * Since a resolver can be created using `@mutator/@subscriptor/@resolver`\n   * or via method on a object returned from `RESOLVERS()`, `MUTATORS()` or\n   * `SUBSCRIPTIONS()`, there should be an easy to use way to fetch a\n   * resolver by name; if for nothing else, code reuse.\n   *\n   * Pass the name of the resolver to the function and optionally pass a\n   * requestData object. The `getMergedRoot()` method will build an object\n   * containing all the root resolvers for the type, bound to the supplied\n   * `requestData` object. It is from this object that `resolverName` will\n   * be used to fetch the function in question. If one exists, it will be\n   * returned, ready for use. Otherwise, null will be your answer.\n   *\n   *\n   * @static\n   * @method ⌾⠀getResolver\n   * @memberof GQLBase\n   *\n   * @param {string} resolverName the name of the resolver as a string\n   * @param {Object} requestData the requestData used to build the\n   * resolver methods from which to choose\n   * @return {Function} returns either a `function` representing the\n   * resolver requested or null if there wasn't one to be found\n   */\n  static async getResolver(resolverName: string, requestData: Object) {\n    const reqData = requestData || null\n    const rootObj = await this.getMergedRoot(reqData)\n\n    return rootObj[resolverName] || null\n  }\n\n  /**\n   * The static version of getProp reads into the prototype to find the field\n   * that is desired. If the field is either a getter or a initializer (see\n   * class properties descriptors), then the option to bind that to either the\n   * prototype object or one of your choosing is available.\n   *\n   * @memberof GQLBase\n   * @method ⌾⠀getProp\n   * @static\n   *\n   * @param {string|Symbol} propName a string or Symbol denoting the name of\n   * the property or field you desire\n   * @param {boolean} bindGetters true if a resulting `getter` or `initializer`\n   * should be bound to the prototype or other object\n   * @param {mixed} bindTo the object to which to bind the `getter` or\n   * `initializer` functions to if other than the class prototype.\n   * @return {mixed} a `Function` or other mixed value making up the property\n   * name requested\n   */\n  static getProp(\n    propName: string,\n    bindGetters: boolean = false,\n    bindTo: mixed\n  ) {\n    let descriptor = Object.getOwnPropertyDescriptor(this.prototype, propName)\n\n    if (descriptor) {\n      if (descriptor.get || descriptor.initializer) {\n        let what = descriptor.initializer || descriptor.get\n\n        if (bindGetters) {\n          bindTo = bindTo || this.prototype\n\n          return what.bind(bindTo)\n        }\n        else {\n          return what\n        }\n      }\n      else {\n        return descriptor.value\n      }\n    }\n    else {\n      return null\n    }\n  }\n\n  /**\n   * Until such time as the reference implementation of Facebook's GraphQL\n   * SDL AST parser supports comments, or until we take advantage of Apollo's\n   * AST parser, this is how comments will be applied to a built schema.\n   *\n   * Several constants are defined on the GQLBase object itself, and thereby\n   * all its subclasses. They pertain to how to define description fields\n   * for various parts of your GQL implementation.\n   *\n   * ```\n   * // To define a description on the top level class\n   * [this.DOC_CLASS]: string\n   *\n   * // To define a description on a field (getter, function or async function)\n   * [this.DOC_FIELDS]: {\n   *   fieldName: string\n   * }\n   *\n   * // To define a description on a query, mutation or subscription field\n   * [this.DOC_QUERIES || this.DOC_MUTATORS || this.DOC_SUBSCRIPTIONS]: {\n   *   fieldName: string\n   * }\n   * ```\n   *\n   * To make writing code easier, the `joinLines()` template function is\n   * available so your source code can look nice and neat and your descriptions\n   * won't get annoying line breaks and spaces as part of that process.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method apiDocs\n   *\n   * @return {Object} an object with various keys and values denoting\n   * description fields that should be applied to the final schema object\n   */\n  static apiDocs(): Object {\n    return {\n      [this.DOC_CLASS]: joinLines`\n        GQLBase class implementation. GQLBase is the root class used in\n        graphql-lattice to describe a GraphQLObjectType. If you are reading\n        this, the person using lattice failed to provide documentation for\n        their type. :)\n      `,\n\n      [this.DOC_QUERY]: joinLines`\n        ## Welcome to GraphQL Lattice\n        **Query**\n\n        You will want to define a \\`DOC_QUERY\\` apiDoc comment with something\n        more meaningful to your particular Schema here.\n      `,\n\n      [this.DOC_MUTATION]: joinLines`\n        ## Welcome to GraphQL Lattice\n        **Mutation**\n\n        You will want to define a \\`DOC_MUTATION\\` apiDoc comment with\n        something more meaningful to your particular Schema here.\n      `,\n\n      [this.DOC_SUBSCRIPTION]: joinLines`\n        ## Welcome to GraphQL Lattice\n        **Subscription**\n\n        You will want to define a \\`DOC_SUBSCRIPTION\\` apiDoc comment with\n        something more meaningful to your particular Schema here.\n      `,\n\n      [this.DOC_FIELDS]: {\n        // fieldName: `fieldDescription`,\n      },\n\n      [this.DOC_QUERIES]: {\n        // queryName: `queryDescription`,\n      },\n\n      [this.DOC_MUTATORS]: {\n        // mutatorName: `mutatorDescription`\n      },\n\n      [this.DOC_SUBSCRIPTIONS]: {\n        // subscriptionName: `subscriptionDescription`\n      }\n    }\n  }\n\n  /**\n   * Defined in a base class, this getter should return either a String\n   * detailing the full IDL schema of a GraphQL handler or one of two\n   * types of Symbols.\n   *\n   * The first Symbol type is the constant `ADJACENT_FILE`. If this Symbol is\n   * returned, the system assumes that next to the source file in question is\n   * a file of the same name with a .graphql extension. This file should be\n   * made of the GraphQL IDL schema definitions for the object types being\n   * created.\n   *\n   * Example:\n   * ```js\n   *   static get SCHEMA(): string | Symbol {\n   *     return GQLBase.ADJACENT_FILE\n   *   }\n   * ```\n   *\n   * The primary advantage of this approach is allowing an outside editor that\n   * provides syntax highlighting rather than returning a string from the\n   * SCHEMA getter.\n   *\n   * Alternatively, the static method IDLFilePath can be used to point to an\n   * alternate location where the GraphQL IDL file resides. The extension can\n   * also be changed from .graphql to something else if need be using this\n   * method.\n   *\n   * Example:\n   * ```js\n   *   static get SCHEMA(): string | Symbol {\n   *     return GQLBase.IDLFilePath('/path/to/file', '.idl')\n   *   }\n   * ```\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⬇︎⠀SCHEMA\n   * @readonly\n   * @static\n   *\n   * @return {string|Symbol} a valid IDL string or one of the Symbols\n   * described above.\n   *\n   * @see {@link GQLBase#ADJACENT_FILE}\n   * @see {@link GQLBase#IDLFilePath}\n   */\n  static get SCHEMA(): string | Symbol {\n    return ''\n  }\n\n  /**\n   * This method should return a promise that resolves to an object of\n   * functions matching the names of the mutation operations. These are to be\n   * injected into the root object when used by `GQLExpressMiddleware`.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀MUTATORS\n   * @readonly\n   * @static\n   *\n   * @param {Object} requestData typically an object containing three\n   * properties; {req, res, gql}\n   * @return {Promise} a promise that resolves to an object; see above for more\n   * information.\n   */\n  static async MUTATORS(requestData: Object): Promise<Object> {\n    // define in base class\n    return {};\n  }\n\n  /**\n   * This method should return a promise that resolves to an object of\n   * functions matching the names of the query operations. These are to be\n   * injected into the root object when used by `GQLExpressMiddleware`.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀RESOLVERS\n   * @readonly\n   * @static\n   *\n   * @param {Object} requestData typically an object containing three\n   * properties; {req, res, gql}\n   * @return {Promise} a promise that resolves to an object; see above for more\n   * information.\n   */\n  static async RESOLVERS(requestData: Object): Promise<Object> {\n    // define in base class\n    return {};\n  }\n\n  /**\n   * @see {@link GQLBase#SCHEMA}\n   *\n   * @memberof GQLBase\n   * @method ⬇︎⠀ADJACENT_FILE\n   * @static\n   * @const\n   *\n   * @return {Symbol} the Symbol, when returned from SCHEMA, causes\n   * the logic to load an IDL Schema from an associated file with a .graphql\n   * extension and bearing the same name.\n   */\n  static get ADJACENT_FILE(): Symbol {\n    return Symbol.for('.graphql file located adjacent to source')\n  }\n\n  /**\n   * Determines the default type targeted by this GQLBase class. Any\n   * type will technically be valid but only will trigger special behavior\n   *\n   * @memberof GQLBase\n   * @method ⬇︎⠀GQL_TYPE\n   * @static\n   * @const\n   *\n   * @return {Function} a type, such as `GraphQLObjectType` or\n   * `GraphQLInterfaceType`\n   */\n  static get GQL_TYPE(): Function {\n    return GraphQLObjectType;\n  }\n\n  /**\n   * Creates an appropriate Symbol crafted with the right data for use by\n   * the IDLFileHandler class below.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⌾⠀IDLFilePath\n   *\n   * @param {string} path a path to the IDL containing file\n   * @param {string} [extension='.graphql'] an extension, including the\n   * prefixed period, that will be added to the supplied path should it not\n   * already exist.\n   * @return Symbol\n   *\n   * @see {@link GQLBase#SCHEMA}\n   */\n  static IDLFilePath(path: string, extension: string = '.graphql'): Symbol {\n    return Symbol.for(`Path ${path} Extension ${extension}`);\n  }\n\n  /**\n   * A file handler for fetching the IDL schema string from the file system\n   * for those `GQLBase` extended classes that have indicated to do so by\n   * returning a `Symbol` for their `SCHEMA` property.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀handler\n   *\n   * @return {IDLFileHandler} instance of IDLFileHandler, created if one does\n   * not already exist, for fetching the contents from disk.\n   */\n  static get handler(): IDLFileHandler {\n    const key = Symbol.for(`${IDLFileHandler.name}.${this.name}`);\n\n    // @ComputedType\n    if (!this[key]) {\n      // @ComputedType\n      this[key] = new IDLFileHandler(this);\n    }\n\n    // @ComputedType\n    return this[key];\n  }\n\n  /**\n   * Returns the module object where your class is created. This needs to be\n   * defined on your class, as a static getter, in the FILE where you are\n   * defining your Class definition.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀module\n   * @const\n   *\n   * @return {Object} the reference to the module object defined and injected\n   * by node.js' module loading system.\n   *\n   * @see https://nodejs.org/api/modules.html\n   */\n  static get module(): Object {\n    return module;\n  }\n\n  /**\n   * The internal data model has some custom `EventEmitter` code wrapped\n   * it here. When the data model is set via `setModel` or by accessing it\n   * via `instance[MODEL_KEY]`, an event `EVENT_MODEL_SET` is emitted. Any\n   * listener listening for this event receives an object with two keys\n   * ```\n   * {\n   *   model: The actual model being set; changes are persisted\n   *   instance: The GQLBase instance the model is associated with\n   * }\n   * ```\n   *\n   * Subsequently, the events `EVENT_MODEL_PROP_CHANGE` and\n   * `EVENT_MODEL_PROP_DELETE` can be listened to if your version of node\n   * supports Proxy objects. They allow you to be notified whenever your\n   * model has a property changed or deleted, respectively.\n   *\n   * The callback for `change` receives an object with four properties\n   * ```\n   * {\n   *   model: The model object the value is being changed on\n   *   old: The old value being replaced; undefined if it is the first time\n   *   key: The property key for the value being changed\n   *   value: The new value being set\n   * }\n   * ```\n   *\n   * The callback for `delete` receives an object with four properties\n   * ```\n   * {\n   *   model: The model object the value is deleted from\n   *   key: The property key for the deleted value\n   *   deleted: The deleted value\n   * }\n   * ```\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⌾⠀setupModel\n   *\n   * @param {GQLBase} instance typically `this` as passed in from a call in\n   * the constructor\n   */\n  static setupModel(instance: GQLBase) {\n    const changeHandler: Object = {\n      /**\n       * Proxy set() handler. This is where the change events are fired from\n       *\n       * @method GQLBase~set\n       * @param {Object} target the `GQLBase` model object\n       * @param {string} key the property name\n       * @param {mixed} value the new property value\n       */\n      set(target, key, value) {\n        const old = target[key];\n\n        target[key] = value;\n        instance.emit(GQLBase.EVENT_MODEL_PROP_CHANGE, {\n          model: target,\n          old,\n          key,\n          value\n        })\n      },\n\n      /**\n       * Proxy deleteProperty() handler. This is where the delete property\n       * events are fired from\n       *\n       * @method GQLBase~deleteProperty\n       * @param {Object} target the `GQLBase` model object\n       * @param {string} key the property name\n       */\n      deleteProperty(target, key) {\n        const deleted = target[key];\n\n        delete target[key];\n        instance.emit(GQLBase.EVENT_MODEL_PROP_DELETE, {\n          model: target,\n          key,\n          deleted\n        })\n      }\n    }\n\n    /**\n     * 'Publicly' the Symbol for accessing the `GQLBase` model is `MODEL_KEY`.\n     * In truth it is stored under a Symbol defined in `setupModel` and\n     * referred to as `_MODEL_KEY` in this code. This is done so a getter and\n     * setter can be wrapped around the usage of the instance's data model.\n     *\n     * When being read, if `Proxy` exists in the node environment and if there\n     * are any registered `EVENT_MODEL_PROP_CHANGE` or `EVENT_MODEL_PROP_DELETE`\n     * events, then the returned model is a Proxy around the real model that\n     * allows us to capture the changes and deletion of keys\n     *\n     * When being assigned, the event `EVENT_MODEL_WILL_BE_SET` and the event\n     * `EVENT_MODEL_HAS_BEEN_SET` are emitted to allow listeners to modify and\n     * see the final data around the setting of a model object. Both events\n     * receive an object with two keys\n     *\n     * ```\n     * {\n     *   model: The object being or having been set\n     *   instance: The GQLBase instance receiving the model\n     * }\n     * ```\n     */\n    Object.defineProperty(instance, MODEL_KEY, {\n      get: function() {\n        let model = this[_MODEL_KEY]\n        let hasListeners =\n          this.listenerCount(GQLBase.EVENT_MODEL_PROP_CHANGE) +\n          this.listenerCount(GQLBase.EVENT_MODEL_PROP_DELETE)\n\n        if (hasProxy && hasListeners) {\n          model = new Proxy(model, changeHandler);\n        }\n\n        return model\n      },\n\n      set: function(model) {\n        const instance = this;\n\n        this.emit(GQLBase.EVENT_MODEL_WILL_BE_SET, { model, instance });\n        instance[_MODEL_KEY] = model;\n        this.emit(GQLBase.EVENT_MODEL_HAS_BEEN_SET, { model, instance })\n      }\n    });\n  }\n\n  /**\n   * If ES6 Proxies are supported in your execution environment, all GQLBase\n   * extended classes are also proxies. By default the internal proxy handler\n   * provides backwards compatibility with the removal of the default getters\n   * and setters for the 'model' property as long as you do not define a\n   * top level 'model' property of your own.\n   *\n   * @method ⬇︎⠀[_PROXY_HANDLER]\n   * @memberof GQLBase\n   * @static\n   * @const\n   * @since 2.5.0\n   *\n   * @type {Object}\n   * @ComputedType\n   */\n  static get [_PROXY_HANDLER]() {\n    return {\n      get(target, key, lastResult) {\n        const model = target[_MODEL_KEY];\n\n        // Allow backwards compatibility for 'model' property if one is not\n        // explicitly defined on your instance.\n        if (notDefined('model', key, target)) {\n          // Be sure to use the public MODEL_KEY to ensure events fire\n          return target[MODEL_KEY];\n        }\n\n        return target[key]\n      }\n    }\n  }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * A constant used to register an event listener for when the internal\n   * model object is assigned a new value. This event fires before the model\n   * is set. Changes to the model value at this point will affect the contents\n   * before the value assignment takes place.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_WILL_BE_SET\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_WILL_BE_SET() { return 'E: Int. model will be set' }\n\n  /**\n   * A constant used to register an event listener for when the internal\n   * model object is assigned a new value. This event fires after the model\n   * is set.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_HAS_BEEN_SET\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_HAS_BEEN_SET() { return 'E: Int. model has been set' }\n\n  /**\n   * A constant used to register an event listener for when a property of the\n   * internal model object is set to a new or intial value.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_PROP_CHANGE\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_PROP_CHANGE() { return 'E: Int. model prop changed' }\n\n  /**\n   * A constant used to register an event listener for when a property of the\n   * internal model object has been deleted. This event fires after the value\n   * has been deleted.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_PROP_DELETE\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_PROP_DELETE() { return 'E: Int. model prop deleted' }\n\n  /**\n   * A constant key used to identify a comment for a class description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_CLASS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_CLASS() { return 'class' }\n\n  /**\n   * A constant key used to identify a comment for a type field description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_FIELDS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_FIELDS() { return 'fields' }\n\n  /**\n   * A constant key used to identify a comment for the top level query\n   * description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_QUERY\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_QUERY() { return 'query' }\n\n  /**\n   * A constant key used to identify a comment for a query description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_QUERIES\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_QUERIES() { return 'queries' }\n\n  /**\n   * A constant key used to identify a comment for the top level mutation\n   * description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_MUTATION\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_MUTATION() { return 'mutation' }\n\n  /**\n   * A constant key used to identify a comment for a mutator description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_MUTATORS\n   * @const\n   * @deprecated Use `DOC_MUTATIONS` instead\n   *\n   * @type {string}\n   */\n  static get DOC_MUTATORS() { return 'mutators' }\n\n  /**\n   * A constant key used to identify a comment for a mutator description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_MUTATORS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_MUTATIONS() { return 'mutators' }\n\n  /**\n   * A constant key used to identify a comment for the top level subscription\n   * description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_SUBSCRIPTION\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_SUBSCRIPTION() { return 'subscription' }\n\n  /**\n   * A constant key used to identify a comment for a subscription description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_SUBSCRIPTIONS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_SUBSCRIPTIONS() { return 'subscriptions' }\n\n  /**\n   * A shortcut to the utils/joinLines function to make it easier to get\n   * the tools to write docs for your types in a friendly fashion.\n   *\n   * @memberof GQLBase\n   * @method ⬇︎⠀joinLines\n   * @static\n   * @const\n   *\n   * @type {Function}\n   */\n  static get joinLines(): Function { return joinLines }\n\n  /**\n   * An simple pass-thru method for fetching a types merged root object.\n   *\n   * @method ⌾⠀getMergedRoot\n   * @memberof GQLBase\n   * @static\n   *\n   * @param {Object} requestData an object containing the request data such as\n   * request, response or graphql context info that should be passed along to\n   * each of the resolver creators\n   * @return {Object} the merged root object with all the query, mutation and\n   * subscription resolvers defined and created within.\n   */\n  static async getMergedRoot(\n    requestData: Object,\n    separateByType: boolean = false\n  ): Object {\n    const root = {};\n    const Class = this;\n\n    let _ = {\n      // $FlowFixMe\n      resolvers: Class[META_KEY].resolvers || [],\n      // $FlowFixMe\n      mutators: Class[META_KEY].mutators || [],\n      // $FlowFixMe\n      subscriptors: Class[META_KEY].subscriptors || []\n    }\n\n    let convert = f => {\n      let isFactoryClass = (c) => {\n        return !!Class[META_KEY][Symbol.for('Factory Class')]\n      }\n\n      if (isFactoryClass(Class)) {\n        return {\n          [f.name]: function(...args) {\n            return f.apply(Class, [Class, requestData, ...args])\n          }\n        }\n      }\n      else {\n        return {\n          [f.name]: function(...args) {\n            return f.apply(Class, [requestData, ...args])\n          }\n        }\n      }\n    }\n    let reduce = (p, c) => merge(p, c)\n\n    _.resolvers = _.resolvers.map(convert).reduce(reduce, {})\n    _.mutators = _.mutators.map(convert).reduce(reduce, {})\n    _.subscriptors = _.subscriptors.map(convert).reduce(reduce, {})\n\n    if (separateByType) {\n      // Apollo wants all the resolvers to grouped by top level type.\n      // The field resolvers aren't an issue in Lattice defined types\n      // but the root types do need to be sorted; so let's do that here\n      merge(\n        root,\n        { Query: await Class.RESOLVERS(requestData) },\n        { Mutation: await Class.MUTATORS(requestData) },\n        { Query: _.resolvers },\n        { Mutation: _.mutators },\n        { Subscription: _.subscriptors }\n      );\n\n      // When using lattice with apollo server, it is quite particular about\n      // empty Query, Mutation or Subscription resolver maps.\n      if (!Object.keys(root.Query).length) delete root.Query\n      if (!Object.keys(root.Mutation).length) delete root.Mutation\n      if (!Object.keys(root.Subscription).length) delete root.Subscription\n    }\n    else {\n      merge(\n        root,\n        await Class.RESOLVERS(requestData),\n        await Class.MUTATORS(requestData),\n        _.resolvers,\n        _.mutators,\n        _.subscriptors\n      );\n    }\n\n    return root;\n  }\n\n  /**\n   * An object used to store data used by decorators and other internal\n   * proccesses.\n   * @ComputedType\n   */\n  static get [META_KEY]() {\n    let storage = this[Symbol.for(this.name)]\n\n    if (!storage) {\n      storage = (this[Symbol.for(this.name)] = {})\n    }\n\n    return storage;\n  }\n}\n\nexport default GQLBase;\n"]}