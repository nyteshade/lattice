{"version":3,"sources":["../es6/GQLBase.js"],"names":["notDefined","hasProxy","global","Proxy","_MODEL_KEY","_PROXY_HANDLER","keyToTest","keySupplied","instance","RegExp","test","toString","hasOwnProperty","MODEL_KEY","REQ_DATA_KEY","META_KEY","AUTO_PROPS","GETTERS","SETTERS","PROPS","GQLBase","modelData","requestData","options","autoProps","Class","constructor","setupModel","setModel","fileHandler","applyAutoProps","SCHEMA","length","warn","name","GQL_TYPE","tree","from","outline","props","propName","desc","prototype","hasCustomImpl","get","value","push","info","error","parsed","exec","message","extensions","args","prop","result","apply","Function","resolverName","getResolver","reqData","getMergedRoot","rootObj","DOC_CLASS","DOC_QUERY","DOC_MUTATION","DOC_SUBSCRIPTION","DOC_FIELDS","DOC_QUERIES","DOC_MUTATORS","DOC_SUBSCRIPTIONS","path","extension","changeHandler","set","target","key","old","emit","EVENT_MODEL_PROP_CHANGE","model","deleteProperty","deleted","EVENT_MODEL_PROP_DELETE","hasListeners","listenerCount","EVENT_MODEL_WILL_BE_SET","EVENT_MODEL_HAS_BEEN_SET","separateByType","root","_","resolvers","mutators","subscriptors","convert","f","bind","reduce","p","c","map","RESOLVERS","Query","MUTATORS","Mutation","Subscription","module","lastResult","storage"],"mappings":"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","file":"GQLBase.js","sourceRoot":"es6","sourcesContent":["/** @namespace GQLBaseEnv */\n// @flow\n\nimport Path from 'path'\nimport fs from 'fs'\n\nimport { Deferred, joinLines } from './utils'\nimport { typeOf } from './types'\nimport { SyntaxTree } from './SyntaxTree'\nimport { Properties } from './decorators/ModelProperties'\nimport { GraphQLObjectType, GraphQLEnumType } from 'graphql'\nimport { IDLFileHandler } from './IDLFileHandler'\nimport { merge } from 'lodash'\nimport { LatticeLogs as ll } from './utils'\n\nimport EventEmitter from 'events'\n\n/* Internal implementation to detect the existence of proxies. When present\n * additional functionality is enabled. Proxies are native in Node >= 6 */\nconst hasProxy = typeof global.Proxy !== 'undefined';\n\n/* Internal Symbol referring to real accessor to GQLBase model object */\nconst _MODEL_KEY = Symbol.for('data-model-contents-value');\n\n/* Internal Symbol referring to the static object containing a proxy handler */\nconst _PROXY_HANDLER = Symbol.for('internal-base-proxy-handler')\n\n/**\n * Simple function to check if a supplied key matches a string of your\n * choosing and that string is not a defined property on the instance\n * passed to the check.\n *\n * @method GQLBaseEnv~notDefined\n * @memberof GQLBaseEnv\n * @since 2.5.0\n *\n * @param {string} keyToTest a String denoting the property you wish to test\n * @param {mixed} keySupplied a value, coerced `toString()`, to compare to\n * `keyToTest`\n * @param {mixed} instance an object instance to check `hasOwnProperty` on for\n * the `keyToTest` supplied.\n * @return {Boolean} true if the property matches the supplied key and that\n * property is not an ownedProperty of the instance supplied.\n */\nexport function notDefined(\n  keyToTest: string,\n  keySupplied: Object | string,\n  instance: Object\n) {\n  return (\n    new RegExp(\"^\" + keyToTest + \"$\").test(keySupplied.toString())\n    && !instance.hasOwnProperty(keyToTest)\n  );\n}\n\n/**\n * A `Symbol` used as a key to store the backing model data. Designed as a\n * way to separate model data and GraphQL property accessors into logical bits.\n *\n * @type {Symbol}\n * @memberof GQLBaseEnv\n * @const\n */\nexport const MODEL_KEY = Symbol.for('data-model-contents-key');\n\n/**\n * A `Symbol` used as a key to store the request data for an instance of the\n * GQLBase object in question.\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberof GQLBaseEnv\n */\nexport const REQ_DATA_KEY = Symbol.for('request-data-object-key');\n\n/**\n * A nameless Symbol for use as a key to the internal decorator storage\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberof GQLBaseEnv\n */\nexport const META_KEY = Symbol();\n\n/**\n * A Symbol used to identify calls to @Properties for properties generated\n * automatically upon instance creation.\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const AUTO_PROPS = Symbol.for('auto-props')\n\n/**\n * A Symbol used to identify calls to @Getters for properties generated\n * via decorator. These are stored in <class>[META_KEY][GETTERS]\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const GETTERS = Symbol.for('getters')\n\n/**\n * A Symbol used to identify calls to @Setters for properties generated\n * via decorator. These are stored in <class>[META_KEY][SETTERS]\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const SETTERS = Symbol.for('setters')\n\n/**\n * A Symbol used to identify calls to @Properties for properties generated\n * via decorator. These are stored in <class>[META_KEY][PROPS]\n *\n * @type {Symbol}\n * @const\n * @inner\n * @memberOf GQLBaseEnv\n */\nexport const PROPS = Symbol.for('props')\n\n/**\n * All GraphQL Type objects used in this system are assumed to have extended\n * from this class. An instance of this class can be used to wrap an existing\n * structure if you have one.\n *\n * @class GQLBase\n */\nexport class GQLBase extends EventEmitter {\n  fileHandler: ?IDLFileHandler;\n\n  /**\n   * Request data is passed to this object when constructed. Typically these\n   * objects, and their children, are instantiated by its own static MUTATORS\n   * and RESOLVERS. They should contain request specific state if any is to\n   * be shared.\n   *\n   * These can be considered request specific controllers for the object in\n   * question. The base class takes a single object which should contain all\n   * the HTTP/S request data and the graphQLParams is provided as the object\n   * { query, variables, operationName, raw }.\n   *\n   * When used with express-graphql, the requestData object has the format\n   * { req, res, gql } where\n   *   • req is an Express 4.x request object\n   *   • res is an Express 4.x response object\n   *   • gql is the graphQLParams object in the format of\n   *     { query, variables, operationName, raw }\n   *     See https://github.com/graphql/express-graphql for more info\n   *\n   * @memberof GQLBase\n   * @method ⎆⠀constructor\n   * @constructor\n   *\n   * @param {mixed} modelData this, typically an object, although anything\n   * really is supported, represents the model data for our GraphQL object\n   * instance.\n   * @param {Object} requestData see description above\n   */\n  constructor(\n    modelData: Object = {},\n    requestData: ?Object = null,\n    options: Object = { autoProps: true }\n  ) {\n    super();\n\n    const Class = this.constructor;\n\n    GQLBase.setupModel(this);\n    this.setModel(modelData);\n    this.requestData = requestData || {};\n    this.fileHandler = new IDLFileHandler(this.constructor);\n\n    if (options && !!options.autoProps !== false) {\n      this.applyAutoProps()\n    }\n\n    // @ComputedType\n    return hasProxy ? new Proxy(this, GQLBase[_PROXY_HANDLER]) : this;\n  }\n\n  /**\n   * Since reading the Schema for a given GraphQL Lattice type or\n   * interface is simple enough, we should be able to automatically\n   * apply one to one GraphQL:Model properties.\n   *\n   * @instance\n   * @method ⌾⠀applyAutoProps\n   * @memberof GQLBase\n   */\n  applyAutoProps() {\n    if (!this.constructor.SCHEMA || !this.constructor.SCHEMA.length) {\n      ll.warn(joinLines`\n        There is no SCHEMA for ${this.constructor.name}!! This will likely\n        end in an error. Proceed with caution. Skipping \\`applyAutoProps\\`\n      `)\n      return\n    }\n\n    // Individual property getters do not need to be auto-created for enum\n    // types. Potentially do some checks for Interfaces and Unions as well\n    if (this.constructor.GQL_TYPE === GraphQLEnumType) {\n      return\n    }\n\n    let Class = this.constructor\n    let tree = SyntaxTree.from(Class.SCHEMA)\n    let outline = tree ? tree.outline : {}\n    let props = []\n\n    // $FlowFixMe\n    for (let propName of Object.keys(outline[Class.name])) {\n      // $FlowFixMe\n      let desc = Object.getOwnPropertyDescriptor(Class.prototype, propName)\n      let hasCustomImpl = !!(\n        // We have a descriptor for the property name\n        desc && (\n          // We have a getter function defined\n          typeof desc.get !== 'undefined'\n          ||\n          // ...or we have a function, async or not, defined\n          typeof desc.value === 'function'\n        )\n      )\n\n      // Only create auto-props for non custom implementations\n      if (!hasCustomImpl) {\n        props.push(propName)\n      }\n    }\n\n    if (props.length) {\n      ll.info(`Creating auto-props for [${Class.name}]: `, props)\n      try {\n        Properties(...props)(Class, [AUTO_PROPS])\n      }\n      catch(error) {\n        let parsed = /Cannot redefine property: (\\w+)/.exec(error.message)\n        if (parsed) {\n          ll.warn(`Skipping auto-prop '${Class.name}.${parsed[1]}'`)\n        }\n        else {\n          ll.error(`Failed to apply auto-properties\\nReason: `)\n          ll.error(error);\n        }\n      }\n    }\n  }\n\n  /**\n   * Getter for the internally stored model data. The contents of this\n   * object are abstracted away behind a `Symbol` key to prevent collision\n   * between the underlying model and any GraphQL Object Definition properties.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀getModel\n   * @since 2.5\n   *\n   * @param {Object} value any object you wish to use as a data store\n   */\n  getModel() {\n    // @ComputedType\n    return this[MODEL_KEY];\n  }\n\n  /**\n   * Setter for the internally stored model data. The contents of this\n   * object are abstracted away behind a `Symbol` key to prevent collision\n   * between the underlying model and any GraphQL Object Definition properties.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀setModel\n   * @since 2.5\n   *\n   * @param {Object} value any object you wish to use as a data store\n   */\n  setModel(value: Object): GQLBase {\n    // @ComputedType\n    this[MODEL_KEY] = value;\n    return this;\n  }\n\n  /**\n   * Uses `_.merge()` to modify the internal backing data store for the\n   * object instance. This is a shortcut for\n   * `_.merge()(instance[MODEL_KEY], ...extensions)`\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀extendModel\n   * @since 2.5\n   *\n   * @param {mixed} extensions n-number of valid `_.merge()` parameters\n   * @return {GQLBase} this is returned\n   */\n  extendModel(...extensions: Array<mixed>): GQLBase {\n    // $FlowFixMe\n    merge(this[MODEL_KEY], ...extensions);\n    return this;\n  }\n\n  /**\n   * A getter that retrieves the inner request data object. When used with\n   * GQLExpressMiddleware, this is an object matching {req, res, gql}.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⬇︎⠀requestData\n   *\n   * @return {Object} an object, usually matching { req, res, gql }\n   */\n  get requestData(): Object | null {\n    // @ComputedType\n    return this[REQ_DATA_KEY];\n  }\n\n  /**\n   * A setter that assigns a value to the inner request data object. When\n   * used with GQLExpressMiddleware, this is an object matching {req, res, gql}.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⬆︎⠀requestData\n   *\n   * @param {Object} value an object, usually matching { req, res, gql }\n   */\n  set requestData(value: Object): void {\n    // @ComputedType\n    this[REQ_DATA_KEY] = value;\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Properties defined for GraphQL types in Lattice can be defined as\n   * a getter, a function or an async function. In the case of standard\n   * functions, if they return a promise they will be handled as though\n   * they were async\n   *\n   * Given the variety of things a GraphQL type can actually be, obtaining\n   * its value can annoying. This method tends to lessen that boilerplate.\n   * Errors raised will be thrown.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀getProp\n   *\n   * @param {string} propName the name of the property in question\n   * @param {Array<mixed>} args the arguments array that will be passed\n   * to `.apply()` should the property evaluate to a `function`\n   * @return {mixed} the return value of any resulting function or\n   * value returned by a getter; wrapped in a promise as all async\n   * functions do.\n   *\n   * @throws {Error} errors raised in awaiting results will be thrown\n   */\n  async getProp(propName: string, ...args: Array<mixed>) {\n    // $FlowFixMe\n    let prop = this[propName]\n    let result\n\n    if (!prop) return null;\n\n    if (typeOf(prop) === 'AsyncFunction') {\n      try {\n        result = await prop.apply(this, args);\n      }\n      catch (error) {\n        throw error\n      }\n    }\n    else if (typeOf(prop) === Function.name) {\n      result = prop.apply(this, args)\n\n      if (typeOf(result) === Promise.name) {\n        try {\n          result = await result\n        }\n        catch (error) {\n          throw error\n        }\n      }\n    }\n    else {\n      result = prop\n    }\n\n    return result\n  }\n\n  /**\n   * A pass-thru method to the static function of the same name. The\n   * difference being that if `requestData` is not specified, the\n   * `requestData` object from this instance will be used to build the\n   * resolvers in question.\n   *\n   * @instance\n   * @method ⌾⠀getResolver\n   * @memberof GQLBase\n   *\n   * @param {string} resolverName the name of the resolver as a string\n   * @param {Object} requestData the requestData used to build the\n   * resolver methods from which to choose\n   * @return {Function} returns either a `function` representing the\n   * resolver requested or null if there wasn't one to be found\n   */\n  async getResolver(resolverName: string, requestData: Object) {\n    return this.constructor.getResolver(\n      resolverName,\n      requestData || this.requestData\n    )\n  }\n\n  /**\n   * Resolvers are created in a number of different ways. OOP design\n   * dictates that instances of a created class will handle field\n   * resolvers, but query, mutation and subscription resolvers are\n   * typically what creates these instances.\n   *\n   * Since a resolver can be created using `@mutator/@subscriptor/@resolver`\n   * or via method on a object returned from `RESOLVERS()`, `MUTATORS()` or\n   * `SUBSCRIPTIONS()`, there should be an easy to use way to fetch a\n   * resolver by name; if for nothing else, code reuse.\n   *\n   * Pass the name of the resolver to the function and optionally pass a\n   * requestData object. The `getMergedRoot()` method will build an object\n   * containing all the root resolvers for the type, bound to the supplied\n   * `requestData` object. It is from this object that `resolverName` will\n   * be used to fetch the function in question. If one exists, it will be\n   * returned, ready for use. Otherwise, null will be your answer.\n   *\n   *\n   * @static\n   * @method ⌾⠀getResolver\n   * @memberof GQLBase\n   *\n   * @param {string} resolverName the name of the resolver as a string\n   * @param {Object} requestData the requestData used to build the\n   * resolver methods from which to choose\n   * @return {Function} returns either a `function` representing the\n   * resolver requested or null if there wasn't one to be found\n   */\n  static async getResolver(resolverName: string, requestData: Object) {\n    const reqData = requestData || null\n    const rootObj = await this.getMergedRoot(reqData)\n\n    return rootObj[resolverName] || null\n  }\n\n  /**\n   * Until such time as the reference implementation of Facebook's GraphQL\n   * SDL AST parser supports comments, or until we take advantage of Apollo's\n   * AST parser, this is how comments will be applied to a built schema.\n   *\n   * Several constants are defined on the GQLBase object itself, and thereby\n   * all its subclasses. They pertain to how to define description fields\n   * for various parts of your GQL implementation.\n   *\n   * ```\n   * // To define a description on the top level class\n   * [this.DOC_CLASS]: string\n   *\n   * // To define a description on a field (getter, function or async function)\n   * [this.DOC_FIELDS]: {\n   *   fieldName: string\n   * }\n   *\n   * // To define a description on a query, mutation or subscription field\n   * [this.DOC_QUERIES || this.DOC_MUTATORS || this.DOC_SUBSCRIPTIONS]: {\n   *   fieldName: string\n   * }\n   * ```\n   *\n   * To make writing code easier, the `joinLines()` template function is\n   * available so your source code can look nice and neat and your descriptions\n   * won't get annoying line breaks and spaces as part of that process.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method apiDocs\n   *\n   * @return {Object} an object with various keys and values denoting\n   * description fields that should be applied to the final schema object\n   */\n  static apiDocs(): Object {\n    return {\n      [this.DOC_CLASS]: joinLines`\n        GQLBase class implementation. GQLBase is the root class used in\n        graphql-lattice to describe a GraphQLObjectType. If you are reading\n        this, the person using lattice failed to provide documentation for\n        their type. :)\n      `,\n\n      [this.DOC_QUERY]: joinLines`\n        ## Welcome to GraphQL Lattice\n        **Query**\n\n        You will want to define a \\`DOC_QUERY\\` apiDoc comment with something\n        more meaningful to your particular Schema here.\n      `,\n\n      [this.DOC_MUTATION]: joinLines`\n        ## Welcome to GraphQL Lattice\n        **Mutation**\n\n        You will want to define a \\`DOC_MUTATION\\` apiDoc comment with\n        something more meaningful to your particular Schema here.\n      `,\n\n      [this.DOC_SUBSCRIPTION]: joinLines`\n        ## Welcome to GraphQL Lattice\n        **Subscription**\n\n        You will want to define a \\`DOC_SUBSCRIPTION\\` apiDoc comment with\n        something more meaningful to your particular Schema here.\n      `,\n\n      [this.DOC_FIELDS]: {\n        // fieldName: `fieldDescription`,\n      },\n\n      [this.DOC_QUERIES]: {\n        // queryName: `queryDescription`,\n      },\n\n      [this.DOC_MUTATORS]: {\n        // mutatorName: `mutatorDescription`\n      },\n\n      [this.DOC_SUBSCRIPTIONS]: {\n        // subscriptionName: `subscriptionDescription`\n      }\n    }\n  }\n\n  /**\n   * Defined in a base class, this getter should return either a String\n   * detailing the full IDL schema of a GraphQL handler or one of two\n   * types of Symbols.\n   *\n   * The first Symbol type is the constant `ADJACENT_FILE`. If this Symbol is\n   * returned, the system assumes that next to the source file in question is\n   * a file of the same name with a .graphql extension. This file should be\n   * made of the GraphQL IDL schema definitions for the object types being\n   * created.\n   *\n   * Example:\n   * ```js\n   *   static get SCHEMA(): string | Symbol {\n   *     return GQLBase.ADJACENT_FILE\n   *   }\n   * ```\n   *\n   * The primary advantage of this approach is allowing an outside editor that\n   * provides syntax highlighting rather than returning a string from the\n   * SCHEMA getter.\n   *\n   * Alternatively, the static method IDLFilePath can be used to point to an\n   * alternate location where the GraphQL IDL file resides. The extension can\n   * also be changed from .graphql to something else if need be using this\n   * method.\n   *\n   * Example:\n   * ```js\n   *   static get SCHEMA(): string | Symbol {\n   *     return GQLBase.IDLFilePath('/path/to/file', '.idl')\n   *   }\n   * ```\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⬇︎⠀SCHEMA\n   * @readonly\n   * @static\n   *\n   * @return {string|Symbol} a valid IDL string or one of the Symbols\n   * described above.\n   *\n   * @see {@link GQLBase#ADJACENT_FILE}\n   * @see {@link GQLBase#IDLFilePath}\n   */\n  static get SCHEMA(): string | Symbol {\n    return ''\n  }\n\n  /**\n   * This method should return a promise that resolves to an object of\n   * functions matching the names of the mutation operations. These are to be\n   * injected into the root object when used by `GQLExpressMiddleware`.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀MUTATORS\n   * @readonly\n   * @static\n   *\n   * @param {Object} requestData typically an object containing three\n   * properties; {req, res, gql}\n   * @return {Promise} a promise that resolves to an object; see above for more\n   * information.\n   */\n  static async MUTATORS(requestData: Object): Promise<Object> {\n    // define in base class\n    return {};\n  }\n\n  /**\n   * This method should return a promise that resolves to an object of\n   * functions matching the names of the query operations. These are to be\n   * injected into the root object when used by `GQLExpressMiddleware`.\n   *\n   * @instance\n   * @memberof GQLBase\n   * @method ⌾⠀RESOLVERS\n   * @readonly\n   * @static\n   *\n   * @param {Object} requestData typically an object containing three\n   * properties; {req, res, gql}\n   * @return {Promise} a promise that resolves to an object; see above for more\n   * information.\n   */\n  static async RESOLVERS(requestData: Object): Promise<Object> {\n    // define in base class\n    return {};\n  }\n\n  /**\n   * @see {@link GQLBase#SCHEMA}\n   *\n   * @memberof GQLBase\n   * @method ⬇︎⠀ADJACENT_FILE\n   * @static\n   * @const\n   *\n   * @return {Symbol} the Symbol, when returned from SCHEMA, causes\n   * the logic to load an IDL Schema from an associated file with a .graphql\n   * extension and bearing the same name.\n   */\n  static get ADJACENT_FILE(): Symbol {\n    return Symbol.for('.graphql file located adjacent to source')\n  }\n\n  /**\n   * Determines the default type targeted by this GQLBase class. Any\n   * type will technically be valid but only will trigger special behavior\n   *\n   * @memberof GQLBase\n   * @method ⬇︎⠀GQL_TYPE\n   * @static\n   * @const\n   *\n   * @return {Function} a type, such as `GraphQLObjectType` or\n   * `GraphQLInterfaceType`\n   */\n  static get GQL_TYPE(): Function {\n    return GraphQLObjectType;\n  }\n\n  /**\n   * Creates an appropriate Symbol crafted with the right data for use by\n   * the IDLFileHandler class below.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⌾⠀IDLFilePath\n   *\n   * @param {string} path a path to the IDL containing file\n   * @param {string} [extension='.graphql'] an extension, including the\n   * prefixed period, that will be added to the supplied path should it not\n   * already exist.\n   * @return Symbol\n   *\n   * @see {@link GQLBase#SCHEMA}\n   */\n  static IDLFilePath(path: string, extension: string = '.graphql'): Symbol {\n    return Symbol.for(`Path ${path} Extension ${extension}`);\n  }\n\n  /**\n   * A file handler for fetching the IDL schema string from the file system\n   * for those `GQLBase` extended classes that have indicated to do so by\n   * returning a `Symbol` for their `SCHEMA` property.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀handler\n   *\n   * @return {IDLFileHandler} instance of IDLFileHandler, created if one does\n   * not already exist, for fetching the contents from disk.\n   */\n  static get handler(): IDLFileHandler {\n    const key = Symbol.for(`${IDLFileHandler.name}.${this.name}`);\n\n    // @ComputedType\n    if (!this[key]) {\n      // @ComputedType\n      this[key] = new IDLFileHandler(this);\n    }\n\n    // @ComputedType\n    return this[key];\n  }\n\n  /**\n   * Returns the module object where your class is created. This needs to be\n   * defined on your class, as a static getter, in the FILE where you are\n   * defining your Class definition.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀module\n   * @const\n   *\n   * @return {Object} the reference to the module object defined and injected\n   * by node.js' module loading system.\n   *\n   * @see https://nodejs.org/api/modules.html\n   */\n  static get module(): Object {\n    return module;\n  }\n\n  /**\n   * The internal data model has some custom `EventEmitter` code wrapped\n   * it here. When the data model is set via `setModel` or by accessing it\n   * via `instance[MODEL_KEY]`, an event `EVENT_MODEL_SET` is emitted. Any\n   * listener listening for this event receives an object with two keys\n   * ```\n   * {\n   *   model: The actual model being set; changes are persisted\n   *   instance: The GQLBase instance the model is associated with\n   * }\n   * ```\n   *\n   * Subsequently, the events `EVENT_MODEL_PROP_CHANGE` and\n   * `EVENT_MODEL_PROP_DELETE` can be listened to if your version of node\n   * supports Proxy objects. They allow you to be notified whenever your\n   * model has a property changed or deleted, respectively.\n   *\n   * The callback for `change` receives an object with four properties\n   * ```\n   * {\n   *   model: The model object the value is being changed on\n   *   old: The old value being replaced; undefined if it is the first time\n   *   key: The property key for the value being changed\n   *   value: The new value being set\n   * }\n   * ```\n   *\n   * The callback for `delete` receives an object with four properties\n   * ```\n   * {\n   *   model: The model object the value is deleted from\n   *   key: The property key for the deleted value\n   *   deleted: The deleted value\n   * }\n   * ```\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⌾⠀setupModel\n   *\n   * @param {GQLBase} instance typically `this` as passed in from a call in\n   * the constructor\n   */\n  static setupModel(instance: GQLBase) {\n    const changeHandler: Object = {\n      /**\n       * Proxy set() handler. This is where the change events are fired from\n       *\n       * @method GQLBase~set\n       * @param {Object} target the `GQLBase` model object\n       * @param {string} key the property name\n       * @param {mixed} value the new property value\n       */\n      set(target, key, value) {\n        const old = target[key];\n\n        target[key] = value;\n        instance.emit(GQLBase.EVENT_MODEL_PROP_CHANGE, {\n          model: target,\n          old,\n          key,\n          value\n        })\n      },\n\n      /**\n       * Proxy deleteProperty() handler. This is where the delete property\n       * events are fired from\n       *\n       * @method GQLBase~deleteProperty\n       * @param {Object} target the `GQLBase` model object\n       * @param {string} key the property name\n       */\n      deleteProperty(target, key) {\n        const deleted = target[key];\n\n        delete target[key];\n        instance.emit(GQLBase.EVENT_MODEL_PROP_DELETE, {\n          model: target,\n          key,\n          deleted\n        })\n      }\n    }\n\n    /**\n     * 'Publicly' the Symbol for accessing the `GQLBase` model is `MODEL_KEY`.\n     * In truth it is stored under a Symbol defined in `setupModel` and\n     * referred to as `_MODEL_KEY` in this code. This is done so a getter and\n     * setter can be wrapped around the usage of the instance's data model.\n     *\n     * When being read, if `Proxy` exists in the node environment and if there\n     * are any registered `EVENT_MODEL_PROP_CHANGE` or `EVENT_MODEL_PROP_DELETE`\n     * events, then the returned model is a Proxy around the real model that\n     * allows us to capture the changes and deletion of keys\n     *\n     * When being assigned, the event `EVENT_MODEL_WILL_BE_SET` and the event\n     * `EVENT_MODEL_HAS_BEEN_SET` are emitted to allow listeners to modify and\n     * see the final data around the setting of a model object. Both events\n     * receive an object with two keys\n     *\n     * ```\n     * {\n     *   model: The object being or having been set\n     *   instance: The GQLBase instance receiving the model\n     * }\n     * ```\n     */\n    Object.defineProperty(instance, MODEL_KEY, {\n      get: function() {\n        let model = this[_MODEL_KEY]\n        let hasListeners =\n          this.listenerCount(GQLBase.EVENT_MODEL_PROP_CHANGE) +\n          this.listenerCount(GQLBase.EVENT_MODEL_PROP_DELETE)\n\n        if (hasProxy && hasListeners) {\n          model = new Proxy(model, changeHandler);\n        }\n\n        return model\n      },\n\n      set: function(model) {\n        const instance = this;\n\n        this.emit(GQLBase.EVENT_MODEL_WILL_BE_SET, { model, instance });\n        instance[_MODEL_KEY] = model;\n        this.emit(GQLBase.EVENT_MODEL_HAS_BEEN_SET, { model, instance })\n      }\n    });\n  }\n\n  /**\n   * If ES6 Proxies are supported in your execution environment, all GQLBase\n   * extended classes are also proxies. By default the internal proxy handler\n   * provides backwards compatibility with the removal of the default getters\n   * and setters for the 'model' property as long as you do not define a\n   * top level 'model' property of your own.\n   *\n   * @method ⬇︎⠀[_PROXY_HANDLER]\n   * @memberof GQLBase\n   * @static\n   * @const\n   * @since 2.5.0\n   *\n   * @type {Object}\n   * @ComputedType\n   */\n  static get [_PROXY_HANDLER]() {\n    return {\n      get(target, key, lastResult) {\n        const model = target[_MODEL_KEY];\n\n        // Allow backwards compatibility for 'model' property if one is not\n        // explicitly defined on your instance.\n        if (notDefined('model', key, target)) {\n          // Be sure to use the public MODEL_KEY to ensure events fire\n          return target[MODEL_KEY];\n        }\n\n        return target[key]\n      }\n    }\n  }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * A constant used to register an event listener for when the internal\n   * model object is assigned a new value. This event fires before the model\n   * is set. Changes to the model value at this point will affect the contents\n   * before the value assignment takes place.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_WILL_BE_SET\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_WILL_BE_SET() { return 'E: Int. model will be set' }\n\n  /**\n   * A constant used to register an event listener for when the internal\n   * model object is assigned a new value. This event fires after the model\n   * is set.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_HAS_BEEN_SET\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_HAS_BEEN_SET() { return 'E: Int. model has been set' }\n\n  /**\n   * A constant used to register an event listener for when a property of the\n   * internal model object is set to a new or intial value.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_PROP_CHANGE\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_PROP_CHANGE() { return 'E: Int. model prop changed' }\n\n  /**\n   * A constant used to register an event listener for when a property of the\n   * internal model object has been deleted. This event fires after the value\n   * has been deleted.\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀EVENT_MODEL_PROP_DELETE\n   * @const\n   *\n   * @type {string}\n   */\n  static get EVENT_MODEL_PROP_DELETE() { return 'E: Int. model prop deleted' }\n\n  /**\n   * A constant key used to identify a comment for a class description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_CLASS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_CLASS() { return 'class' }\n\n  /**\n   * A constant key used to identify a comment for a type field description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_FIELDS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_FIELDS() { return 'fields' }\n\n  /**\n   * A constant key used to identify a comment for the top level query\n   * description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_QUERY\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_QUERY() { return 'query' }\n\n  /**\n   * A constant key used to identify a comment for a query description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_QUERIES\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_QUERIES() { return 'queries' }\n\n  /**\n   * A constant key used to identify a comment for the top level mutation\n   * description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_MUTATION\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_MUTATION() { return 'mutation' }\n\n  /**\n   * A constant key used to identify a comment for a mutator description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_MUTATORS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_MUTATORS() { return 'mutators' }\n\n  /**\n   * A constant key used to identify a comment for the top level subscription\n   * description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_SUBSCRIPTION\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_SUBSCRIPTION() { return 'subscription' }\n\n  /**\n   * A constant key used to identify a comment for a subscription description\n   *\n   * @static\n   * @memberof GQLBase\n   * @method ⬇︎⠀DOC_SUBSCRIPTIONS\n   * @const\n   *\n   * @type {string}\n   */\n  static get DOC_SUBSCRIPTIONS() { return 'subscriptions' }\n\n  /**\n   * A shortcut to the utils/joinLines function to make it easier to get\n   * the tools to write docs for your types in a friendly fashion.\n   *\n   * @memberof GQLBase\n   * @method ⬇︎⠀joinLines\n   * @static\n   * @const\n   *\n   * @type {Function}\n   */\n  static get joinLines(): Function { return joinLines }\n\n  /**\n   * An simple pass-thru method for fetching a types merged root object.\n   *\n   * @method ⌾⠀getMergedRoot\n   * @memberof GQLBase\n   * @static\n   *\n   * @param {Object} requestData an object containing the request data such as\n   * request, response or graphql context info that should be passed along to\n   * each of the resolver creators\n   * @return {Object} the merged root object with all the query, mutation and\n   * subscription resolvers defined and created within.\n   */\n  static async getMergedRoot(\n    requestData: Object,\n    separateByType: boolean = false\n  ): Object {\n    const root = {};\n    const Class = this;\n\n    let _ = {\n      // $FlowFixMe\n      resolvers: Class[META_KEY].resolvers || [],\n      // $FlowFixMe\n      mutators: Class[META_KEY].mutators || [],\n      // $FlowFixMe\n      subscriptors: Class[META_KEY].subscriptors || []\n    }\n\n    let convert = f => {return { [f.name]: f.bind(Class, requestData) }}\n    let reduce = (p, c) => merge(p, c)\n\n    _.resolvers = _.resolvers.map(convert).reduce(reduce, {})\n    _.mutators = _.mutators.map(convert).reduce(reduce, {})\n    _.subscriptors = _.subscriptors.map(convert).reduce(reduce, {})\n\n    if (separateByType) {\n      // Apollo wants all the resolvers to grouped by top level type.\n      // The field resolvers aren't an issue in Lattice defined types\n      // but the root types do need to be sorted; so let's do that here\n      merge(\n        root,\n        { Query: await Class.RESOLVERS(requestData) },\n        { Mutation: await Class.MUTATORS(requestData) },\n        { Query: _.resolvers },\n        { Mutation: _.mutators },\n        { Subscription: _.subscriptors }\n      );\n\n      // When using lattice with apollo server, it is quite particular about\n      // empty Query, Mutation or Subscription resolver maps.\n      if (!Object.keys(root.Query).length) delete root.Query\n      if (!Object.keys(root.Mutation).length) delete root.Mutation\n      if (!Object.keys(root.Subscription).length) delete root.Subscription\n    }\n    else {\n      merge(\n        root,\n        await Class.RESOLVERS(requestData),\n        await Class.MUTATORS(requestData),\n        _.resolvers,\n        _.mutators,\n        _.subscriptors\n      );\n    }\n\n    return root;\n  }\n\n  /**\n   * An object used to store data used by decorators and other internal\n   * proccesses.\n   * @ComputedType\n   */\n  static get [META_KEY]() {\n    let storage = this[Symbol.for(this.name)]\n\n    if (!storage) {\n      storage = (this[Symbol.for(this.name)] = {})\n    }\n\n    return storage;\n  }\n}\n\nexport default GQLBase;\n"]}