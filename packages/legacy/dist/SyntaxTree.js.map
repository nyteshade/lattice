{"version":3,"sources":["../es6/SyntaxTree.js"],"names":["AST_KEY","SyntaxTree","constructor","schemaOrASTOrST","setAST","ast","value","type","st","String","name","ignore","Object","updateAST","newAST","error","appendDefinitions","source","from","set","definitions","map","definition","add","theirs","ours","find","index","indexOf","has","push","kind","interfaces","concat","directives","fields","consumeDefinition","astOrSyntaxTree","definitionType","tree","left","right","Error","splice","outline","out","forEach","field","_interface","values","types","definitionName","findDefinition","toString","QUERY","MUTATION","SUBSCRIPTION","mixed","schema","fromSchema","fromAST","findInASTArrayByNameValue","findField","fieldName","meta","nullable","findEnumDefinition","enumDefinitionName","enumValueName","array","isRegExp","test","regex","RegExp","flags","reducer","last","cur","i","reduce","EmptyQuery","EmptyMutation","EmptyDocument","loc","start","end"],"mappings":"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","file":"SyntaxTree.js","sourceRoot":"es6","sourcesContent":["// @flow\n// @module SyntaxTree\n\nimport { typeOf } from 'ne-types'\nimport { print, parse } from 'graphql'\nimport { merge } from 'lodash'\nimport { LatticeLogs as ll } from './utils'\n\nimport type { GraphQLObjectType } from 'graphql/type/definition'\nimport type {\n  ObjectTypeDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  EnumTypeDefinitionNode,\n  UnionTypeDefinitionNode,\n  FieldDefinitionNode,\n  TypeDefinitionNode,\n  TypeNode\n} from 'graphql/language/ast'\n\n\n// Shorthand for the key storing the internal AST\n// @prop\nconst AST_KEY = Symbol.for('Internal AST Storage Key');\n\n/**\n * A parser and processor of GraphQL IDL Abstract Syntax Trees. Used to combine\n * a set of {@link GQLBase} class instances.\n *\n * @class SyntaxTree\n */\nexport class SyntaxTree\n{\n  /**\n   * Constructs a new `SyntaxTree` object. If a string schema is supplied or\n   * an already parsed AST object, either of which is valid GraphQL IDL, then\n   * its parsed AST will be the internals of this object.\n   *\n   * @constructor\n   * @memberof SyntaxTree\n   * @method ⎆⠀constructor\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST if supplied the tree\n   * will be constructed with the contents of the data. If a string of IDL is\n   * given, it will be parsed. If an AST is given, it will be verified. If a\n   * SyntaxTree is supplied, it will be copied.\n   */\n  constructor(schemaOrASTOrST?: string | Object | SyntaxTree) {\n    // $ComputedType\n    this[AST_KEY] = {};\n\n    if (schemaOrASTOrST) {\n      this.setAST(schemaOrASTOrST);\n    }\n  }\n\n  /**\n   * Getter that retrieves the abstract syntax tree created by `graphql.parse`\n   * when it is presented with a valid string of IDL.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀ast\n   *\n   * @return {Object} a GraphQL AST object\n   */\n  get ast(): Object {\n    // $ComputedType\n    return this[AST_KEY];\n  }\n\n  /**\n   * Setter that assigns the abstract syntax tree, typically created by\n   * `graphql.parse` when given a valid string of IDL.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬆︎⠀ast\n   *\n   * @param {Object} value a valid AST object. Other operations will act\n   * in an undefined manner should this object not be a valid AST\n   */\n  set ast(value: Object): void {\n    // $ComputedType\n    this[AST_KEY] = value;\n  }\n\n  /**\n   * Sets the underlying AST object with either schema which will be parsed\n   * into a valid AST or an existing AST. Previous ast values will be erased.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀setAST\n   *\n   * @param {string|Object} schemaOrAST a valid GraphQL IDL schema or a\n   * previosuly parsed or compatible GraphQL IDL AST object.\n   * @return {SyntaxTree} this for inlining.\n   */\n  setAST(schemaOrASTOrST: string|Object|SyntaxTree): SyntaxTree {\n    // $ComputedType\n    this[AST_KEY] = {};\n\n    const type = typeOf(schemaOrASTOrST);\n    let ast: Object;\n    let st: SyntaxTree;\n\n    switch (type) {\n      case String.name:\n        try {\n          ast = parse((schemaOrASTOrST: any));\n\n          merge(this.ast, ast);\n        }\n        catch (ignore) { /* Ignore this error */ }\n\n        break;\n      case Object.name:\n        ast = (schemaOrASTOrST: any);\n\n        try {\n          ast = parse(print(ast));\n          merge(this.ast, ast);\n        }\n        catch (ignore) { /* Ignore this error */ }\n\n        break;\n      case SyntaxTree.name:\n        st = (schemaOrASTOrST: any);\n\n        merge(this.ast, st.ast);\n\n        break;\n    }\n\n    return this;\n  }\n\n  /**\n   * As passthru update method that works on the internal AST object. If\n   * an error occurs, the update is skipped. An error can occur if adding the\n   * changes would make the AST invalid. In such a case, the error is logged\n   * to the error console.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀updateAST\n   *\n   * @param {Object} ast an existing GraphQL IDL AST object that will be\n   * merged on top of the existing tree using _.merge()\n   * @return {SyntaxTree} this for inlining.\n   */\n  updateAST(ast: Object): SyntaxTree {\n    if (typeOf(ast) === Object.name) {\n      let newAST = merge({}, this.ast, ast);\n\n      try {\n        print(newAST);\n        this.ast = merge(this.ast, ast);\n      }\n      catch (error) {\n        ll.error('[SyntaxTree] Failed to updateAST with %o', ast);\n        ll.error('Resulting object would be %o', newAST);\n        ll.error(error);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Appends all definitions from another AST to this one. The method will\n   * actually create a copy using SyntaxTree.from() so the input types can\n   * be any one of a valid GraphQL IDL schema string, a GraphQL IDL AST or\n   * another SyntaxTree object instance.\n   *\n   * Definitions of the same name but different kinds will be replaced by the\n   * new copy. Those of the same kind and name will be merged (TODO handle more\n   * than ObjectTypeDefinition kinds when merging; currently other types are\n   * overwritten).\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀appendDefinitions\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST an instance of one of\n   * the valid types for SyntaxTree.from() that can be used to create or\n   * duplicate the source from which to copy definitions.\n   * @return {SyntaxTree} this for inlining\n   */\n  appendDefinitions(schemaOrASTOrST: string | Object | SyntaxTree): SyntaxTree {\n    const source = SyntaxTree.from(schemaOrASTOrST);\n    const set = new Set();\n\n    this.ast.definitions.map((definition) => {\n      set.add(definition.name.value);\n    })\n\n    if (source && source.ast.definitions && this.ast.definitions) {\n      for (let theirs of (source: any)) {\n        let name = theirs.name.value;\n        let ours = this.find(name);\n        let index = ours && this.ast.definitions.indexOf(ours) || -1;\n\n        // We don't yet have one with that name\n        if (!set.has(name)) {\n          set.add(name);\n          this.ast.definitions.push(theirs);\n        }\n\n        // We do have one with that name\n        else {\n          // The kinds aren't the same, just replace theirs with ours\n          if (theirs.kind !== ours.kind) {\n            // replace with the new one\n            this.ast.definitions[index] = theirs;\n          }\n\n          // The kinds are the same, lets just merge their fields\n          else {\n            // merge the properties of the same types.\n            switch (theirs.kind) {\n              case 'ObjectTypeDefinition':\n                ours.interfaces = [].concat(ours.interfaces, theirs.interfaces)\n                ours.directives = [].concat(ours.directives, theirs.directives)\n                ours.fields = [].concat(ours.fields, theirs.fields)\n                break;\n              default:\n                // Since we don't support other types yet. Let's replace\n                this.ast.definitions[index] = theirs;\n                break;\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * This method finds the Query type definitions in the supplied AST or\n   * SyntaxTree objects, takes its defined fields and adds it to the current\n   * instances. If this instance does not have a Query type defined but the\n   * supplied object does, then the supplied one is moved over. If neither\n   * has a query handler, then nothing happens.\n   *\n   * NOTE this *removes* the Query type definition from the supplied AST or\n   * SyntaxTree object.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀consumeDefinition\n   *\n   * @param {Object|SyntaxTree} astOrSyntaxTree a valid GraphQL IDL AST or\n   * an instance of SyntaxTree that represents one.\n   * @param {string|RegExp} definitionType a valid search input as would be\n   * accepted for the #find() method of this object.\n   * @return {SyntaxTree} returns this for inlining\n   */\n  consumeDefinition(\n    astOrSyntaxTree: Object | SyntaxTree,\n    definitionType: string | RegExp = \"Query\"\n  ): SyntaxTree {\n    if (!astOrSyntaxTree || !this.ast || !this.ast.definitions) { return this }\n\n    const tree = typeOf(SyntaxTree) === SyntaxTree.name\n      ? astOrSyntaxTree\n      : SyntaxTree.from(astOrSyntaxTree);\n    let left = this.find(definitionType);\n    let right = tree && tree.find(definitionType) || null;\n\n    if (!tree) {\n      ll.error('There seems to be something wrong with your tree')\n      ll.error(new Error('Missing tree; continuing...'));\n      return this;\n    }\n\n    if (!right) { return this }\n\n    if (!left) {\n      this.ast.definitions.push(right);\n\n      // Remove the copied definition from the source\n      tree.ast.definitions.splice(tree.ast.definitions.indexOf(right), 1);\n\n      return this;\n    }\n\n    // TODO support other types aside from ObjectTypeDefinitions\n    // TODO see if there is a better way to achieve this with built-in\n    // graphql code someplace\n    switch(left.kind) {\n      case 'ObjectTypeDefinition':\n        if (left.interfaces && right.interfaces) {\n          left.interfaces = [].concat(left.interfaces, right.interfaces);\n        }\n\n        if (left.directives && right.directives) {\n          left.directives = [].concat(left.directives, right.directives);\n        }\n\n        if (left.fields && right.fields) {\n          left.fields = [].concat(left.fields, right.fields);\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    // Remove the copied definition from the source\n    tree.ast.definitions.splice(tree.ast.definitions.indexOf(right), 1);\n\n    return this;\n  }\n\n  /**\n   * When iterating over an instance of SyntaxTree, you are actually\n   * iterating over the definitions of the SyntaxTree if there are any;\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method *[Symbol.iterator]\n   *\n   * @return {TypeDefinitionNode} an instance of a TypeDefinitionNode; see\n   * graphql/language/ast.js.flow for more information\n   * @ComputedType\n   */\n  *[Symbol.iterator](): TypeDefinitionNode {\n    if (this[AST_KEY].definitions) {\n      return yield* this[AST_KEY].definitions;\n    }\n    else {\n      return yield* this;\n    }\n  }\n\n  /**\n   * Getter that builds a small outline object denoting the schema being\n   * processed. If you have a schema that looks like the following:\n   *\n   * ```javascript\n   * let st = SyntaxTree.from(`\n   *   type Contrived {\n   *     name: String\n   *     age: Int\n   *   }\n   *\n   *   type Query {\n   *     getContrived: Contrived\n   *   }\n   * `)\n   * let outline = st.outline\n   * ```\n   *\n   * You will end up with an object that looks like the following:\n   *\n   * ```javascript\n   * {\n   *   Contrived: { name: 'String', age: 'Int' },\n   *   Query: { getContrived: 'Contrived' }\n   * }\n   * ```\n   *\n   * As may be evidenced by the example above, the name of the type is\n   * represented by an object where the name of each field (sans arguments)\n   * is mapped to a string denoting the type.\n   */\n  get outline(): Object {\n    let outline = {}\n    let interfaces = Symbol.for('interfaces')\n\n    // $FlowFixMe\n    for (let definition of this) {\n      let out\n\n      switch (definition.kind) {\n        case 'InterfaceTypeDefinition':\n        case 'ObjectTypeDefinition':\n          out = outline[definition.name.value] = {}\n          definition.fields.forEach(\n            field => {\n              if (field.type.kind === 'NamedType')\n                out[field.name.value] = field.type.name.value\n              else if (field.type.kind === 'ListType')\n                out[field.name.value] = field.type.type.name.value\n            }\n          )\n\n          if (definition.interfaces) {\n            // $FlowFixMe\n            out = (out[interfaces] = out[interfaces] || [])\n\n            definition.interfaces.forEach(\n              _interface => out.push(_interface.name.value)\n            )\n          }\n\n          break;\n\n        case 'EnumTypeDefinition':\n          out = outline[definition.name.value] = []\n          definition.values.forEach(\n            value => out[value.name.value] = value.name.value\n          )\n          break;\n\n        case 'UnionTypeDefinition':\n          out = outline[definition.name.value] = []\n          definition.types.forEach(\n            type => out.push(type.name.value)\n          )\n          break;\n      }\n    }\n\n    return outline\n  }\n\n  /**\n   * Iterate through the definitions of the AST if there are any. For each\n   * definition the name property's value field is compared to the supplied\n   * definitionName. The definitionName can be a string or a regular\n   * expression if finer granularity is desired.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀find\n   *\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @return {Object|null} a reference to the internal definition field or\n   * null if one with a matching name could not be found.\n   */\n  find(definitionName: string|RegExp): Object | null {\n    // $ComputedType\n    return SyntaxTree.findDefinition(this[AST_KEY], definitionName);\n  }\n\n  /**\n   * SyntaxTree instances that are toString()'ed will have the graphql method\n   * print() called on them to convert their internal structures back to a\n   * GraphQL IDL schema syntax. If the object is in an invalid state, it WILL\n   * throw an error.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀toString\n   *\n   * @return {string} the AST for the tree parsed back into a string\n   */\n  toString(): string {\n    // $ComputedType\n    return print(this[AST_KEY]);\n  }\n\n  /**\n   * A runtime constant denoting a query type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀QUERY\n   * @readonly\n   * @const\n   */\n  static get QUERY(): string { return 'Query' }\n\n  /**\n   * A runtime constant denoting a mutation type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀MUTATION\n   * @readonly\n   * @const\n   */\n  static get MUTATION(): string { return 'Mutation' }\n\n    /**\n   * A runtime constant denoting a subscription type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method SUBSCRIPTION\n   * @readonly\n   * @const\n   */\n  static get SUBSCRIPTION(): string { return 'Subscription' }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof SyntaxTree\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof SyntaxTree\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Given one of, a valid GraphQL IDL schema string, a valid GraphQL AST or\n   * an instance of SyntaxTree, the static from() method will create a new\n   * instance of the SyntaxTree with the values you provide.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀from\n   *\n   * @param {String|Object|SyntaxTree} mixed an instance of one of the valid\n   * types specified above. Everything else will result in a null value.\n   * @return {SyntaxTree} a newly created and populated instance of SyntaxTree\n   * or null if an invalid type was supplied for mixed.\n   */\n  static from(mixed: string | Object | SyntaxTree): SyntaxTree | null {\n    let schema: string;\n    let ast: Object;\n\n    switch (typeOf(mixed)) {\n      case String.name:\n        schema = (mixed: any);\n        try { parse(schema) } catch(error) { ll.error(error); return null; }\n\n        return SyntaxTree.fromSchema(String(schema));\n      case Object.name:\n        ast = (mixed: any);\n        try { print(ast) } catch(error) { return null; }\n\n        return SyntaxTree.fromAST(ast);\n      case SyntaxTree.name:\n        schema = mixed.toString();\n\n        return SyntaxTree.from(schema);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Generates a new instance of SyntaxTree from the supplied, valid, GraphQL\n   * schema. This method does not perform try/catch validation and if an\n   * invalid GraphQL schema is supplied an error will be thrown.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀fromSchema\n   *\n   * @param {string} schema a valid GraphQL IDL schema string.\n   * @return {SyntaxTree} a new instance of SyntaxTree initialized with a\n   * parsed response from require('graphql').parse().\n   */\n  static fromSchema(schema: string): SyntaxTree {\n    const ast = parse(schema);\n    let tree = new SyntaxTree(ast);\n\n    return tree;\n  }\n\n  /**\n   * Generates a new instance of SyntaxTree from the supplied, valid, GraphQL\n   * schema. This method does not perform try/catch validation and if an\n   * invalid GraphQL schema is supplied an error will be thrown.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀fromAST\n   *\n   * @param {object} ast a valid GraphQL AST object.\n   * @return {SyntaxTree} a new instance of SyntaxTree initialized with a\n   * supplied abstract syntax tree generated by require('graphql').parse() or\n   * other compatible method.\n   */\n  static fromAST(ast: Object): SyntaxTree | null {\n    const source = parse(print(ast));\n    let tree = new SyntaxTree(source);\n\n    return source ? tree : null;\n  }\n\n  /**\n   * Iterate through the definitions of the AST if there are any. For each\n   * definition the name property's value field is compared to the supplied\n   * definitionName. The definitionName can be a string or a regular\n   * expression if finer granularity is desired.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findDefinition\n   *\n   * @param {Object} ast an abstract syntax tree object created from a GQL SDL\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @return {Object|null} a reference to the internal definition field or\n   * null if one with a matching name could not be found.\n   */\n  static findDefinition(ast: Object, definitionName: string | RegExp) {\n    return this.findInASTArrayByNameValue(\n      ast.definitions,\n      definitionName\n    );\n  }\n\n  /**\n   * Iterate through the fields of a definition AST if there are any. For each\n   * field, the name property's value field is compared to the supplied\n   * fieldName. The fieldName can be a string or a regular expression if\n   * finer granularity is desired.\n   *\n   * Before iterating over the fields, however, the definition is found using\n   * `SyntaxTree#findDefinition`. If either the field or definition are not\n   * found, null is returned.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findField\n   * @since 2.7.0\n   *\n   * @param {Object} ast an abstract syntax tree object created from a GQL SDL\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @param {string|RegExp} fieldName a string or regular expression used\n   * to match against the field name field in a given AST.\n   * @return {Object|null} an object containing two keys, the first being\n   * `field` which points to the requested AST definition field. The second\n   * being `meta` which contains three commonly requested bits of data; `name`,\n   * `type` and `nullable`. Non-nullable fields have their actual type wrapped\n   * in a `NonNullType` GraphQL construct. The actual field type is contained\n   * within. The meta object surfaces those values for easy use.\n   */\n  static findField(\n    ast: Object,\n    definitionName: string | RegExp,\n    fieldName: string | RegExp\n  ) {\n    const definition = this.findDefinition(ast, definitionName)\n    let meta;\n\n    if (!definition || !definition.fields) {\n      return null;\n    }\n\n    const field = this.findInASTArrayByNameValue(definition.fields, fieldName)\n\n    if (field) {\n      meta = {\n        name: field.name && field.name.value || null,\n        type: field.type && field.type.kind === 'NonNullType'\n          ? field.type.type.name.value\n          : field.type && field.type.name && field.type.name.value || null,\n        nullable: !!(field.type && field.type.kind !== 'NonNullType')\n      }\n    }\n\n    return { field, meta };\n  }\n\n  /**\n   * Enum AST definitions operate differently than object type definitions\n   * do. Namely, they do not have a `fields` array but instead have a `values`\n   * array. This wrapper method, first finds the enum definition in the ast\n   * and then searches the values for the named node desired and returns that\n   * or null, if one could not be found.\n   *\n   * @method SyntaxTree#⌾⠀findEnumDefinition\n   * @since 2.7.0\n   *\n   * @param {Object} ast the abstract syntax tree parsed by graphql\n   * @param {string|RegExp} enumDefinitionName a string or regular expression\n   * used to locate the enum definition in the AST.\n   * @param {string|RegExp} enumValueName a string or regular expression used\n   * to locate the value by name in the values of the enum definition.\n   * @return {Object|null} the desired AST node or null if one does not exist\n   */\n  static findEnumDefinition(\n    ast: Object,\n    enumDefinitionName: string | RegExp,\n    enumValueName: string | RegExp\n  ): ?Object {\n    // Fetch the enum definition\n    const definition = this.findDefinition(ast, enumDefinitionName);\n\n    // Ensure we have one or that it has a values array\n    if (!definition || !definition.values) {\n      return null;\n    }\n\n    // Return the results of an `findInASTArrayByNameValue()` search of the\n    // aforementioned 'values' array.\n    return this.findInASTArrayByNameValue(\n      definition.values,\n      enumValueName\n    )\n  }\n\n  /**\n   * A lot of searching in ASTs is filtering through arrays and matching on\n   * subobject properties on each iteration. A common theme is find something\n   * by its `.name.value`. This method simplifies that by taking an array of\n   * AST nodes and searching them for a `.name.value` property that exists\n   * within.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findInASTArrayByNameValue\n   * @since 2.7.0\n   *\n   * @param {Array} array of mixed AST object nodes containing `name.value`s\n   * @param {string|RegExp} name a string or regular expression used\n   * to match against the node name value\n   * @return {Object|null} the AST leaf if one matches or null otherwise.\n   */\n  static findInASTArrayByNameValue(\n    array: Array<Object>,\n    name: string | RegExp\n  ): ?Object {\n    const isRegExp: boolean = /RegExp/.test(typeOf(name));\n    const regex = !isRegExp\n      // $FlowFixMe\n      ? new RegExp(RegExp.escape(name.toString()))\n      // $FlowFixMe\n      : (name: RegExp);\n    const flags = regex.flags\n    const source = regex.source\n    const reducer = (last,cur,i) => {\n      if (last !== -1) return last;\n      if (!cur || !cur.name || !cur.name.value) return -1;\n      return new RegExp(source, flags).test(cur.name.value) ? i : -1\n    }\n    const index = array.reduce(reducer, -1);\n\n    return (~index) ? array[index] : null;\n  }\n\n  /**\n   * Query types in GraphQL are an ObjectTypeDefinition of importance for\n   * placement on the root object. There is utility in creating an empty\n   * one that can be injected with the fields of other GraphQL object query\n   * entries.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyQuery\n   *\n   * @return {SyntaxTree} an instance of SyntaxTree with a base AST generated\n   * by parsing the graph query, \"type Query {}\"\n   */\n  static EmptyQuery(): ?SyntaxTree {\n    return SyntaxTree.from(`type ${this.QUERY} {}`);\n  }\n\n  /**\n   * Mutation types in GraphQL are an ObjectTypeDefinition of importance for\n   * placement on the root object. There is utility in creating an empty\n   * one that can be injected with the fields of other GraphQL object mutation\n   * entries.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyMutation\n   *\n   * @return {SyntaxTree} an instance of SyntaxTree with a base AST generated\n   * by parsing the graph query, \"type Mutation {}\"\n   */\n  static EmptyMutation(): ?SyntaxTree {\n    return SyntaxTree.from(`type ${this.MUTATION} {}`);\n  }\n\n  /**\n   * The starting point for a SyntaxTree that will be built up programmatically.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyDocument\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST any valid type taken by\n   * SyntaxTree.from() used to further populate the new empty document\n   * @return {SyntaxTree} an instance of SyntaxTree with no definitions and a\n   * kind set to 'Document'\n   */\n  static EmptyDocument(\n    schemaOrASTOrST?: string | Object | SyntaxTree\n  ): SyntaxTree {\n    let tree = new SyntaxTree();\n\n    // Due to normal validation methods with ASTs (i.e. converting to string\n    // and then back to an AST object), doing this with an empty document\n    // fails. Therefore, we manually set the document contents here. This allows\n    // toString(), consumeDefinition() and similar methods to still work.\n    tree.ast = {\n      kind: 'Document',\n      definitions: [],\n      loc: {start: 0, end: 0}\n    };\n\n    if (schemaOrASTOrST) {\n      tree.appendDefinitions(schemaOrASTOrST);\n    }\n\n    return tree;\n  }\n}\n\nexport default SyntaxTree;\n"]}