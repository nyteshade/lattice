{"version":3,"sources":["../es6/SyntaxTree.js"],"names":["AST_KEY","SyntaxTree","schemaOrASTOrST","setAST","type","ast","st","String","name","ignore","Object","newAST","error","source","from","set","definitions","map","definition","add","value","theirs","ours","find","index","indexOf","has","push","kind","interfaces","concat","directives","fields","astOrSyntaxTree","definitionType","tree","left","right","Error","splice","definitionName","findDefinition","outline","out","forEach","field","_interface","values","types","constructor","mixed","schema","fromSchema","fromAST","toString","findInASTArrayByNameValue","fieldName","meta","nullable","enumDefinitionName","enumValueName","array","isRegExp","test","regex","RegExp","flags","reducer","last","cur","i","reduce","QUERY","MUTATION","loc","start","end","appendDefinitions"],"mappings":"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","file":"SyntaxTree.js","sourceRoot":"es6","sourcesContent":["// @flow\n// @module SyntaxTree\n\nimport { typeOf } from './types'\nimport { print, parse } from 'graphql'\nimport { merge } from 'lodash'\nimport { LatticeLogs as ll } from './utils'\n\nimport type { GraphQLObjectType } from 'graphql/type/definition'\nimport type {\n  ObjectTypeDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  EnumTypeDefinitionNode,\n  UnionTypeDefinitionNode,\n  FieldDefinitionNode,\n  TypeDefinitionNode,\n  TypeNode\n} from 'graphql/language/ast'\n\n\n// Shorthand for the key storing the internal AST\n// @prop\nconst AST_KEY = Symbol.for('Internal AST Storage Key');\n\n/**\n * A parser and processor of GraphQL IDL Abstract Syntax Trees. Used to combine\n * a set of {@link GQLBase} class instances.\n *\n * @class SyntaxTree\n */\nexport class SyntaxTree\n{\n  /**\n   * Constructs a new `SyntaxTree` object. If a string schema is supplied or\n   * an already parsed AST object, either of which is valid GraphQL IDL, then\n   * its parsed AST will be the internals of this object.\n   *\n   * @constructor\n   * @memberof SyntaxTree\n   * @method ⎆⠀constructor\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST if supplied the tree\n   * will be constructed with the contents of the data. If a string of IDL is\n   * given, it will be parsed. If an AST is given, it will be verified. If a\n   * SyntaxTree is supplied, it will be copied.\n   */\n  constructor(schemaOrASTOrST?: string | Object | SyntaxTree) {\n    // $ComputedType\n    this[AST_KEY] = {};\n\n    if (schemaOrASTOrST) {\n      this.setAST(schemaOrASTOrST);\n    }\n  }\n\n  /**\n   * Getter that retrieves the abstract syntax tree created by `graphql.parse`\n   * when it is presented with a valid string of IDL.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀ast\n   *\n   * @return {Object} a GraphQL AST object\n   */\n  get ast(): Object {\n    // $ComputedType\n    return this[AST_KEY];\n  }\n\n  /**\n   * Setter that assigns the abstract syntax tree, typically created by\n   * `graphql.parse` when given a valid string of IDL.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⬆︎⠀ast\n   *\n   * @param {Object} value a valid AST object. Other operations will act\n   * in an undefined manner should this object not be a valid AST\n   */\n  set ast(value: Object): void {\n    // $ComputedType\n    this[AST_KEY] = value;\n  }\n\n  /**\n   * Sets the underlying AST object with either schema which will be parsed\n   * into a valid AST or an existing AST. Previous ast values will be erased.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀setAST\n   *\n   * @param {string|Object} schemaOrAST a valid GraphQL IDL schema or a\n   * previosuly parsed or compatible GraphQL IDL AST object.\n   * @return {SyntaxTree} this for inlining.\n   */\n  setAST(schemaOrASTOrST: string|Object|SyntaxTree): SyntaxTree {\n    // $ComputedType\n    this[AST_KEY] = {};\n\n    const type = typeOf(schemaOrASTOrST);\n    let ast: Object;\n    let st: SyntaxTree;\n\n    switch (type) {\n      case String.name:\n        try {\n          ast = parse((schemaOrASTOrST: any));\n\n          merge(this.ast, ast);\n        }\n        catch (ignore) { /* Ignore this error */ }\n\n        break;\n      case Object.name:\n        ast = (schemaOrASTOrST: any);\n\n        try {\n          ast = parse(print(ast));\n          merge(this.ast, ast);\n        }\n        catch (ignore) { /* Ignore this error */ }\n\n        break;\n      case SyntaxTree.name:\n        st = (schemaOrASTOrST: any);\n\n        merge(this.ast, st.ast);\n\n        break;\n    }\n\n    return this;\n  }\n\n  /**\n   * As passthru update method that works on the internal AST object. If\n   * an error occurs, the update is skipped. An error can occur if adding the\n   * changes would make the AST invalid. In such a case, the error is logged\n   * to the error console.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀updateAST\n   *\n   * @param {Object} ast an existing GraphQL IDL AST object that will be\n   * merged on top of the existing tree using _.merge()\n   * @return {SyntaxTree} this for inlining.\n   */\n  updateAST(ast: Object): SyntaxTree {\n    if (typeOf(ast) === Object.name) {\n      let newAST = merge({}, this.ast, ast);\n\n      try {\n        print(newAST);\n        this.ast = merge(this.ast, ast);\n      }\n      catch (error) {\n        ll.error('[SyntaxTree] Failed to updateAST with %o', ast);\n        ll.error('Resulting object would be %o', newAST);\n        ll.error(error);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Appends all definitions from another AST to this one. The method will\n   * actually create a copy using SyntaxTree.from() so the input types can\n   * be any one of a valid GraphQL IDL schema string, a GraphQL IDL AST or\n   * another SyntaxTree object instance.\n   *\n   * Definitions of the same name but different kinds will be replaced by the\n   * new copy. Those of the same kind and name will be merged (TODO handle more\n   * than ObjectTypeDefinition kinds when merging; currently other types are\n   * overwritten).\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀appendDefinitions\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST an instance of one of\n   * the valid types for SyntaxTree.from() that can be used to create or\n   * duplicate the source from which to copy definitions.\n   * @return {SyntaxTree} this for inlining\n   */\n  appendDefinitions(schemaOrASTOrST: string | Object | SyntaxTree): SyntaxTree {\n    const source = SyntaxTree.from(schemaOrASTOrST);\n    const set = new Set();\n\n    this.ast.definitions.map((definition) => {\n      set.add(definition.name.value);\n    })\n\n    if (source && source.ast.definitions && this.ast.definitions) {\n      for (let theirs of (source: any)) {\n        let name = theirs.name.value;\n        let ours = this.find(name);\n        let index = ours && this.ast.definitions.indexOf(ours) || -1;\n\n        // We don't yet have one with that name\n        if (!set.has(name)) {\n          set.add(name);\n          this.ast.definitions.push(theirs);\n        }\n\n        // We do have one with that name\n        else {\n          // The kinds aren't the same, just replace theirs with ours\n          if (theirs.kind !== ours.kind) {\n            // replace with the new one\n            this.ast.definitions[index] = theirs;\n          }\n\n          // The kinds are the same, lets just merge their fields\n          else {\n            // merge the properties of the same types.\n            switch (theirs.kind) {\n              case 'ObjectTypeDefinition':\n                ours.interfaces = [].concat(ours.interfaces, theirs.interfaces)\n                ours.directives = [].concat(ours.directives, theirs.directives)\n                ours.fields = [].concat(ours.fields, theirs.fields)\n                break;\n              default:\n                // Since we don't support other types yet. Let's replace\n                this.ast.definitions[index] = theirs;\n                break;\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * This method finds the Query type definitions in the supplied AST or\n   * SyntaxTree objects, takes its defined fields and adds it to the current\n   * instances. If this instance does not have a Query type defined but the\n   * supplied object does, then the supplied one is moved over. If neither\n   * has a query handler, then nothing happens.\n   *\n   * NOTE this *removes* the Query type definition from the supplied AST or\n   * SyntaxTree object.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀consumeDefinition\n   *\n   * @param {Object|SyntaxTree} astOrSyntaxTree a valid GraphQL IDL AST or\n   * an instance of SyntaxTree that represents one.\n   * @param {string|RegExp} definitionType a valid search input as would be\n   * accepted for the #find() method of this object.\n   * @return {SyntaxTree} returns this for inlining\n   */\n  consumeDefinition(\n    astOrSyntaxTree: Object | SyntaxTree,\n    definitionType: string | RegExp = \"Query\"\n  ): SyntaxTree {\n    if (!astOrSyntaxTree || !this.ast || !this.ast.definitions) { return this }\n\n    const tree = typeOf(SyntaxTree) === SyntaxTree.name\n      ? astOrSyntaxTree\n      : SyntaxTree.from(astOrSyntaxTree);\n    let left = this.find(definitionType);\n    let right = tree && tree.find(definitionType) || null;\n\n    if (!tree) {\n      ll.error('There seems to be something wrong with your tree')\n      ll.error(new Error('Missing tree; continuing...'));\n      return this;\n    }\n\n    if (!right) { return this }\n\n    if (!left) {\n      this.ast.definitions.push(right);\n\n      // Remove the copied definition from the source\n      tree.ast.definitions.splice(tree.ast.definitions.indexOf(right), 1);\n\n      return this;\n    }\n\n    // TODO support other types aside from ObjectTypeDefinitions\n    // TODO see if there is a better way to achieve this with built-in\n    // graphql code someplace\n    switch(left.kind) {\n      case 'ObjectTypeDefinition':\n        if (left.interfaces && right.interfaces) {\n          left.interfaces = [].concat(left.interfaces, right.interfaces);\n        }\n\n        if (left.directives && right.directives) {\n          left.directives = [].concat(left.directives, right.directives);\n        }\n\n        if (left.fields && right.fields) {\n          left.fields = [].concat(left.fields, right.fields);\n        }\n\n        break;\n      default:\n        break;\n    }\n\n    // Remove the copied definition from the source\n    tree.ast.definitions.splice(tree.ast.definitions.indexOf(right), 1);\n\n    return this;\n  }\n\n  /**\n   * When iterating over an instance of SyntaxTree, you are actually\n   * iterating over the definitions of the SyntaxTree if there are any;\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method *[Symbol.iterator]\n   *\n   * @return {TypeDefinitionNode} an instance of a TypeDefinitionNode; see\n   * graphql/language/ast.js.flow for more information\n   * @ComputedType\n   */\n  *[Symbol.iterator](): TypeDefinitionNode {\n    if (this[AST_KEY].definitions) {\n      return yield* this[AST_KEY].definitions;\n    }\n    else {\n      return yield* this;\n    }\n  }\n\n  /**\n   * Getter that builds a small outline object denoting the schema being\n   * processed. If you have a schema that looks like the following:\n   *\n   * ```javascript\n   * let st = SyntaxTree.from(`\n   *   type Contrived {\n   *     name: String\n   *     age: Int\n   *   }\n   *\n   *   type Query {\n   *     getContrived: Contrived\n   *   }\n   * `)\n   * let outline = st.outline\n   * ```\n   *\n   * You will end up with an object that looks like the following:\n   *\n   * ```javascript\n   * {\n   *   Contrived: { name: 'String', age: 'Int' },\n   *   Query: { getContrived: 'Contrived' }\n   * }\n   * ```\n   *\n   * As may be evidenced by the example above, the name of the type is\n   * represented by an object where the name of each field (sans arguments)\n   * is mapped to a string denoting the type.\n   */\n  get outline(): Object {\n    let outline = {}\n    let interfaces = Symbol.for('interfaces')\n\n    // $FlowFixMe\n    for (let definition of this) {\n      let out\n\n      switch (definition.kind) {\n        case 'InterfaceTypeDefinition':\n        case 'ObjectTypeDefinition':\n          out = outline[definition.name.value] = {}\n          definition.fields.forEach(\n            field => {\n              if (field.type.kind === 'NamedType')\n                out[field.name.value] = field.type.name.value\n              else if (field.type.kind === 'ListType')\n                out[field.name.value] = field.type.type.name.value\n            }\n          )\n\n          if (definition.interfaces) {\n            // $FlowFixMe\n            out = (out[interfaces] = out[interfaces] || [])\n\n            definition.interfaces.forEach(\n              _interface => out.push(_interface.name.value)\n            )\n          }\n\n          break;\n\n        case 'EnumTypeDefinition':\n          out = outline[definition.name.value] = []\n          definition.values.forEach(\n            value => out[value.name.value] = value.name.value\n          )\n          break;\n\n        case 'UnionTypeDefinition':\n          out = outline[definition.name.value] = []\n          definition.types.forEach(\n            type => out.push(type.name.value)\n          )\n          break;\n      }\n    }\n\n    return outline\n  }\n\n  /**\n   * Iterate through the definitions of the AST if there are any. For each\n   * definition the name property's value field is compared to the supplied\n   * definitionName. The definitionName can be a string or a regular\n   * expression if finer granularity is desired.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀find\n   *\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @return {Object|null} a reference to the internal definition field or\n   * null if one with a matching name could not be found.\n   */\n  find(definitionName: string|RegExp): Object | null {\n    // $ComputedType\n    return SyntaxTree.findDefinition(this[AST_KEY], definitionName);\n  }\n\n  /**\n   * SyntaxTree instances that are toString()'ed will have the graphql method\n   * print() called on them to convert their internal structures back to a\n   * GraphQL IDL schema syntax. If the object is in an invalid state, it WILL\n   * throw an error.\n   *\n   * @instance\n   * @memberof SyntaxTree\n   * @method ⌾⠀toString\n   *\n   * @return {string} the AST for the tree parsed back into a string\n   */\n  toString(): string {\n    // $ComputedType\n    return print(this[AST_KEY]);\n  }\n\n  /**\n   * A runtime constant denoting a query type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀QUERY\n   * @readonly\n   * @const\n   */\n  static get QUERY(): string { return 'Query' }\n\n  /**\n   * A runtime constant denoting a mutation type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method ⬇︎⠀MUTATION\n   * @readonly\n   * @const\n   */\n  static get MUTATION(): string { return 'Mutation' }\n\n    /**\n   * A runtime constant denoting a subscription type.\n   *\n   * @type {string}\n   * @static\n   * @memberof SyntaxTree\n   * @method SUBSCRIPTION\n   * @readonly\n   * @const\n   */\n  static get SUBSCRIPTION(): string { return 'Subscription' }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof SyntaxTree\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof SyntaxTree\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Given one of, a valid GraphQL IDL schema string, a valid GraphQL AST or\n   * an instance of SyntaxTree, the static from() method will create a new\n   * instance of the SyntaxTree with the values you provide.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀from\n   *\n   * @param {String|Object|SyntaxTree} mixed an instance of one of the valid\n   * types specified above. Everything else will result in a null value.\n   * @return {SyntaxTree} a newly created and populated instance of SyntaxTree\n   * or null if an invalid type was supplied for mixed.\n   */\n  static from(mixed: string | Object | SyntaxTree): SyntaxTree | null {\n    let schema: string;\n    let ast: Object;\n\n    switch (typeOf(mixed)) {\n      case String.name:\n        schema = (mixed: any);\n        try { parse(schema) } catch(error) { ll.error(error); return null; }\n\n        return SyntaxTree.fromSchema(String(schema));\n      case Object.name:\n        ast = (mixed: any);\n        try { print(ast) } catch(error) { return null; }\n\n        return SyntaxTree.fromAST(ast);\n      case SyntaxTree.name:\n        schema = mixed.toString();\n\n        return SyntaxTree.from(schema);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Generates a new instance of SyntaxTree from the supplied, valid, GraphQL\n   * schema. This method does not perform try/catch validation and if an\n   * invalid GraphQL schema is supplied an error will be thrown.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀fromSchema\n   *\n   * @param {string} schema a valid GraphQL IDL schema string.\n   * @return {SyntaxTree} a new instance of SyntaxTree initialized with a\n   * parsed response from require('graphql').parse().\n   */\n  static fromSchema(schema: string): SyntaxTree {\n    const ast = parse(schema);\n    let tree = new SyntaxTree(ast);\n\n    return tree;\n  }\n\n  /**\n   * Generates a new instance of SyntaxTree from the supplied, valid, GraphQL\n   * schema. This method does not perform try/catch validation and if an\n   * invalid GraphQL schema is supplied an error will be thrown.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀fromAST\n   *\n   * @param {object} ast a valid GraphQL AST object.\n   * @return {SyntaxTree} a new instance of SyntaxTree initialized with a\n   * supplied abstract syntax tree generated by require('graphql').parse() or\n   * other compatible method.\n   */\n  static fromAST(ast: Object): SyntaxTree | null {\n    const source = parse(print(ast));\n    let tree = new SyntaxTree(source);\n\n    return source ? tree : null;\n  }\n\n  /**\n   * Iterate through the definitions of the AST if there are any. For each\n   * definition the name property's value field is compared to the supplied\n   * definitionName. The definitionName can be a string or a regular\n   * expression if finer granularity is desired.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findDefinition\n   *\n   * @param {Object} ast an abstract syntax tree object created from a GQL SDL\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @return {Object|null} a reference to the internal definition field or\n   * null if one with a matching name could not be found.\n   */\n  static findDefinition(ast: Object, definitionName: string | RegExp) {\n    return this.findInASTArrayByNameValue(\n      ast.definitions,\n      definitionName\n    );\n  }\n\n  /**\n   * Iterate through the fields of a definition AST if there are any. For each\n   * field, the name property's value field is compared to the supplied\n   * fieldName. The fieldName can be a string or a regular expression if\n   * finer granularity is desired.\n   *\n   * Before iterating over the fields, however, the definition is found using\n   * `SyntaxTree#findDefinition`. If either the field or definition are not\n   * found, null is returned.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findField\n   * @since 2.7.0\n   *\n   * @param {Object} ast an abstract syntax tree object created from a GQL SDL\n   * @param {string|RegExp} definitionName a string or regular expression used\n   * to match against the definition name field in a given AST.\n   * @param {string|RegExp} fieldName a string or regular expression used\n   * to match against the field name field in a given AST.\n   * @return {Object|null} an object containing two keys, the first being\n   * `field` which points to the requested AST definition field. The second\n   * being `meta` which contains three commonly requested bits of data; `name`,\n   * `type` and `nullable`. Non-nullable fields have their actual type wrapped\n   * in a `NonNullType` GraphQL construct. The actual field type is contained\n   * within. The meta object surfaces those values for easy use.\n   */\n  static findField(\n    ast: Object,\n    definitionName: string | RegExp,\n    fieldName: string | RegExp\n  ) {\n    const definition = this.findDefinition(ast, definitionName)\n    let meta;\n\n    if (!definition || !definition.fields) {\n      return null;\n    }\n\n    const field = this.findInASTArrayByNameValue(definition.fields, fieldName)\n\n    if (field) {\n      meta = {\n        name: field.name && field.name.value || null,\n        type: field.type && field.type.kind === 'NonNullType'\n          ? field.type.type.name.value\n          : field.type && field.type.name && field.type.name.value || null,\n        nullable: !!(field.type && field.type.kind !== 'NonNullType')\n      }\n    }\n\n    return { field, meta };\n  }\n\n  /**\n   * Enum AST definitions operate differently than object type definitions\n   * do. Namely, they do not have a `fields` array but instead have a `values`\n   * array. This wrapper method, first finds the enum definition in the ast\n   * and then searches the values for the named node desired and returns that\n   * or null, if one could not be found.\n   *\n   * @method SyntaxTree#⌾⠀findEnumDefinition\n   * @since 2.7.0\n   *\n   * @param {Object} ast the abstract syntax tree parsed by graphql\n   * @param {string|RegExp} enumDefinitionName a string or regular expression\n   * used to locate the enum definition in the AST.\n   * @param {string|RegExp} enumValueName a string or regular expression used\n   * to locate the value by name in the values of the enum definition.\n   * @return {Object|null} the desired AST node or null if one does not exist\n   */\n  static findEnumDefinition(\n    ast: Object,\n    enumDefinitionName: string | RegExp,\n    enumValueName: string | RegExp\n  ): ?Object {\n    // Fetch the enum definition\n    const definition = this.findDefinition(ast, enumDefinitionName);\n\n    // Ensure we have one or that it has a values array\n    if (!definition || !definition.values) {\n      return null;\n    }\n\n    // Return the results of an `findInASTArrayByNameValue()` search of the\n    // aforementioned 'values' array.\n    return this.findInASTArrayByNameValue(\n      definition.values,\n      enumValueName\n    )\n  }\n\n  /**\n   * A lot of searching in ASTs is filtering through arrays and matching on\n   * subobject properties on each iteration. A common theme is find something\n   * by its `.name.value`. This method simplifies that by taking an array of\n   * AST nodes and searching them for a `.name.value` property that exists\n   * within.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀findInASTArrayByNameValue\n   * @since 2.7.0\n   *\n   * @param {Array} array of mixed AST object nodes containing `name.value`s\n   * @param {string|RegExp} name a string or regular expression used\n   * to match against the node name value\n   * @return {Object|null} the AST leaf if one matches or null otherwise.\n   */\n  static findInASTArrayByNameValue(\n    array: Array<Object>,\n    name: string | RegExp\n  ): ?Object {\n    const isRegExp: boolean = /RegExp/.test(typeOf(name));\n    const regex = !isRegExp\n      // $FlowFixMe\n      ? new RegExp(RegExp.escape(name.toString()))\n      // $FlowFixMe\n      : (name: RegExp);\n    const flags = regex.flags\n    const source = regex.source\n    const reducer = (last,cur,i) => {\n      if (last !== -1) return last;\n      if (!cur || !cur.name || !cur.name.value) return -1;\n      return new RegExp(source, flags).test(cur.name.value) ? i : -1\n    }\n    const index = array.reduce(reducer, -1);\n\n    return (~index) ? array[index] : null;\n  }\n\n  /**\n   * Query types in GraphQL are an ObjectTypeDefinition of importance for\n   * placement on the root object. There is utility in creating an empty\n   * one that can be injected with the fields of other GraphQL object query\n   * entries.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyQuery\n   *\n   * @return {SyntaxTree} an instance of SyntaxTree with a base AST generated\n   * by parsing the graph query, \"type Query {}\"\n   */\n  static EmptyQuery(): ?SyntaxTree {\n    return SyntaxTree.from(`type ${this.QUERY} {}`);\n  }\n\n  /**\n   * Mutation types in GraphQL are an ObjectTypeDefinition of importance for\n   * placement on the root object. There is utility in creating an empty\n   * one that can be injected with the fields of other GraphQL object mutation\n   * entries.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyMutation\n   *\n   * @return {SyntaxTree} an instance of SyntaxTree with a base AST generated\n   * by parsing the graph query, \"type Mutation {}\"\n   */\n  static EmptyMutation(): ?SyntaxTree {\n    return SyntaxTree.from(`type ${this.MUTATION} {}`);\n  }\n\n  /**\n   * The starting point for a SyntaxTree that will be built up programmatically.\n   *\n   * @static\n   * @memberof SyntaxTree\n   * @method ⌾⠀EmptyDocument\n   *\n   * @param {string|Object|SyntaxTree} schemaOrASTOrST any valid type taken by\n   * SyntaxTree.from() used to further populate the new empty document\n   * @return {SyntaxTree} an instance of SyntaxTree with no definitions and a\n   * kind set to 'Document'\n   */\n  static EmptyDocument(\n    schemaOrASTOrST?: string | Object | SyntaxTree\n  ): SyntaxTree {\n    let tree = new SyntaxTree();\n\n    // Due to normal validation methods with ASTs (i.e. converting to string\n    // and then back to an AST object), doing this with an empty document\n    // fails. Therefore, we manually set the document contents here. This allows\n    // toString(), consumeDefinition() and similar methods to still work.\n    tree.ast = {\n      kind: 'Document',\n      definitions: [],\n      loc: {start: 0, end: 0}\n    };\n\n    if (schemaOrASTOrST) {\n      tree.appendDefinitions(schemaOrASTOrST);\n    }\n\n    return tree;\n  }\n}\n\nexport default SyntaxTree;\n"]}