{"version":3,"sources":["../es6/SchemaUtils.js"],"names":["SchemaUtils","injectAll","schema","Classes","injectInterfaceResolvers","injectEnums","injectScalars","injectComments","DOC_CLASS","DOC_FIELDS","DOC_QUERIES","DOC_MUTATORS","DOC_SUBSCRIPTIONS","DOC_QUERY","DOC_MUTATION","DOC_SUBSCRIPTION","Class","docs","apiDocs","query","_typeMap","Query","mutation","Mutation","subscription","Subscription","type","name","fields","_fields","values","_values","description","field","value","_type","_CONST","_topCONST","length","GQL_TYPE","resolveType","_typeConfig","__enum","serialize","parseValue","parseLiteral","error","_scalarConfig","generateSchemaSDL","logOutput","EmptyDocument","log","args","console","classSchema","SCHEMA","handler","filename","basename","path","getSchema","repeat","replace","appendDefinitions","toString","createMergedRoot","requestData","separateByType","root","getMergedRoot"],"mappings":"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","file":"SchemaUtils.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nimport path from 'path'\nimport { SyntaxTree } from './SyntaxTree'\nimport { GQLBase, META_KEY } from './GQLBase'\nimport { GQLEnum } from './GQLEnum'\nimport { GQLInterface } from './GQLInterface'\nimport { GQLScalar } from './GQLScalar'\nimport { typeOf } from 'ne-types'\nimport { LatticeLogs as ll } from './utils'\nimport { merge } from 'lodash'\nimport EventEmitter from 'events'\nimport {\n  parse,\n  print,\n  buildSchema,\n  GraphQLInterfaceType,\n  GraphQLEnumType,\n  GraphQLScalarType,\n  GraphQLSchema\n} from 'graphql'\n\n/**\n * The SchemaUtils is used by tools such as GQLExpressMiddleware in order to\n * apply GraphQL Lattice specifics to the build schema.\n *\n * @class SchemaUtils\n */\nexport class SchemaUtils extends EventEmitter {\n  /**\n   * Calls all the Lattice post-schema creation routines on a given Schema\n   * using data from a supplied array of classes.\n   *\n   * @param {GraphQLSchema} schema the schema to post-process\n   * @param {Array<GQLBase>} Classes the Classes from which to drive post\n   * processing data from\n   */\n  static injectAll(schema: GraphQLSchema, Classes: Array<GQLBase>) {\n    SchemaUtils.injectInterfaceResolvers(schema, Classes);\n    SchemaUtils.injectEnums(schema, Classes);\n    SchemaUtils.injectScalars(schema, Classes);\n    SchemaUtils.injectComments(schema, Classes);\n  }\n\n  /**\n   * Until such time as I can get the reference Facebook GraphQL AST parser to\n   * read and apply descriptions or until such time as I employ the Apollo\n   * AST parser, providing a `static get apiDocs()` getter is the way to get\n   * your descriptions into the proper fields, post schema creation.\n   *\n   * This method walks the types in the registered classes and the supplied\n   * schema type. It then injects the written comments such that they can\n   * be exposed in graphiql and to applications or code that read the meta\n   * fields of a built schema\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectComments\n   * @static\n   * @since 2.7.0\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectComments(schema: Object, Classes: Array<GQLBase>) {\n    const {\n      DOC_CLASS, DOC_FIELDS, DOC_QUERIES, DOC_MUTATORS, DOC_SUBSCRIPTIONS,\n      DOC_QUERY, DOC_MUTATION, DOC_SUBSCRIPTION\n    } = GQLBase;\n\n    for (let Class of Classes) {\n      const docs = Class.apiDocs();\n      const query = schema._typeMap.Query;\n      const mutation = schema._typeMap.Mutation;\n      const subscription = schema._typeMap.Subscription;\n      let type;\n\n      if ((type = schema._typeMap[Class.name])) {\n        let fields = type._fields;\n        let values = type._values;\n\n        if (docs[DOC_CLASS]) { type.description = docs[DOC_CLASS] }\n\n        for (let field of Object.keys(docs[DOC_FIELDS] || {})) {\n          if (fields && field in fields) {\n            fields[field].description = docs[DOC_FIELDS][field];\n          }\n          if (values) {\n            for (let value of values) {\n              if (value.name === field) {\n                value.description = docs[DOC_FIELDS][field]\n              }\n            }\n          }\n        }\n      }\n\n      for (let [_type, _CONST, _topCONST] of [\n        [query, DOC_QUERIES, DOC_QUERY],\n        [mutation, DOC_MUTATORS, DOC_MUTATION],\n        [subscription, DOC_SUBSCRIPTIONS, DOC_SUBSCRIPTION]\n      ]) {\n        if (\n          _type\n          && (\n            (Object.keys(docs[_CONST] || {}).length)\n            || (docs[_topCONST] && docs[_topCONST].length)\n          )\n        ) {\n          let fields = _type._fields;\n\n          if (docs[_topCONST]) {\n            _type.description = docs[_topCONST]\n          }\n\n          for (let field of Object.keys(docs[_CONST])) {\n            if (field in fields) {\n              fields[field].description = docs[_CONST][field];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Somewhat like `injectComments` and other similar methods, the\n   * `injectInterfaceResolvers` method walks the registered classes and\n   * finds `GQLInterface` types and applies their `resolveType()`\n   * implementations.\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectInterfaceResolvers\n   * @static\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectInterfaceResolvers(schema: Object, Classes: Array<GQLBase>) {\n    for (let Class of Classes) {\n      if (Class.GQL_TYPE === GraphQLInterfaceType) {\n        schema._typeMap[Class.name].resolveType =\n        schema._typeMap[Class.name]._typeConfig.resolveType =\n          Class.resolveType;\n      }\n    }\n  }\n\n  /**\n   * Somewhat like `injectComments` and other similar methods, the\n   * `injectInterfaceResolvers` method walks the registered classes and\n   * finds `GQLInterface` types and applies their `resolveType()`\n   * implementations.\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectEnums\n   * @static\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectEnums(schema: Object, Classes: Array<GQLBase>) {\n    for (let Class of Classes) {\n      if (Class.GQL_TYPE === GraphQLEnumType) {\n        const __enum = schema._typeMap[Class.name];\n        const values = Class.values;\n\n        for (let value of __enum._values) {\n          if (value.name in values) {\n            merge(value, values[value.name])\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * GQLScalar types must define three methods to have a valid implementation.\n   * They are serialize, parseValue and parseLiteral. See their docs for more\n   * info on how to do so.\n   *\n   * This code finds each scalar and adds their implementation details to the\n   * generated schema type config.\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectScalars\n   * @static\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectScalars(schema: Object, Classes: Array<GQLBase>) {\n    for (let Class of Classes) {\n      if (Class.GQL_TYPE === GraphQLScalarType) {\n        // @ComputedType\n        const type = schema._typeMap[Class.name];\n\n        // @ComputedType\n        const { serialize, parseValue, parseLiteral } = Class;\n\n        if (!serialize || !parseValue || !parseLiteral) {\n          // @ComputedType\n          ll.error(`Scalar type ${Class.name} has invaild impl.`);\n          continue;\n        }\n\n        merge(type._scalarConfig, {\n          serialize,\n          parseValue,\n          parseLiteral\n        });\n      }\n    }\n  }\n\n  /**\n   * A function that combines the IDL schemas of all the supplied classes and\n   * returns that value to the middleware getter.\n   *\n   * @static\n   * @memberof GQLExpressMiddleware\n   * @method ⌾⠀generateSchemaSDL\n   *\n   * @return {string} a dynamically generated GraphQL IDL schema string\n   */\n  static generateSchemaSDL(\n    Classes: Array<GQLBase>,\n    logOutput: boolean = true\n  ): string {\n    let schema = SyntaxTree.EmptyDocument();\n    let log = (...args) => {\n      if (logOutput) {\n        console.log(...args);\n      }\n    }\n\n    for (let Class of Classes) {\n      let classSchema = Class.SCHEMA;\n\n      if (typeOf(classSchema) === 'Symbol') {\n        let handler = Class.handler;\n        let filename = path.basename(Class.handler.path)\n\n        classSchema = handler.getSchema();\n        log(\n          `\\nRead schema (%s)\\n%s\\n%s\\n`,\n          filename,\n          '-'.repeat(14 + filename.length),\n          classSchema.replace(/^/gm, '  ')\n        )\n      }\n\n      schema.appendDefinitions(classSchema);\n    }\n\n    log('\\nGenerated GraphQL Schema\\n----------------\\n%s', schema);\n\n    return schema.toString();\n  }\n\n  /**\n   * An asynchronous function used to parse the supplied classes for each\n   * ones resolvers and mutators. These are all combined into a single root\n   * object passed to express-graphql.\n   *\n   * @static\n   * @memberof SchemaUtils\n   * @method ⌾⠀createMergedRoot\n   *\n   * @param {Array<GQLBase>} Classes the GQLBase extended class objects or\n   * functions from which to merge the RESOLVERS and MUTATORS functions.\n   * @param {Object} requestData for Express apss, this will be an object\n   * containing { req, res, gql } where those are the Express request and\n   * response object as well as the GraphQL parameters for the request.\n   * @return {Promise<Object>} a Promise resolving to an Object containing all\n   * the functions described in both Query and Mutation types.\n   */\n  static async createMergedRoot(\n    Classes: Array<GQLBase>,\n    requestData: Object,\n    separateByType: boolean = false\n  ): Promise<Object> {\n    const root = {};\n\n    for (let Class of Classes) {\n      merge(\n        root,\n        // $FlowFixMe\n        await Class.getMergedRoot(requestData, separateByType)\n      );\n    }\n\n    return root;\n  }\n}\n\nexport default SchemaUtils\n"]}