{"version":3,"sources":["../es6/SchemaUtils.js"],"names":["SchemaUtils","schema","Classes","injectInterfaceResolvers","injectEnums","injectScalars","injectComments","DOC_CLASS","DOC_FIELDS","DOC_QUERIES","DOC_MUTATORS","DOC_SUBSCRIPTIONS","DOC_QUERY","DOC_MUTATION","DOC_SUBSCRIPTION","Class","docs","apiDocs","query","_typeMap","Query","mutation","Mutation","subscription","Subscription","type","name","fields","_fields","values","_values","description","field","value","_type","_CONST","_topCONST","length","GQL_TYPE","resolveType","_typeConfig","__enum","serialize","parseValue","parseLiteral","error","_scalarConfig","logOutput","EmptyDocument","log","classSchema","SCHEMA","handler","filename","basename","path","getSchema","repeat","replace","appendDefinitions","toString","requestData","separateByType","root","getMergedRoot"],"mappings":"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","file":"SchemaUtils.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nimport path from 'path'\nimport { SyntaxTree } from './SyntaxTree'\nimport { GQLBase, META_KEY } from './GQLBase'\nimport { GQLEnum } from './GQLEnum'\nimport { GQLInterface } from './GQLInterface'\nimport { GQLScalar } from './GQLScalar'\nimport { typeOf } from './types'\nimport { LatticeLogs as ll } from './utils'\nimport { merge } from 'lodash'\nimport EventEmitter from 'events'\nimport {\n  parse,\n  print,\n  buildSchema,\n  GraphQLInterfaceType,\n  GraphQLEnumType,\n  GraphQLScalarType,\n  GraphQLSchema\n} from 'graphql'\n\n/**\n * The SchemaUtils is used by tools such as GQLExpressMiddleware in order to\n * apply GraphQL Lattice specifics to the build schema.\n *\n * @class SchemaUtils\n */\nexport class SchemaUtils extends EventEmitter {\n  /**\n   * Calls all the Lattice post-schema creation routines on a given Schema\n   * using data from a supplied array of classes.\n   *\n   * @param {GraphQLSchema} schema the schema to post-process\n   * @param {Array<GQLBase>} Classes the Classes from which to drive post\n   * processing data from\n   */\n  static injectAll(schema: GraphQLSchema, Classes: Array<GQLBase>) {\n    SchemaUtils.injectInterfaceResolvers(schema, Classes);\n    SchemaUtils.injectEnums(schema, Classes);\n    SchemaUtils.injectScalars(schema, Classes);\n    SchemaUtils.injectComments(schema, Classes);\n  }\n\n  /**\n   * Until such time as I can get the reference Facebook GraphQL AST parser to\n   * read and apply descriptions or until such time as I employ the Apollo\n   * AST parser, providing a `static get apiDocs()` getter is the way to get\n   * your descriptions into the proper fields, post schema creation.\n   *\n   * This method walks the types in the registered classes and the supplied\n   * schema type. It then injects the written comments such that they can\n   * be exposed in graphiql and to applications or code that read the meta\n   * fields of a built schema\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectComments\n   * @static\n   * @since 2.7.0\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectComments(schema: Object, Classes: Array<GQLBase>) {\n    const {\n      DOC_CLASS, DOC_FIELDS, DOC_QUERIES, DOC_MUTATORS, DOC_SUBSCRIPTIONS,\n      DOC_QUERY, DOC_MUTATION, DOC_SUBSCRIPTION\n    } = GQLBase;\n\n    for (let Class of Classes) {\n      const docs = Class.apiDocs();\n      const query = schema._typeMap.Query;\n      const mutation = schema._typeMap.Mutation;\n      const subscription = schema._typeMap.Subscription;\n      let type;\n\n      if ((type = schema._typeMap[Class.name])) {\n        let fields = type._fields;\n        let values = type._values;\n\n        if (docs[DOC_CLASS]) { type.description = docs[DOC_CLASS] }\n\n        for (let field of Object.keys(docs[DOC_FIELDS] || {})) {\n          if (fields && field in fields) {\n            fields[field].description = docs[DOC_FIELDS][field];\n          }\n          if (values) {\n            for (let value of values) {\n              if (value.name === field) {\n                value.description = docs[DOC_FIELDS][field]\n              }\n            }\n          }\n        }\n      }\n\n      for (let [_type, _CONST, _topCONST] of [\n        [query, DOC_QUERIES, DOC_QUERY],\n        [mutation, DOC_MUTATORS, DOC_MUTATION],\n        [subscription, DOC_SUBSCRIPTIONS, DOC_SUBSCRIPTION]\n      ]) {\n        if (\n          _type\n          && (\n            (Object.keys(docs[_CONST] || {}).length)\n            || (docs[_topCONST] && docs[_topCONST].length)\n          )\n        ) {\n          let fields = _type._fields;\n\n          if (docs[_topCONST]) {\n            _type.description = docs[_topCONST]\n          }\n\n          for (let field of Object.keys(docs[_CONST])) {\n            if (field in fields) {\n              fields[field].description = docs[_CONST][field];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Somewhat like `injectComments` and other similar methods, the\n   * `injectInterfaceResolvers` method walks the registered classes and\n   * finds `GQLInterface` types and applies their `resolveType()`\n   * implementations.\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectInterfaceResolvers\n   * @static\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectInterfaceResolvers(schema: Object, Classes: Array<GQLBase>) {\n    for (let Class of Classes) {\n      if (Class.GQL_TYPE === GraphQLInterfaceType) {\n        schema._typeMap[Class.name].resolveType =\n        schema._typeMap[Class.name]._typeConfig.resolveType =\n          Class.resolveType;\n      }\n    }\n  }\n\n  /**\n   * Somewhat like `injectComments` and other similar methods, the\n   * `injectInterfaceResolvers` method walks the registered classes and\n   * finds `GQLInterface` types and applies their `resolveType()`\n   * implementations.\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectEnums\n   * @static\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectEnums(schema: Object, Classes: Array<GQLBase>) {\n    for (let Class of Classes) {\n      if (Class.GQL_TYPE === GraphQLEnumType) {\n        const __enum = schema._typeMap[Class.name];\n        const values = Class.values;\n\n        for (let value of __enum._values) {\n          if (value.name in values) {\n            merge(value, values[value.name])\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * GQLScalar types must define three methods to have a valid implementation.\n   * They are serialize, parseValue and parseLiteral. See their docs for more\n   * info on how to do so.\n   *\n   * This code finds each scalar and adds their implementation details to the\n   * generated schema type config.\n   *\n   * @memberof SchemaUtils\n   * @method ⌾⠀injectScalars\n   * @static\n   *\n   * @param {Object} schema a built GraphQLSchema object created via buildSchema\n   * or some other alternative but compatible manner\n   * @param {Function[]} Classes these are GQLBase extended classes used to\n   * manipulate the schema with.\n   */\n  static injectScalars(schema: Object, Classes: Array<GQLBase>) {\n    for (let Class of Classes) {\n      if (Class.GQL_TYPE === GraphQLScalarType) {\n        // @ComputedType\n        const type = schema._typeMap[Class.name];\n\n        // @ComputedType\n        const { serialize, parseValue, parseLiteral } = Class;\n\n        if (!serialize || !parseValue || !parseLiteral) {\n          // @ComputedType\n          ll.error(`Scalar type ${Class.name} has invaild impl.`);\n          continue;\n        }\n\n        merge(type._scalarConfig, {\n          serialize,\n          parseValue,\n          parseLiteral\n        });\n      }\n    }\n  }\n\n  /**\n   * A function that combines the IDL schemas of all the supplied classes and\n   * returns that value to the middleware getter.\n   *\n   * @static\n   * @memberof GQLExpressMiddleware\n   * @method ⌾⠀generateSchemaSDL\n   *\n   * @return {string} a dynamically generated GraphQL IDL schema string\n   */\n  static generateSchemaSDL(\n    Classes: Array<GQLBase>,\n    logOutput: boolean = true\n  ): string {\n    let schema = SyntaxTree.EmptyDocument();\n    let log = (...args) => {\n      if (logOutput) {\n        console.log(...args);\n      }\n    }\n\n    for (let Class of Classes) {\n      let classSchema = Class.SCHEMA;\n\n      if (typeOf(classSchema) === 'Symbol') {\n        let handler = Class.handler;\n        let filename = path.basename(Class.handler.path)\n\n        classSchema = handler.getSchema();\n        log(\n          `\\nRead schema (%s)\\n%s\\n%s\\n`,\n          filename,\n          '-'.repeat(14 + filename.length),\n          classSchema.replace(/^/gm, '  ')\n        )\n      }\n\n      schema.appendDefinitions(classSchema);\n    }\n\n    log('\\nGenerated GraphQL Schema\\n----------------\\n%s', schema);\n\n    return schema.toString();\n  }\n\n  /**\n   * An asynchronous function used to parse the supplied classes for each\n   * ones resolvers and mutators. These are all combined into a single root\n   * object passed to express-graphql.\n   *\n   * @static\n   * @memberof SchemaUtils\n   * @method ⌾⠀createMergedRoot\n   *\n   * @param {Array<GQLBase>} Classes the GQLBase extended class objects or\n   * functions from which to merge the RESOLVERS and MUTATORS functions.\n   * @param {Object} requestData for Express apss, this will be an object\n   * containing { req, res, gql } where those are the Express request and\n   * response object as well as the GraphQL parameters for the request.\n   * @return {Promise<Object>} a Promise resolving to an Object containing all\n   * the functions described in both Query and Mutation types.\n   */\n  static async createMergedRoot(\n    Classes: Array<GQLBase>,\n    requestData: Object,\n    separateByType: boolean = false\n  ): Promise<Object> {\n    const root = {};\n\n    for (let Class of Classes) {\n      merge(\n        root,\n        // $FlowFixMe\n        await Class.getMergedRoot(requestData, separateByType)\n      );\n    }\n\n    return root;\n  }\n}\n\nexport default SchemaUtils\n"]}