{"version":3,"sources":["../../es6/errors/AwaitingPromiseError.js"],"names":["AwaitingPromiseError","Error","constructor","error","fileName","lineNumber","NaN","message","columnNumber","name","stack","setPromise","promise","asyncFn","fn","args","result","preciseError","finalError"],"mappings":";;;;;;;;;;;AAAA;;;;AAEA;;;;;;;;;;;IAWaA,oB,WAAAA,oB,GAAN,MAAMA,oBAAN,SAAmCC,KAAnC,CAAyC;;AAoB9C;;;;;;;;;;;AAnBA;;;;;;;AA6BAC,cACEC,KADF,EAEEC,QAFF,EAGEC,aAAqBC,GAHvB,EAIE;AACA,QAAIC,UAAUJ,iBAAiBF,KAAjB,GAAyBE,MAAMI,OAA/B,GAAyCJ,KAAvD;;AAEA,UAAMI,WAAWJ,KAAjB,EAAwBC,QAAxB,EAAkCC,UAAlC;;AAEA,QAAIF,iBAAiBF,KAArB,EAA4B;AAC1B,UAAI,EAAEO,YAAF,EAAgBJ,QAAhB,EAA0BC,UAA1B,EAAsCE,OAAtC,EAA+CE,IAA/C,EAAqDC,KAArD,KAA+DP,KAAnE;;AAEA,4BAAc,IAAd,EAAoB;AAClBK,oBADkB,EACJJ,QADI,EACMC,UADN,EACkBE,OADlB,EAC2BE,IAD3B,EACiCC;AADjC,OAApB;;AAIA,WAAKP,KAAL,GAAaA,KAAb;AACD;AACF;;AAED;;;;;;;;;;;;;;;;;;;;;;;;AAxCA;;;;;;;;AA8DAQ,aAAWC,OAAX,EAA0D;AACxD,SAAKA,OAAL,GAAeA,OAAf;AACA,WAAO,IAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;AAmBA,SAAOC,OAAP,CACEV,KADF,EAEEW,EAFF,EAGEC,IAHF,EAIEC,MAJF,EAKEJ,OALF,EAMwB;AACtB,QAAIK,eAAe,6DAAgCd,KAAhC,EAAuCW,EAAvC,EAA2CC,IAA3C,EAAiDC,MAAjD,CAAnB;AACA,QAAIE,aAAa,IAAIlB,oBAAJ,CAAyBiB,YAAzB,CAAjB;;AAEA,QAAIL,OAAJ,EAAa;AACXM,iBAAWP,UAAX,CAAsBC,OAAtB;AACD;;AAED,WAAOM,UAAP;AACD;AA/G6C,C;kBAkHjClB,oB","file":"AwaitingPromiseError.js","sourceRoot":"es6","sourcesContent":["import { AsyncFunctionExecutionError } from './AsyncFunctionExecutionError'\n\n/**\n * An error that occurs while waiting for a Promise or asynchronous function\n * to resolve. Typically found in the catch() handler of a promise or the\n * try/catch handler of an `await asyncFn()` statement. In addition to an\n * error message that occurred during the asynchronous event, this error\n * can track other potentially pertinent information such as the promise\n * in question and/or an AsyncFunctionExecutionError wrapping the originally\n * thrown generic error.\n *\n * @class AwaitingPromiseError\n */\nexport class AwaitingPromiseError extends Error {\n  /**\n   * The promise that threw an error if available.\n   *\n   * @type {Promise<mixed>}\n   * @instance\n   * @memberOf AwaitingPromiseError\n   */\n  promise: Promise<mixed>\n\n  /**\n   * The error that spawned the creation of this Error instance. Specifically,\n   * it is better if this error is an instance of AsyncFunctionExecutionError\n   *\n   * @type {Error}\n   * @instance\n   * @memberOf AwaitingPromiseError\n   */\n  error: Error\n\n  /**\n   * Creates a new instance of AwaitingPromiseError. It takes the same default\n   * parameters of the core Error class.\n   *\n   * @constructor\n   *\n   * @param {Error|string} error the error or message to describe what happened\n   * @param {string} fileName the name of the file, see Error for more detail\n   * @param {number} lineNumber line number of the error, see Error for more\n   */\n  constructor(\n    error: ?Error|string,\n    fileName: ?string,\n    lineNumber: number = NaN\n  ) {\n    let message = error instanceof Error ? error.message : error\n\n    super(message || error, fileName, lineNumber)\n\n    if (error instanceof Error) {\n      let { columnNumber, fileName, lineNumber, message, name, stack } = error\n\n      Object.assign(this, {\n        columnNumber, fileName, lineNumber, message, name, stack\n      })\n\n      this.error = error\n    }\n  }\n\n  /**\n   * A promise that potentially spawned the error is something that this type\n   * of Error tracks. You can set this inline with a return statement by using\n   * this helper function.\n   *\n   * i.e.\n   * ```\n   * let promise; // define elsewhere\n   * promise\n   *   .then(result => ({}))\n   *   .catch(error => {\n   *     throw new AwaitingPromiseError(error).setPromise(promise)\n   *   })\n   * ```\n   *\n   * @method ⌾⠀setPromise\n   * @memberof AwaitingPromiseError\n   * @instance\n   *\n   * @param {Promise<mixed>} promise the promise to store as a chained call\n   * @return {AwaitingPromiseError} `this` for use in a chained function call\n   */\n  setPromise(promise: Promise<mixed>): AwaitingPromiseError {\n    this.promise = promise\n    return this\n  }\n\n  /**\n   * A static helper method that creates an error but also takes and records\n   * the additional data with regards to the associated async function call\n   * that caused the error to occur. Optionally a promise can be assigned by\n   * giving one as the last parameter.\n   *\n   * @method ⌾⠀asyncFn\n   * @memberof AwaitingPromiseError\n   * @instance\n   *\n   * @param {Error|string} error any error present at the time of failure\n   * @param {Function} fn the function that failed\n   * @param {Array<mixed>} args any arguments passed to the failed fn\n   * @param {mixed} result any result returned by the failed function\n   * @param {Promise<mixed>} promise an associated promise, if available\n   *\n   * @return {AwaitingPromiseError} a newly minted AwaitingPromiseError with\n   * all the specified data\n   */\n  static asyncFn(\n    error: (Error | string),\n    fn: ?Function,\n    args: ?Array<mixed>,\n    result: ?mixed,\n    promise: ?Promise<mixed>\n  ): AwaitingPromiseError {\n    let preciseError = new AsyncFunctionExecutionError(error, fn, args, result)\n    let finalError = new AwaitingPromiseError(preciseError)\n\n    if (promise) {\n      finalError.setPromise(promise)\n    }\n\n    return finalError\n  }\n}\n\nexport default AwaitingPromiseError"]}