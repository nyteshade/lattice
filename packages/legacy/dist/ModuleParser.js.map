{"version":3,"sources":["../es6/ModuleParser.js"],"names":["types","readdirAsync","readdir","statAsync","stat","typeOf","isString","isOfType","isPrimitive","isArray","isObject","extendsFrom","ModuleParser","directory","options","addLatticeTypes","resolve","classes","skipped","valid","statSync","isDirectory","error","filePath","moduleContents","yellow","clear","require","ignore","log","trace","set","contents","gqlDefinitions","stack","add","key","value","push","has","findGQLBaseClasses","delete","modules","files","opts","Error","constructor","walk","map","importClass","file","mod","reduce","last","cur","concat","forEach","Class","sort","l","r","name","failOnError","size","printSkipped","walkSync","outWrite","basename","message","replace","dir","filelist","extensions","exts","checkForPackageExtensions","pattern","arrayToPattern","stats","join","test","extname","flags","RegExp","toString","pkg","packageExts","Array"],"mappings":"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","file":"ModuleParser.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nimport fs, { readdirSync, statSync } from 'fs'\nimport path from 'path'\nimport * as types from './types'\nimport { GQLBase } from './GQLBase'\nimport { GQLJSON } from './types/GQLJSON'\nimport { merge } from 'lodash'\nimport {\n  promisify,\n  Deferred,\n  getLatticePrefs,\n  LatticeLogs as ll\n} from './utils'\n\n// Promisify some bits\nconst readdirAsync = promisify(fs.readdir)\nconst statAsync = promisify(fs.stat)\n\n// Fetch some type checking bits from 'types'\nconst {\n  typeOf,\n  isString,\n  isOfType,\n  isPrimitive,\n  isArray,\n  isObject,\n  extendsFrom\n} = types;\n\n/**\n * The ModuleParser is a utility class designed to loop through and iterate\n * on a directory and pull out of each .js file found, any classes or exports\n * that extend from GQLBase or a child of GQLBase.\n *\n * @class ModuleParser\n * @since 2.7.0\n */\nexport class ModuleParser {\n  /**\n   * An internal array of `GQLBase` extended classes found during either a\n   * `parse()` or `parseSync()` call.\n   *\n   * @memberof ModuleParser\n   * @type {Array<GQLBase>}\n   */\n  classes: Array<GQLBase>;\n\n  /**\n   * A map of skipped items on the last pass and the associated error that\n   * accompanies it.\n   */\n  skipped: Map<string, Error>;\n\n  /**\n   * A string denoting the directory on disk where `ModuleParser` should be\n   * searching for its classes.\n   *\n   * @memberof ModuleParser\n   * @type {string}\n   */\n  directory: string;\n\n  /**\n   * A boolean value denoting whether or not the `ModuleParser` instance is\n   * valid; i.e. the directory it points to actually exists and is a directory\n   *\n   * @type {boolean}\n   */\n  valid: boolean;\n\n  /**\n   * An object, optionally added during construction, that specifies some\n   * configuration about the ModuleParser and how it should do its job.\n   *\n   * Initially, the\n   *\n   * @type {Object}\n   */\n  options: Object = {};\n\n  /**\n   * The constructor\n   *\n   * @constructor\n   * @method ⎆⠀constructor\n   * @memberof ModuleParser\n   * @inner\n   *\n   * @param {string} directory a string path to a directory containing the\n   * various GQLBase extended classes that should be gathered.\n   */\n  constructor(directory: string, options: Object = {addLatticeTypes: true}) {\n    this.directory = path.resolve(directory);\n    this.classes = [];\n    this.skipped = new Map();\n\n    merge(this.options, options);\n\n    try {\n      this.valid = fs.statSync(directory).isDirectory();\n    }\n    catch (error) {\n      this.valid = false;\n    }\n  }\n\n  /**\n   * Given a file path, this method will attempt to import/require the\n   * file in question and return the object it exported; whatever that\n   * may be.\n   *\n   * @method ModuleParser#⌾⠀importClass\n   * @since 2.7.0\n   *\n   * @param {string} filePath a path to pass to `require()`\n   *\n   * @return {Object} the object, or undefined, that was returned when\n   * it was `require()`'ed.\n   */\n  importClass(filePath: string): Object {\n    let moduleContents: Object = {};\n    let yellow: string = '\\x1b[33m'\n    let clear: string = '\\x1b[0m'\n\n    try {\n      moduleContents = require(filePath)\n    }\n    catch(ignore) {\n      ll.log(`${yellow}Skipping${clear} ${filePath}`)\n      ll.trace(ignore)\n      this.skipped.set(filePath, ignore)\n    }\n\n    return moduleContents;\n  }\n\n  /**\n   * Given an object, typically the result of a `require()` or `import`\n   * command, iterate over its contents and find any `GQLBase` derived\n   * exports. Continually, and recursively, build this list of classes out\n   * so that we can add them to a `GQLExpressMiddleware`.\n   *\n   * @method ModuleParser#⌾⠀findGQLBaseClasses\n   * @since 2.7.0\n   *\n   * @param {Object} contents the object to parse for properties extending\n   * from `GQLBase`\n   * @param {Array<GQLBase>} gqlDefinitions the results, allowed as a second\n   * parameter during recursion as a means to save state between calls\n   * @return {Set<mixed>} a unique set of values that are currently being\n   * iterated over. Passed in as a third parameter to save state between calls\n   * during recursion.\n   */\n  findGQLBaseClasses(\n    contents: Object,\n    gqlDefinitions?: Array<GQLBase> = [],\n    stack?: Set<GQLBase> = new Set()\n  ): Array<GQLBase> {\n    // In order to prevent infinite object recursion, we should add the\n    // object being iterated over to our Set. At each new recursive level\n    // add the item being iterated over to the set and only recurse into\n    // if the item does not already exist in the stack itself.\n    stack.add(contents)\n\n    for (let key in contents) {\n      let value = contents[key];\n\n      if (isPrimitive(value)) { continue }\n\n      if (extendsFrom(value, GQLBase)) {\n        gqlDefinitions.push(value)\n      }\n\n      if ((isObject(value) || isArray(value)) && !stack.has(value)) {\n        gqlDefinitions = this.findGQLBaseClasses(value, gqlDefinitions, stack);\n      }\n    }\n\n    // We remove the current iterable from our set as we leave this current\n    // recursive iteration.\n    stack.delete(contents)\n\n    return gqlDefinitions\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   * in a resolved promise.\n   *\n   * @method ModuleParser#⌾⠀parse\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Promise<Array<GQLBase>>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  async parse(): Promise<Array<GQLBase>> {\n    let modules\n    let files\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    // @ComputedType\n    files = await this.constructor.walk(this.directory)\n    modules = files.map(file => this.importClass(file))\n\n    // @ComputedType\n    (modules\n      .map(mod => this.findGQLBaseClasses(mod))\n      .reduce((last, cur) => (last || []).concat(cur || []), [])\n      .forEach(Class => set.add(Class)))\n\n    // Convert the set back into an array\n    this.classes = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.classes.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    if (this.options.addLatticeTypes) {\n      this.classes.push(GQLJSON)\n    }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.classes;\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   *\n   * @method ModuleParser#⌾⠀parseSync\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Array<GQLBase>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  parseSync(): Array<GQLBase> {\n    let modules: Array<Object>;\n    let files: Array<string>;\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    files = this.constructor.walkSync(this.directory)\n    modules = files.map(file => {\n      return this.importClass(file)\n    })\n\n    modules\n      .map(mod => this.findGQLBaseClasses(mod))\n      .reduce((last, cur) => (last || []).concat(cur || []), [])\n      .forEach(Class => set.add(Class))\n\n    // Convert the set back into an array\n    this.classes = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.classes.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    if (this.options.addLatticeTypes) {\n      this.classes.push(GQLJSON)\n    }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.classes;\n  }\n\n  /**\n   * Prints the list of skipped files, their stack traces, and the errors\n   * denoting the reasons the files were skipped.\n   */\n  printSkipped() {\n    if (this.skipped.size) {\n      ll.outWrite('\\x1b[1;91m')\n      ll.outWrite('Skipped\\x1b[0;31m the following files\\n')\n\n      for (let [key, value] of this.skipped) {\n        ll.log(`${path.basename(key)}: ${value.message}`)\n        if (value.stack)\n          ll.log(value.stack.replace(/(^)/m, '$1  '))\n      }\n\n      ll.outWrite('\\x1b[0m')\n    }\n    else {\n      ll.log('\\x1b[1;32mNo files skipped\\x1b[0m')\n    }\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory.\n   *\n   * @method ModuleParser~⌾⠀walk\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Promise<Array<string>>} an array of existing absolute file paths\n   * found under the supplied `dir` directory.\n   */\n  static async walk(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Promise<Array<string>> {\n    let files = await readdirAsync(dir);\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = await statAsync(file)\n      if (stats.isDirectory()) {\n        filelist = await this.walk(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory. This version does this in a\n   * synchronous fashion.\n   *\n   * @method ModuleParser~⌾⠀walkSync\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Array<string>} an array of existing absolute file paths found\n   * under the supplied `dir` directory.\n   */\n  static walkSync(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Array<string> {\n    let files = readdirSync(dir)\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = statSync(file)\n      if (stats.isDirectory()) {\n        filelist = this.walkSync(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * The ModuleParser should only parse files that match the default or\n   * supplied file extensions. The default list contains .js, .jsx, .ts\n   * and .tsx; so JavaScript or TypeScript files and their JSX React\n   * counterparts\n   *\n   * Since the list is customizable for a usage, however, it makes sense\n   * to have a function that will match what is supplied rather than\n   * creating a constant expression to use instead.\n   *\n   * @static\n   * @memberof ModuleParser\n   * @function ⌾⠀arrayToPattern\n   * @since 2.13.0\n   *\n   * @param {Array<string>} extensions an array of extensions to\n   * convert to a regular expression that would pass for each\n   * @param {string} flags the value passed to a new RegExp denoting the\n   * flags used in the pattern; defaults to 'i' for case insensitivity\n   * @return {RegExp} a regular expression object matching the contents\n   * of the array of extensions or the default extensions and that will\n   * also match those values in a case insensitive manner\n   */\n  static arrayToPattern(\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx'],\n    flags: string = 'i'\n  ) {\n    return new RegExp(\n      extensions\n        .join('|')\n        .replace(/\\./g, '\\\\.')\n        .replace(/([\\|$])/g, '\\\\b$1'),\n      flags\n    )\n  }\n\n  /**\n   * Using the module `read-pkg-up`, finds the nearest package.json file\n   * and checks to see if it has a `.lattice.moduleParser.extensions'\n   * preference. If so, if the value is an array, that value is used,\n   * otherwise the value is wrapped in an array. If the optional parameter\n   * `toString` is `true` then `.toString()` will be invoked on any non\n   * Array values found; this behavior is the default\n   *\n   * @static\n   * @memberof ModuleParser\n   * @method ⌾⠀checkForPackageExtensions\n   * @since 2.13.0\n   *\n   * @param {boolean} toString true if any non-array values should have\n   * their `.toString()` method invoked before being wrapped in an Array;\n   * defaults to true\n   * @return {?Array<string>} null if no value is set for the property\n   * `lattice.ModuleParser.extensions` in `package.json` or the value\n   * of the setting if it is an array. Finally if the value is set but is\n   * not an array, the specified value wrapped in an array is returned\n   */\n  static checkForPackageExtensions(toString: boolean = true): ?Array<string> {\n    let pkg = getLatticePrefs()\n    let extensions = null\n\n    if (pkg.ModuleParser && pkg.ModuleParser.extensions) {\n      let packageExts = pkg.ModuleParser.extensions\n\n      if (Array.isArray(packageExts)) {\n        extensions = packageExts\n      }\n      else {\n        extensions = [toString ? packageExts.toString() : packageExts]\n      }\n    }\n\n    return extensions\n  }\n}\n\nexport default ModuleParser;\n"]}