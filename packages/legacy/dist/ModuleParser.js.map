{"version":3,"sources":["../es6/ModuleParser.js"],"names":["types","readdirAsync","readdir","statAsync","stat","typeOf","isString","isOfType","isPrimitive","isArray","isObject","extendsFrom","ModuleParser","constructor","directory","options","addLatticeTypes","resolve","classes","skipped","valid","statSync","isDirectory","error","importClass","filePath","moduleContents","yellow","clear","require","ignore","log","trace","set","findGQLBaseClasses","contents","gqlDefinitions","stack","add","key","value","push","has","delete","parse","modules","files","opts","Error","walk","map","file","mod","reduce","last","cur","concat","forEach","Class","sort","l","r","name","failOnError","size","printSkipped","parseSync","walkSync","outWrite","basename","message","replace","dir","filelist","extensions","exts","checkForPackageExtensions","pattern","arrayToPattern","stats","join","test","extname","flags","RegExp","toString","pkg","packageExts","Array"],"mappings":"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","file":"ModuleParser.js","sourceRoot":"es6","sourcesContent":["// @flow\n\nimport fs, { readdirSync, statSync } from 'fs'\nimport path from 'path'\nimport * as types from './types'\nimport { GQLBase } from './GQLBase'\nimport { GQLJSON } from './types/GQLJSON'\nimport { merge } from 'lodash'\nimport {\n  promisify,\n  Deferred,\n  getLatticePrefs,\n  LatticeLogs as ll\n} from './utils'\n\n// Promisify some bits\nconst readdirAsync = promisify(fs.readdir)\nconst statAsync = promisify(fs.stat)\n\n// Fetch some type checking bits from 'types'\nconst {\n  typeOf,\n  isString,\n  isOfType,\n  isPrimitive,\n  isArray,\n  isObject,\n  extendsFrom\n} = types;\n\n/**\n * The ModuleParser is a utility class designed to loop through and iterate\n * on a directory and pull out of each .js file found, any classes or exports\n * that extend from GQLBase or a child of GQLBase.\n *\n * @class ModuleParser\n * @since 2.7.0\n */\nexport class ModuleParser {\n  /**\n   * An internal array of `GQLBase` extended classes found during either a\n   * `parse()` or `parseSync()` call.\n   *\n   * @memberof ModuleParser\n   * @type {Array<GQLBase>}\n   */\n  classes: Array<GQLBase>;\n\n  /**\n   * A map of skipped items on the last pass and the associated error that\n   * accompanies it.\n   */\n  skipped: Map<string, Error>;\n\n  /**\n   * A string denoting the directory on disk where `ModuleParser` should be\n   * searching for its classes.\n   *\n   * @memberof ModuleParser\n   * @type {string}\n   */\n  directory: string;\n\n  /**\n   * A boolean value denoting whether or not the `ModuleParser` instance is\n   * valid; i.e. the directory it points to actually exists and is a directory\n   *\n   * @type {boolean}\n   */\n  valid: boolean;\n\n  /**\n   * An object, optionally added during construction, that specifies some\n   * configuration about the ModuleParser and how it should do its job.\n   *\n   * Initially, the\n   *\n   * @type {Object}\n   */\n  options: Object = {};\n\n  /**\n   * The constructor\n   *\n   * @constructor\n   * @method ⎆⠀constructor\n   * @memberof ModuleParser\n   * @inner\n   *\n   * @param {string} directory a string path to a directory containing the\n   * various GQLBase extended classes that should be gathered.\n   */\n  constructor(directory: string, options: Object = {addLatticeTypes: true}) {\n    this.directory = path.resolve(directory);\n    this.classes = [];\n    this.skipped = new Map();\n\n    merge(this.options, options);\n\n    try {\n      this.valid = fs.statSync(directory).isDirectory();\n    }\n    catch (error) {\n      this.valid = false;\n    }\n  }\n\n  /**\n   * Given a file path, this method will attempt to import/require the\n   * file in question and return the object it exported; whatever that\n   * may be.\n   *\n   * @method ModuleParser#⌾⠀importClass\n   * @since 2.7.0\n   *\n   * @param {string} filePath a path to pass to `require()`\n   *\n   * @return {Object} the object, or undefined, that was returned when\n   * it was `require()`'ed.\n   */\n  importClass(filePath: string): Object {\n    let moduleContents: Object = {};\n    let yellow: string = '\\x1b[33m'\n    let clear: string = '\\x1b[0m'\n\n    try {\n      moduleContents = require(filePath)\n    }\n    catch(ignore) {\n      ll.log(`${yellow}Skipping${clear} ${filePath}`)\n      ll.trace(ignore)\n      this.skipped.set(filePath, ignore)\n    }\n\n    return moduleContents;\n  }\n\n  /**\n   * Given an object, typically the result of a `require()` or `import`\n   * command, iterate over its contents and find any `GQLBase` derived\n   * exports. Continually, and recursively, build this list of classes out\n   * so that we can add them to a `GQLExpressMiddleware`.\n   *\n   * @method ModuleParser#⌾⠀findGQLBaseClasses\n   * @since 2.7.0\n   *\n   * @param {Object} contents the object to parse for properties extending\n   * from `GQLBase`\n   * @param {Array<GQLBase>} gqlDefinitions the results, allowed as a second\n   * parameter during recursion as a means to save state between calls\n   * @return {Set<mixed>} a unique set of values that are currently being\n   * iterated over. Passed in as a third parameter to save state between calls\n   * during recursion.\n   */\n  findGQLBaseClasses(\n    contents: Object,\n    gqlDefinitions?: Array<GQLBase> = [],\n    stack?: Set<GQLBase> = new Set()\n  ): Array<GQLBase> {\n    // In order to prevent infinite object recursion, we should add the\n    // object being iterated over to our Set. At each new recursive level\n    // add the item being iterated over to the set and only recurse into\n    // if the item does not already exist in the stack itself.\n    stack.add(contents)\n\n    for (let key in contents) {\n      let value = contents[key];\n\n      if (isPrimitive(value)) { continue }\n\n      if (extendsFrom(value, GQLBase)) {\n        gqlDefinitions.push(value)\n      }\n\n      if ((isObject(value) || isArray(value)) && !stack.has(value)) {\n        gqlDefinitions = this.findGQLBaseClasses(value, gqlDefinitions, stack);\n      }\n    }\n\n    // We remove the current iterable from our set as we leave this current\n    // recursive iteration.\n    stack.delete(contents)\n\n    return gqlDefinitions\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   * in a resolved promise.\n   *\n   * @method ModuleParser#⌾⠀parse\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Promise<Array<GQLBase>>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  async parse(): Promise<Array<GQLBase>> {\n    let modules\n    let files\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    // @ComputedType\n    files = await this.constructor.walk(this.directory)\n    modules = files.map(file => this.importClass(file))\n\n    // @ComputedType\n    (modules\n      .map(mod => this.findGQLBaseClasses(mod))\n      .reduce((last, cur) => (last || []).concat(cur || []), [])\n      .forEach(Class => set.add(Class)))\n\n    // Convert the set back into an array\n    this.classes = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.classes.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    if (this.options.addLatticeTypes) {\n      this.classes.push(GQLJSON)\n    }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.classes;\n  }\n\n  /**\n   * This method takes a instance of ModuleParser, initialized with a directory,\n   * and walks its contents, importing files as they are found, and sorting\n   * any exports that extend from GQLBase into an array of such classes\n   *\n   * @method ModuleParser#⌾⠀parseSync\n   * @async\n   * @since 2.7.0\n   *\n   * @return {Array<GQLBase>} an array GQLBase classes, or an empty\n   * array if none could be identified.\n   */\n  parseSync(): Array<GQLBase> {\n    let modules: Array<Object>;\n    let files: Array<string>;\n    let set = new Set();\n    let opts = getLatticePrefs()\n\n    if (!this.valid) {\n      throw new Error(`\n        ModuleParser instance is invalid for use with ${this.directory}.\n        The path is either a non-existent path or it does not represent a\n        directory.\n      `)\n    }\n\n    this.skipped.clear()\n\n    files = this.constructor.walkSync(this.directory)\n    modules = files.map(file => {\n      return this.importClass(file)\n    })\n\n    modules\n      .map(mod => this.findGQLBaseClasses(mod))\n      .reduce((last, cur) => (last || []).concat(cur || []), [])\n      .forEach(Class => set.add(Class))\n\n    // Convert the set back into an array\n    this.classes = Array.from(set);\n\n    // We can ignore equality since we came from a set; @ComputedType\n    this.classes.sort((l,r) => l.name < r.name ? -1 : 1)\n\n    // Add in any GraphQL Lattice types requested\n    if (this.options.addLatticeTypes) {\n      this.classes.push(GQLJSON)\n    }\n\n    // Stop flow and throw an error if some files failed to load and settings\n    // declare we should do so. After Lattice 3.x we should expect this to be\n    // the new default\n    if (opts.ModuleParser.failOnError && this.skipped.size) {\n      this.printSkipped()\n      throw new Error('Some files skipped due to errors')\n    }\n\n    return this.classes;\n  }\n\n  /**\n   * Prints the list of skipped files, their stack traces, and the errors\n   * denoting the reasons the files were skipped.\n   */\n  printSkipped() {\n    if (this.skipped.size) {\n      ll.outWrite('\\x1b[1;91m')\n      ll.outWrite('Skipped\\x1b[0;31m the following files\\n')\n\n      for (let [key, value] of this.skipped) {\n        ll.log(`${path.basename(key)}: ${value.message}`)\n        if (value.stack)\n          ll.log(value.stack.replace(/(^)/m, '$1  '))\n      }\n\n      ll.outWrite('\\x1b[0m')\n    }\n    else {\n      ll.log('\\x1b[1;32mNo files skipped\\x1b[0m')\n    }\n  }\n\n  /**\n   * Returns the `constructor` name. If invoked as the context, or `this`,\n   * object of the `toString` method of `Object`'s `prototype`, the resulting\n   * value will be `[object MyClass]`, given an instance of `MyClass`\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   *\n   * @return {string} the name of the class this is an instance of\n   * @ComputedType\n   */\n  get [Symbol.toStringTag]() { return this.constructor.name }\n\n  /**\n   * Applies the same logic as {@link #[Symbol.toStringTag]} but on a static\n   * scale. So, if you perform `Object.prototype.toString.call(MyClass)`\n   * the result would be `[object MyClass]`.\n   *\n   * @method ⌾⠀[Symbol.toStringTag]\n   * @memberof ModuleParser\n   * @static\n   *\n   * @return {string} the name of this class\n   * @ComputedType\n   */\n  static get [Symbol.toStringTag]() { return this.name }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory.\n   *\n   * @method ModuleParser~⌾⠀walk\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Promise<Array<string>>} an array of existing absolute file paths\n   * found under the supplied `dir` directory.\n   */\n  static async walk(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Promise<Array<string>> {\n    let files = await readdirAsync(dir);\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = await statAsync(file)\n      if (stats.isDirectory()) {\n        filelist = await this.walk(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * Recursively walks a directory and returns an array of asbolute file paths\n   * to the files under the specified directory. This version does this in a\n   * synchronous fashion.\n   *\n   * @method ModuleParser~⌾⠀walkSync\n   * @async\n   * @since 2.7.0\n   *\n   * @param {string} dir string path to the top level directory to parse\n   * @param {Array<string>} filelist an array of existing absolute file paths,\n   * or if not parameter is supplied a default empty array will be used.\n   * @return {Array<string>} an array of existing absolute file paths found\n   * under the supplied `dir` directory.\n   */\n  static walkSync(\n    dir: string,\n    filelist: Array<string> = [],\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx']\n  ): Array<string> {\n    let files = readdirSync(dir)\n    let exts = ModuleParser.checkForPackageExtensions() || extensions\n    let pattern = ModuleParser.arrayToPattern(exts)\n    let stats\n\n    files = files.map(file => path.resolve(path.join(dir, file)))\n\n    for (let file of files) {\n      stats = statSync(file)\n      if (stats.isDirectory()) {\n        filelist = this.walkSync(file, filelist)\n      }\n      else {\n        if (pattern.test(path.extname(file)))\n          filelist = filelist.concat(file);\n      }\n    }\n\n    return filelist;\n  }\n\n  /**\n   * The ModuleParser should only parse files that match the default or\n   * supplied file extensions. The default list contains .js, .jsx, .ts\n   * and .tsx; so JavaScript or TypeScript files and their JSX React\n   * counterparts\n   *\n   * Since the list is customizable for a usage, however, it makes sense\n   * to have a function that will match what is supplied rather than\n   * creating a constant expression to use instead.\n   *\n   * @static\n   * @memberof ModuleParser\n   * @function ⌾⠀arrayToPattern\n   * @since 2.13.0\n   *\n   * @param {Array<string>} extensions an array of extensions to\n   * convert to a regular expression that would pass for each\n   * @param {string} flags the value passed to a new RegExp denoting the\n   * flags used in the pattern; defaults to 'i' for case insensitivity\n   * @return {RegExp} a regular expression object matching the contents\n   * of the array of extensions or the default extensions and that will\n   * also match those values in a case insensitive manner\n   */\n  static arrayToPattern(\n    extensions: Array<string> = ['.js', '.jsx', '.ts', '.tsx'],\n    flags: string = 'i'\n  ) {\n    return new RegExp(\n      extensions\n        .join('|')\n        .replace(/\\./g, '\\\\.')\n        .replace(/([\\|$])/g, '\\\\b$1'),\n      flags\n    )\n  }\n\n  /**\n   * Using the module `read-pkg-up`, finds the nearest package.json file\n   * and checks to see if it has a `.lattice.moduleParser.extensions'\n   * preference. If so, if the value is an array, that value is used,\n   * otherwise the value is wrapped in an array. If the optional parameter\n   * `toString` is `true` then `.toString()` will be invoked on any non\n   * Array values found; this behavior is the default\n   *\n   * @static\n   * @memberof ModuleParser\n   * @method ⌾⠀checkForPackageExtensions\n   * @since 2.13.0\n   *\n   * @param {boolean} toString true if any non-array values should have\n   * their `.toString()` method invoked before being wrapped in an Array;\n   * defaults to true\n   * @return {?Array<string>} null if no value is set for the property\n   * `lattice.ModuleParser.extensions` in `package.json` or the value\n   * of the setting if it is an array. Finally if the value is set but is\n   * not an array, the specified value wrapped in an array is returned\n   */\n  static checkForPackageExtensions(toString: boolean = true): ?Array<string> {\n    let pkg = getLatticePrefs()\n    let extensions = null\n\n    if (pkg.ModuleParser && pkg.ModuleParser.extensions) {\n      let packageExts = pkg.ModuleParser.extensions\n\n      if (Array.isArray(packageExts)) {\n        extensions = packageExts\n      }\n      else {\n        extensions = [toString ? packageExts.toString() : packageExts]\n      }\n    }\n\n    return extensions\n  }\n}\n\nexport default ModuleParser;\n"]}