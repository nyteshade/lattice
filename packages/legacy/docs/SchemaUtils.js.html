<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>SchemaUtils.js</title>





    <link type="text/css" rel="stylesheet" href="github.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <script src="scripts/highlight.js"></script>
    <script src="scripts/linenumber.js"></script>
    

    <script>hljs && hljs.initHighlightingOnLoad();</script>
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>
<label for="nav-trigger" class="overlay"></label>

<div class="page">
  <header class="page-header">
    <h1 class="project-name">
  <a href="/">graphql-lattice</a>

</h1>
<h2 class="project-tagline">
  OO Underpinnings for ease of GraphQL Implementation
</h2>

<h2 class="project-version">
  2.7.0
</h2>

  </header>
  <div class="page-contents">
    <nav class="sidebar">
        <h2 class="home"><a href="index.html">Home</a></h2><h3 data-name="Classes">Classes</h3><ul><li><a href="DirectTypeAdd.html">DirectTypeAdd</a></li><li><a href="GQLBase.html">GQLBase</a><ul class='methods'><li data-type='method'><a href="GQLBase.html#.%25E2%258C%25BE%25E2%25A0%2580IDLFilePath">⌾⠀IDLFilePath</a></li><li data-type='method'><a href="GQLBase.html#.%25E2%258C%25BE%25E2%25A0%2580MUTATORS">⌾⠀MUTATORS</a></li><li data-type='method'><a href="GQLBase.html#.%25E2%258C%25BE%25E2%25A0%2580setupModel">⌾⠀setupModel</a></li><li data-type='method'><a href="GQLBase.html#%25E2%258C%25BE%25E2%25A0%2580getModel">⌾⠀getModel</a></li><li data-type='method'><a href="GQLBase.html#%25E2%25AC%2586%25EF%25B8%258E%25E2%25A0%2580requestData">⬆︎⠀requestData</a></li></ul></li><li><a href="GQLBase.%25E2%258E%2586%25E2%25A0%2580constructor.html">⎆⠀constructor</a></li><li><a href="GQLEnum.html">GQLEnum</a><ul class='methods'><li data-type='method'><a href="GQLEnum.html#.valueFor">valueFor</a></li><li data-type='method'><a href="GQLEnum.html#GenerateEnumsProxyHandler">GenerateEnumsProxyHandler</a></li><li data-type='method'><a href="GQLEnum.html#~get">get</a></li><li data-type='method'><a href="GQLEnum.html#~set">~set</a></li></ul></li><li><a href="GQLExpressMiddleware.html">GQLExpressMiddleware</a><ul class='methods'><li data-type='method'><a href="GQLExpressMiddleware.html#%25E2%258C%25BE%25E2%25A0%2580customMiddleware">⌾⠀customMiddleware</a></li><li data-type='method'><a href="GQLExpressMiddleware.html#%25E2%25AC%2587%25EF%25B8%258E%25E2%25A0%2580schema">⬇︎⠀schema</a></li></ul></li><li><a href="GQLExpressMiddleware.%25E2%258E%2586%25E2%25A0%2580constructor.html">⎆⠀constructor</a></li><li><a href="GQLInterface.html">GQLInterface</a><ul class='methods'><li data-type='method'><a href="GQLInterface.html#.%25E2%258C%25BE%25E2%25A0%2580resolveType">⌾⠀resolveType</a></li></ul></li><li><a href="GQLScalar.html">GQLScalar</a><ul class='methods'><li data-type='method'><a href="GQLScalar.html#.serialize">serialize</a></li></ul></li><li><a href="IDLFileHandler.html">IDLFileHandler</a><ul class='methods'><li data-type='method'><a href="IDLFileHandler.html#%25E2%258C%25BE%25E2%25A0%2580getFile">⌾⠀getFile</a></li></ul></li><li><a href="IDLFileHandler.%25E2%258E%2586%25E2%25A0%2580constructor.html">⎆⠀constructor</a></li><li><a href="ModuleParser.html">ModuleParser</a><ul class='methods'><li data-type='method'><a href="ModuleParser.html#.ModuleParser">ModuleParser</a></li><li data-type='method'><a href="ModuleParser.html#%25E2%258C%25BE%25E2%25A0%2580importClass">⌾⠀importClass</a></li><li data-type='method'><a href="ModuleParser.html#~walk">walk</a></li><li data-type='method'><a href="ModuleParser.html#~%25E2%258E%2586%25E2%25A0%2580constructor">⎆⠀constructor</a></li></ul></li><li><a href="SchemaUtils.html">SchemaUtils</a><ul class='methods'><li data-type='method'><a href="SchemaUtils.html#.%25E2%258C%25BE%25E2%25A0%2580injectComments">⌾⠀injectComments</a></li></ul></li><li><a href="SyntaxTree.html">SyntaxTree</a><ul class='methods'><li data-type='method'><a href="SyntaxTree.html#.%25E2%258C%25BE%25E2%25A0%2580from">⌾⠀from</a></li><li data-type='method'><a href="SyntaxTree.html#.%25E2%258E%2586%25E2%25A0%2580constructor">⎆⠀constructor</a></li><li data-type='method'><a href="SyntaxTree.html#%25E2%258C%25BE%25E2%25A0%2580setAST">⌾⠀setAST</a></li><li data-type='method'><a href="SyntaxTree.html#%25E2%25AC%2586%25EF%25B8%258E%25E2%25A0%2580ast">⬆︎⠀ast</a></li><li data-type='method'><a href="SyntaxTree.html#%25E2%25AC%2587%25EF%25B8%258E%25E2%25A0%2580ast">⬇︎⠀ast</a></li></ul></li><li><a href="utils.Deferred.html">Deferred</a></li></ul><h3 data-name="Namespaces">Namespaces</h3><ul><li><a href="decorators.html">decorators</a><ul class='methods'><li data-type='method'><a href="decorators.html#..AdjacentSchema">.AdjacentSchema</a></li><li data-type='method'><a href="decorators.html#..FileSchema">.FileSchema</a></li><li data-type='method'><a href="decorators.html#..Schema">.Schema</a></li><li data-type='method'><a href="decorators.html#.%25E2%258C%25BE%25E2%25A0%2580extractBits">⌾⠀extractBits</a></li><li data-type='method'><a href="decorators.html#..%25F0%259F%258F%25B7%25E2%25A0%2580Getters">.🏷⠀Getters</a></li><li data-type='method'><a href="decorators.html#..%25F0%259F%258F%25B7%25E2%25A0%2580Properties">.🏷⠀Properties</a></li><li data-type='method'><a href="decorators.html#..%25F0%259F%258F%25B7%25E2%25A0%2580Setters">.🏷⠀Setters</a></li></ul></li><li><a href="GQLBaseEnv.html">GQLBaseEnv</a><ul class='methods'><li data-type='method'><a href="GQLBaseEnv.html#~notDefined">notDefined</a></li></ul></li><li><a href="global.html#types">types</a><ul class='methods'><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580extendsFrom">⌾⠀extendsFrom</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isArray">⌾⠀isArray</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isClass">⌾⠀isClass</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isDate">⌾⠀isDate</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isFunction">⌾⠀isFunction</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isNativeClassByProps">⌾⠀isNativeClassByProps</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isNativeClassByString">⌾⠀isNativeClassByString</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isNull">⌾⠀isNull</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isNumber">⌾⠀isNumber</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isObject">⌾⠀isObject</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isOfType">⌾⠀isOfType</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isPrimitive">⌾⠀isPrimitive</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isRegExp">⌾⠀isRegExp</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isString">⌾⠀isString</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isUndefined">⌾⠀isUndefined</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580isValue">⌾⠀isValue</a></li><li data-type='method'><a href="global.html#types#~%25E2%258C%25BE%25E2%25A0%2580typeOf">⌾⠀typeOf</a></li></ul></li><li><a href="utils.html">utils</a><ul class='methods'><li data-type='method'><a href="utils.html#.joinLines">joinLines</a></li><li data-type='method'><a href="utils.html#~promisify">promisify</a></li></ul></li></ul><h3>global</h3><ul><li><a href="global.html#deleteProperty">deleteProperty</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#%25E2%25AC%2587%25EF%25B8%258E%25E2%25A0%2580name">⬇︎⠀name</a></li></ul>
    </nav>

    <div id="main">
        
        <h1 class="page-title">SchemaUtils.js</h1>
        

        



    
    <section>
        <article>
            <pre class="source linenums"><code class="hljs js">// @flow

import path from 'path'
import { SyntaxTree } from './SyntaxTree'
import { GQLBase } from './GQLBase'
import { GQLEnum } from './GQLEnum'
import { GQLInterface } from './GQLInterface'
import { GQLScalar } from './GQLScalar'
import { typeOf } from './types'
import EventEmitter from 'events'
import {
  parse,
  print,
  buildSchema,
  GraphQLInterfaceType,
  GraphQLEnumType,
  GraphQLScalarType
} from 'graphql'

/**
 * The SchemaUtils is used by tools such as GQLExpressMiddleware in order to
 * apply GraphQL Lattice specifics to the build schema.
 *
 * @class SchemaUtils
 */
export class SchemaUtils extends EventEmitter {
  /**
   * Until such time as I can get the reference Facebook GraphQL AST parser to
   * read and apply descriptions or until such time as I employ the Apollo
   * AST parser, providing a `static get apiDocs()` getter is the way to get
   * your descriptions into the proper fields, post schema creation.
   *
   * This method walks the types in the registered classes and the supplied
   * schema type. It then injects the written comments such that they can
   * be exposed in graphiql and to applications or code that read the meta
   * fields of a built schema
   *
   * @memberof SchemaUtils
   * @method ⌾⠀injectComments
   * @static
   * @since 2.7.0
   *
   * @param {Object} schema a built GraphQLSchema object created via buildSchema
   * or some other alternative but compatible manner
   * @param {Function[]} Classes these are GQLBase extended classes used to 
   * manipulate the schema with.
   */
  static injectComments(schema: Object, Classes: Array&lt;GQLBase>) {
    const {
      DOC_CLASS, DOC_FIELDS, DOC_QUERIES, DOC_MUTATORS, DOC_SUBSCRIPTIONS
    } = GQLBase;

    for (let Class of Classes) {
      const docs = Class.apiDocs();
      const query = schema._typeMap.Query;
      const mutation = schema._typeMap.Mutation;
      const subscription = schema._typeMap.Subscription;
      let type;

      if ((type = schema._typeMap[Class.name])) {
        let fields = type._fields;
        let values = type._values;

        if (docs[DOC_CLASS]) { type.description = docs[DOC_CLASS] }

        for (let field of Object.keys(docs[DOC_FIELDS] || {})) {
          if (fields &amp;&amp; field in fields) {
            fields[field].description = docs[DOC_FIELDS][field];
          }
          if (values) {
            for (let value of values) {
              if (value.name === field) {
                value.description = docs[DOC_FIELDS][field]
              }
            }
          }
        }
      }

      for (let [_type, _CONST] of [
        [query, DOC_QUERIES],
        [mutation, DOC_MUTATORS],
        [subscription, DOC_SUBSCRIPTIONS]
      ]) {
        if (_type &amp;&amp; Object.keys(docs[_CONST] || {}).length) {
          let fields = _type._fields;

          if (docs[_CONST][DOC_CLASS]) {
            _type.description = docs[_CONST][DOC_CLASS]
          }

          for (let field of Object.keys(docs[_CONST])) {
            if (field in fields) {
              fields[field].description = docs[_CONST][field];
            }
          }
        }
      }
    }
  }

  /**
   * Somewhat like `injectComments` and other similar methods, the
   * `injectInterfaceResolvers` method walks the registered classes and
   * finds `GQLInterface` types and applies their `resolveType()`
   * implementations.
   *
   * @memberof SchemaUtils
   * @method ⌾⠀injectInterfaceResolvers
   * @static
   *
   * @param {Object} schema a built GraphQLSchema object created via buildSchema
   * or some other alternative but compatible manner
   * @param {Function[]} Classes these are GQLBase extended classes used to 
   * manipulate the schema with.
   */
  static injectInterfaceResolvers(schema: Object, Classes: Array&lt;GQLBase>) {
    for (let Class of Classes) {
      if (Class.GQL_TYPE === GraphQLInterfaceType) {
        schema._typeMap[Class.name].resolveType =
        schema._typeMap[Class.name]._typeConfig.resolveType =
          Class.resolveType;
      }
    }
  }

  /**
   * Somewhat like `injectComments` and other similar methods, the
   * `injectInterfaceResolvers` method walks the registered classes and
   * finds `GQLInterface` types and applies their `resolveType()`
   * implementations.
   *
   * @memberof SchemaUtils
   * @method ⌾⠀injectEnums
   * @static
   *
   * @param {Object} schema a built GraphQLSchema object created via buildSchema
   * or some other alternative but compatible manner
   * @param {Function[]} Classes these are GQLBase extended classes used to 
   * manipulate the schema with.
   */
  static injectEnums(schema: Object, Classes: Array&lt;GQLBase>) {
    for (let Class of Classes) {
      if (Class.GQL_TYPE === GraphQLEnumType) {
        const __enum = schema._typeMap[Class.name];
        const values = Class.values;

        for (let value of __enum._values) {
          if (value.name in values) {
            Object.assign(value, values[value.name])
          }
        }
      }
    }
  }
  
  /**
   * GQLScalar types must define three methods to have a valid implementation.
   * They are serialize, parseValue and parseLiteral. See their docs for more 
   * info on how to do so.
   *
   * This code finds each scalar and adds their implementation details to the 
   * generated schema type config.
   *
   * @memberof SchemaUtils
   * @method ⌾⠀injectScalars
   * @static
   * 
   * @param {Object} schema a built GraphQLSchema object created via buildSchema
   * or some other alternative but compatible manner
   * @param {Function[]} Classes these are GQLBase extended classes used to 
   * manipulate the schema with.
   */
  static injectScalars(schema: Object, Classes: Array&lt;GQLBase>) {
    for (let Class of Classes) {
      if (Class.GQL_TYPE === GraphQLScalarType) {
        // @ComputedType
        const type = schema._typeMap[Class.name];
        
        // @ComputedType
        const { serialize, parseValue, parseLiteral } = Class;

        // @ComputedType
        console.dir(Class.name, type);
        
        if (!serialize || !parseValue || !parseLiteral) {
          // @ComputedType
          console.error(`Scalar type ${Class.name} has invaild impl.`);
          continue;
        }
        
        Object.assign(type._scalarConfig, {
          serialize,
          parseValue,
          parseLiteral
        });
      }
    }
  } 
  
  /**
   * A function that combines the IDL schemas of all the supplied classes and
   * returns that value to the middleware getter.
   *
   * @static
   * @memberof GQLExpressMiddleware
   * @method ⌾⠀generateSchemaSDL
   *
   * @return {string} a dynamically generated GraphQL IDL schema string
   */
  static generateSchemaSDL(
    Classes: Array&lt;GQLBase>, 
    logOutput: boolean = true
  ): string {
    let schema = SyntaxTree.EmptyDocument();
    let log = (...args) => {
      if (logOutput) {
        console.log(...args);
      }
    }

    for (let Class of Classes) {
      let classSchema = Class.SCHEMA;

      if (typeOf(classSchema) === 'Symbol') {
        let handler = Class.handler;
        let filename = path.basename(Class.handler.path)

        classSchema = handler.getSchema();
        log(
          `\nRead schema (%s)\n%s\n%s\n`,
          filename,
          '-'.repeat(14 + filename.length),
          classSchema.replace(/^/gm, '  ')
        )
      }

      schema.appendDefinitions(classSchema);
    }

    log('\nGenerated GraphQL Schema\n----------------\n%s', schema);

    return schema.toString();
  }
  
  /**
   * An asynchronous function used to parse the supplied classes for each
   * ones resolvers and mutators. These are all combined into a single root
   * object passed to express-graphql.
   *
   * @static
   * @memberof SchemaUtils
   * @method ⌾⠀createMergedRoot
   *
   * @param {Function[]} Classes the GQLBase extended class objects or 
   * functions from which to merge the RESOLVERS and MUTATORS functions.
   * @param {Object} requestData for Express apss, this will be an object 
   * containing { req, res, gql } where those are the Express request and 
   * response object as well as the GraphQL parameters for the request. 
   * @return {Promise&lt;Object>} a Promise resolving to an Object containing all
   * the functions described in both Query and Mutation types.
   */
  static async createMergedRoot(
    Classes: Function[], 
    requestData: Object
  ): Promise&lt;Object> {
    const root = {};

    for (let Class of Classes) {
      Object.assign(
        root,
        await Class.RESOLVERS(requestData),
        await Class.MUTATORS(requestData)
      );
    }

    return root;
  }  
}</code></pre>
        </article>
    </section>
    <script type="text/javascript">
      hljs.lineNumbersBlock(d3.select('.source .hljs').node())
    </script>





    </div>
  </div>
</div>

<br class="clear">
<footer>
    <span>graphql-lattice</span> docs generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Sep 21 2017 using the <a href="https://github.com/mere/kitsune">Kitsune</a> theme.
</footer>


<script src="scripts/linenumber.js"></script>
</body>
</html>
